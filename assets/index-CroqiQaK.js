(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const r6=Symbol.for("@libp2p/connection"),As=Symbol.for("@libp2p/content-routing"),Qo=Symbol.for("@libp2p/peer-discovery"),Ou=Symbol.for("@libp2p/peer-id");function v0(n){return!!n?.[Ou]}const Ts=Symbol.for("@libp2p/peer-routing"),Wa="keep-alive",Yo="StrictSign",Fu="StrictNoSign";var Vt;(function(n){n.Accept="accept",n.Ignore="ignore",n.Reject="reject"})(Vt||(Vt={}));const Ga=Symbol.for("@libp2p/transport");var Ss;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(Ss||(Ss={}));let Un=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class n6 extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}class B extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class Xo extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class E0 extends Error{static name="InvalidPrivateKeyError";constructor(e="Invalid private key"){super(e),this.name="InvalidPrivateKeyError"}}class s6 extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class S0 extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class _0 extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class ms extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class i6 extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Nl extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let It=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class x0 extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class Uu extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class o6 extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class $u extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class Qa extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class Pe extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class a6 extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Ya=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class Ri extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Ei extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Bl extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class k0 extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class c6 extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Vu extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Xs extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class Ke extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return r==null||(r=r.filter(({once:s})=>!s),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function Hu(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function Nr(...n){const e=[];for(const t of n)Hu(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function wn(...n){const e=[];for(const t of n)Hu(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const rt=Symbol.for("@libp2p/service-capabilities"),cn=Symbol.for("@libp2p/service-dependencies");function l6(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function Zs(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function u6(n){return new TextEncoder().encode(n)}function h6(n){return new TextDecoder().decode(n)}function d6(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var s=0;s<n.length;s++){var i=n.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=n.length,c=n.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var m=0,g=0,y=0,b=p.length;y!==b&&p[y]===0;)y++,m++;for(var w=(b-y)*u+1>>>0,k=new Uint8Array(w);y!==b;){for(var _=p[y],A=0,I=w-1;(_!==0||A<g)&&I!==-1;I--,A++)_+=256*k[I]>>>0,k[I]=_%a>>>0,_=_/a>>>0;if(_!==0)throw new Error("Non-zero carry");g=A,y++}for(var D=w-g;D!==w&&k[D]===0;)D++;for(var v=c.repeat(m);D<w;++D)v+=n.charAt(k[D]);return v}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var m=0;if(p[m]!==" "){for(var g=0,y=0;p[m]===c;)g++,m++;for(var b=(p.length-m)*l+1>>>0,w=new Uint8Array(b);p[m];){var k=t[p.charCodeAt(m)];if(k===255)return;for(var _=0,A=b-1;(k!==0||_<y)&&A!==-1;A--,_++)k+=a*w[A]>>>0,w[A]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");y=_,m++}if(p[m]!==" "){for(var I=b-y;I!==b&&w[I]===0;)I++;for(var D=new Uint8Array(g+(b-I)),v=g;I!==b;)D[v++]=w[I++];return D}}}function f(p){var m=d(p);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:d,decode:f}}var f6=d6,p6=f6;let g6=class{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},m6=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return I0(this,e)}};class y6{decoders;constructor(e){this.decoders=e}or(e){return I0(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function I0(n,e){return new y6({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}class w6{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,s){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=s,this.encoder=new g6(e,t,r),this.decoder=new m6(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Xa({name:n,prefix:e,encode:t,decode:r}){return new w6(n,e,t,r)}function Ji({name:n,prefix:e,alphabet:t}){const{encode:r,decode:s}=p6(t,n);return Xa({prefix:e,name:n,encode:r,decode:i=>Zs(s(i))})}function b6(n,e,t,r){const s={};for(let u=0;u<e.length;++u)s[e[u]]=u;let i=n.length;for(;n[i-1]==="=";)--i;const o=new Uint8Array(i*t/8|0);let a=0,c=0,l=0;for(let u=0;u<i;++u){const h=s[n[u]];if(h===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<t|h,a+=t,a>=8&&(a-=8,o[l++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o}function v6(n,e,t){const r=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),r)for(;i.length*t&7;)i+="=";return i}function nt({name:n,prefix:e,bitsPerChar:t,alphabet:r}){return Xa({prefix:e,name:n,encode(s){return v6(s,r,t)},decode(s){return b6(s,r,t,n)}})}const ze=Ji({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),E6=Ji({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),S6=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ze,base58flickr:E6},Symbol.toStringTag,{value:"Module"})),xt=nt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),_6=nt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),x6=nt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),k6=nt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),I6=nt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),A6=nt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),T6=nt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),P6=nt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),C6=nt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),D6=Object.freeze(Object.defineProperty({__proto__:null,base32:xt,base32hex:I6,base32hexpad:T6,base32hexpadupper:P6,base32hexupper:A6,base32pad:x6,base32padupper:k6,base32upper:_6,base32z:C6},Symbol.toStringTag,{value:"Module"})),Mn=Ji({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),R6=Ji({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),M6=Object.freeze(Object.defineProperty({__proto__:null,base36:Mn,base36upper:R6},Symbol.toStringTag,{value:"Module"}));var L6=A0,fd=128,N6=-128,B6=Math.pow(2,31);function A0(n,e,t){e=e||[],t=t||0;for(var r=t;n>=B6;)e[t++]=n&255|fd,n/=128;for(;n&N6;)e[t++]=n&255|fd,n>>>=7;return e[t]=n|0,A0.bytes=t-r+1,e}var O6=Ol,F6=128,pd=127;function Ol(n,r){var t=0,r=r||0,s=0,i=r,o,a=n.length;do{if(i>=a)throw Ol.bytes=0,new RangeError("Could not decode varint");o=n[i++],t+=s<28?(o&pd)<<s:(o&pd)*Math.pow(2,s),s+=7}while(o>=F6);return Ol.bytes=i-r,t}var U6=Math.pow(2,7),$6=Math.pow(2,14),V6=Math.pow(2,21),H6=Math.pow(2,28),z6=Math.pow(2,35),q6=Math.pow(2,42),K6=Math.pow(2,49),W6=Math.pow(2,56),G6=Math.pow(2,63),Q6=function(n){return n<U6?1:n<$6?2:n<V6?3:n<H6?4:n<z6?5:n<q6?6:n<K6?7:n<W6?8:n<G6?9:10},Y6={encode:L6,decode:O6,encodingLength:Q6},Zo=Y6;function Fl(n,e=0){return[Zo.decode(n,e),Zo.decode.bytes]}function jo(n,e,t=0){return Zo.encode(n,e,t),e}function Jo(n){return Zo.encodingLength(n)}function Br(n,e){const t=e.byteLength,r=Jo(n),s=r+Jo(t),i=new Uint8Array(s+t);return jo(n,i,0),jo(t,i,r),i.set(e,s),new zu(n,t,e,i)}function je(n){const e=Zs(n),[t,r]=Fl(e),[s,i]=Fl(e.subarray(r)),o=e.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new zu(t,s,o,e)}function X6(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&l6(n.bytes,t.bytes)}}class zu{code;size;digest;bytes;constructor(e,t,r,s){this.code=e,this.size=t,this.digest=r,this.bytes=s}}function gd(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return j6(t,Ul(n),e??ze.encoder);default:return J6(t,Ul(n),e??xt.encoder)}}const md=new WeakMap;function Ul(n){const e=md.get(n);if(e==null){const t=new Map;return md.set(n,t),t}return e}class Y{code;version;multihash;bytes;"/";constructor(e,t,r,s){this.code=t,this.version=e,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==li)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==e5)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Y.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Br(e,t);return Y.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Y.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&X6(e.multihash,r.multihash)}toString(e){return gd(this,e)}toJSON(){return{"/":gd(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Y)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:s,multihash:i,bytes:o}=t;return new Y(r,s,i,o??yd(r,s,i.bytes))}else if(t[t5]===!0){const{version:r,multihash:s,code:i}=t,o=je(s);return Y.create(r,i,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==li)throw new Error(`Version 0 CID must use dag-pb (code: ${li}) block encoding`);return new Y(e,t,r,r.bytes)}case 1:{const s=yd(e,t,r.bytes);return new Y(e,t,r,s)}default:throw new Error("Invalid version")}}static createV0(e){return Y.create(0,li,e)}static createV1(e,t){return Y.create(1,e,t)}static decode(e){const[t,r]=Y.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Y.inspectBytes(e),r=t.size-t.multihashSize,s=Zs(e.subarray(r,r+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new zu(t.multihashCode,t.digestSize,i,s);return[t.version===0?Y.createV0(o):Y.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[h,d]=Fl(e.subarray(t));return t+=d,h};let s=r(),i=li;if(s===18?(s=0,t=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=r(),c=r(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,s]=Z6(e,t),i=Y.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Ul(i).set(r,e),i}}function Z6(n,e){switch(n[0]){case"Q":{const t=e??ze;return[ze.prefix,t.decode(`${ze.prefix}${n}`)]}case ze.prefix:{const t=e??ze;return[ze.prefix,t.decode(n)]}case xt.prefix:{const t=e??xt;return[xt.prefix,t.decode(n)]}case Mn.prefix:{const t=e??Mn;return[Mn.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function j6(n,e,t){const{prefix:r}=t;if(r!==ze.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(r);if(s==null){const i=t.encode(n).slice(1);return e.set(r,i),i}else return s}function J6(n,e,t){const{prefix:r}=t,s=e.get(r);if(s==null){const i=t.encode(n);return e.set(r,i),i}else return s}const li=112,e5=18;function yd(n,e,t){const r=Jo(n),s=r+Jo(e),i=new Uint8Array(s+t.byteLength);return jo(n,i,0),jo(e,i,r),i.set(t,s),i}const t5=Symbol.for("@ipld/js-cid/CID"),T0=0,r5="identity",P0=Zs;function n5(n){return Br(T0,P0(n))}const $n={code:T0,name:r5,encode:P0,digest:n5};function pe(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function _s(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function s5(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Za(n,...e){if(!s5(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function ja(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");_s(n.outputLen),_s(n.blockLen)}function ea(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function i5(n,e){Za(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const cs=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Si(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function ur(n,e){return n<<32-e|n>>>e}function Cc(n,e){return n<<e|n>>>32-e>>>0}const o5=async()=>{};async function a5(n,e,t){let r=Date.now();for(let s=0;s<n;s++){t(s);const i=Date.now()-r;i>=0&&i<e||(await o5(),r+=i)}}function c5(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))}function Vn(n){return typeof n=="string"&&(n=c5(n)),Za(n),n}function l5(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];Za(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}class C0{clone(){return this._cloneInto()}}function u5(n,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(n,e)}function qu(n){const e=r=>n().update(Vn(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function Ja(n=32){if(cs&&typeof cs.getRandomValues=="function")return cs.getRandomValues(new Uint8Array(n));if(cs&&typeof cs.randomBytes=="function")return cs.randomBytes(n);throw new Error("crypto.getRandomValues must be defined")}function h5(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=r?4:0,l=r?0:4;n.setUint32(e+c,o,r),n.setUint32(e+l,a,r)}function D0(n,e,t){return n&e^~n&t}function R0(n,e,t){return n&e^n&t^e&t}class Ku extends C0{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Si(this.buffer)}update(e){ea(this);const{view:t,buffer:r,blockLen:s}=this;e=Vn(e);const i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Si(e);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ea(this),i5(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(r,0),o=0);for(let h=o;h<s;h++)t[h]=0;h5(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=Si(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)a.setUint32(4*h,u[h],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return e.length=s,e.pos=a,e.finished=i,e.destroyed=o,s%t&&e.buffer.set(r),e}}const po=BigInt(2**32-1),$l=BigInt(32);function M0(n,e=!1){return e?{h:Number(n&po),l:Number(n>>$l&po)}:{h:Number(n>>$l&po)|0,l:Number(n&po)|0}}function d5(n,e=!1){let t=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:i,l:o}=M0(n[s],e);[t[s],r[s]]=[i,o]}return[t,r]}const f5=(n,e)=>BigInt(n>>>0)<<$l|BigInt(e>>>0),p5=(n,e,t)=>n>>>t,g5=(n,e,t)=>n<<32-t|e>>>t,m5=(n,e,t)=>n>>>t|e<<32-t,y5=(n,e,t)=>n<<32-t|e>>>t,w5=(n,e,t)=>n<<64-t|e>>>t-32,b5=(n,e,t)=>n>>>t-32|e<<64-t,v5=(n,e)=>e,E5=(n,e)=>n,S5=(n,e,t)=>n<<t|e>>>32-t,_5=(n,e,t)=>e<<t|n>>>32-t,x5=(n,e,t)=>e<<t-32|n>>>64-t,k5=(n,e,t)=>n<<t-32|e>>>64-t;function I5(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const A5=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),T5=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,P5=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),C5=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,D5=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),R5=(n,e,t,r,s,i)=>e+t+r+s+i+(n/2**32|0)|0,se={fromBig:M0,split:d5,toBig:f5,shrSH:p5,shrSL:g5,rotrSH:m5,rotrSL:y5,rotrBH:w5,rotrBL:b5,rotr32H:v5,rotr32L:E5,rotlSH:S5,rotlSL:_5,rotlBH:x5,rotlBL:k5,add:I5,add3L:A5,add3H:T5,add4L:P5,add4H:C5,add5H:R5,add5L:D5},[M5,L5]=se.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),Ur=new Uint32Array(80),$r=new Uint32Array(80);class N5 extends Ku{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:h,Fl:d,Gh:f,Gl:p,Hh:m,Hl:g}=this;return[e,t,r,s,i,o,a,c,l,u,h,d,f,p,m,g]}set(e,t,r,s,i,o,a,c,l,u,h,d,f,p,m,g){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=h|0,this.Fl=d|0,this.Gh=f|0,this.Gl=p|0,this.Hh=m|0,this.Hl=g|0}process(e,t){for(let w=0;w<16;w++,t+=4)Ur[w]=e.getUint32(t),$r[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const k=Ur[w-15]|0,_=$r[w-15]|0,A=se.rotrSH(k,_,1)^se.rotrSH(k,_,8)^se.shrSH(k,_,7),I=se.rotrSL(k,_,1)^se.rotrSL(k,_,8)^se.shrSL(k,_,7),D=Ur[w-2]|0,v=$r[w-2]|0,M=se.rotrSH(D,v,19)^se.rotrBH(D,v,61)^se.shrSH(D,v,6),L=se.rotrSL(D,v,19)^se.rotrBL(D,v,61)^se.shrSL(D,v,6),N=se.add4L(I,L,$r[w-7],$r[w-16]),O=se.add4H(N,A,M,Ur[w-7],Ur[w-16]);Ur[w]=O|0,$r[w]=N|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:h,El:d,Fh:f,Fl:p,Gh:m,Gl:g,Hh:y,Hl:b}=this;for(let w=0;w<80;w++){const k=se.rotrSH(h,d,14)^se.rotrSH(h,d,18)^se.rotrBH(h,d,41),_=se.rotrSL(h,d,14)^se.rotrSL(h,d,18)^se.rotrBL(h,d,41),A=h&f^~h&m,I=d&p^~d&g,D=se.add5L(b,_,I,L5[w],$r[w]),v=se.add5H(D,y,k,A,M5[w],Ur[w]),M=D|0,L=se.rotrSH(r,s,28)^se.rotrBH(r,s,34)^se.rotrBH(r,s,39),N=se.rotrSL(r,s,28)^se.rotrBL(r,s,34)^se.rotrBL(r,s,39),O=r&i^r&a^i&a,P=s&o^s&c^o&c;y=m|0,b=g|0,m=f|0,g=p|0,f=h|0,p=d|0,{h,l:d}=se.add(l|0,u|0,v|0,M|0),l=a|0,u=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const R=se.add3L(M,N,P);r=se.add3H(R,v,L,O),s=R|0}({h:r,l:s}=se.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=se.add(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=se.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=se.add(this.Dh|0,this.Dl|0,l|0,u|0),{h,l:d}=se.add(this.Eh|0,this.El|0,h|0,d|0),{h:f,l:p}=se.add(this.Fh|0,this.Fl|0,f|0,p|0),{h:m,l:g}=se.add(this.Gh|0,this.Gl|0,m|0,g|0),{h:y,l:b}=se.add(this.Hh|0,this.Hl|0,y|0,b|0),this.set(r,s,i,o,a,c,l,u,h,d,f,p,m,g,y,b)}roundClean(){Ur.fill(0),$r.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ec=qu(()=>new N5);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const tc=BigInt(0),rc=BigInt(1),B5=BigInt(2);function Hn(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function eo(n){if(!Hn(n))throw new Error("Uint8Array expected")}function Mr(n,e){if(typeof e!="boolean")throw new Error(n+" boolean expected, got "+e)}const O5=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function zn(n){eo(n);let e="";for(let t=0;t<n.length;t++)e+=O5[n[t]];return e}function ys(n){const e=n.toString(16);return e.length&1?"0"+e:e}function Wu(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?tc:BigInt("0x"+n)}const Ir={_0:48,_9:57,A:65,F:70,a:97,f:102};function wd(n){if(n>=Ir._0&&n<=Ir._9)return n-Ir._0;if(n>=Ir.A&&n<=Ir.F)return n-(Ir.A-10);if(n>=Ir.a&&n<=Ir.f)return n-(Ir.a-10)}function Ps(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=wd(n.charCodeAt(i)),a=wd(n.charCodeAt(i+1));if(o===void 0||a===void 0){const c=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function Ln(n){return Wu(zn(n))}function tn(n){return eo(n),Wu(zn(Uint8Array.from(n).reverse()))}function Cs(n,e){return Ps(n.toString(16).padStart(e*2,"0"))}function Ds(n,e){return Cs(n,e).reverse()}function F5(n){return Ps(ys(n))}function Be(n,e,t){let r;if(typeof e=="string")try{r=Ps(e)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Hn(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(n+" of length "+t+" expected, got "+s);return r}function qn(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];eo(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}function U5(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function $5(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}const Dc=n=>typeof n=="bigint"&&tc<=n;function nc(n,e,t){return Dc(n)&&Dc(e)&&Dc(t)&&e<=n&&n<t}function kt(n,e,t,r){if(!nc(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function L0(n){let e;for(e=0;n>tc;n>>=rc,e+=1);return e}function V5(n,e){return n>>BigInt(e)&rc}function H5(n,e,t){return n|(t?rc:tc)<<BigInt(e)}const Gu=n=>(B5<<BigInt(n-1))-rc,Rc=n=>new Uint8Array(n),bd=n=>Uint8Array.from(n);function N0(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Rc(n),s=Rc(n),i=0;const o=()=>{r.fill(1),s.fill(0),i=0},a=(...h)=>t(s,r,...h),c=(h=Rc())=>{s=a(bd([0]),h),r=a(),h.length!==0&&(s=a(bd([1]),h),r=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const d=[];for(;h<e;){r=a();const f=r.slice();d.push(f),h+=r.length}return qn(...d)};return(h,d)=>{o(),c(h);let f;for(;!(f=d(l()));)c();return o(),f}}const z5={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||Hn(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function Jn(n,e,t={}){const r=(s,i,o)=>{const a=z5[i];if(typeof a!="function")throw new Error("invalid validator function");const c=n[s];if(!(o&&c===void 0)&&!a(c,n))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))r(s,i,!1);for(const[s,i]of Object.entries(t))r(s,i,!0);return n}const q5=()=>{throw new Error("not implemented")};function Mi(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const i=n(t,...r);return e.set(t,i),i}}const K5=Object.freeze(Object.defineProperty({__proto__:null,aInRange:kt,abool:Mr,abytes:eo,bitGet:V5,bitLen:L0,bitMask:Gu,bitSet:H5,bytesToHex:zn,bytesToNumberBE:Ln,bytesToNumberLE:tn,concatBytes:qn,createHmacDrbg:N0,ensureBytes:Be,equalBytes:U5,hexToBytes:Ps,hexToNumber:Wu,inRange:nc,isBytes:Hn,memoized:Mi,notImplemented:q5,numberToBytesBE:Cs,numberToBytesLE:Ds,numberToHexUnpadded:ys,numberToVarBytesBE:F5,utf8ToBytes:$5,validateObject:Jn},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),Le=BigInt(1),In=BigInt(2),W5=BigInt(3),Vl=BigInt(4),vd=BigInt(5),Ed=BigInt(8);function xe(n,e){const t=n%e;return t>=Xe?t:e+t}function B0(n,e,t){if(e<Xe)throw new Error("invalid exponent, negatives unsupported");if(t<=Xe)throw new Error("invalid modulus");if(t===Le)return Xe;let r=Le;for(;e>Xe;)e&Le&&(r=r*n%t),n=n*n%t,e>>=Le;return r}function Me(n,e,t){let r=n;for(;e-- >Xe;)r*=r,r%=t;return r}function Hl(n,e){if(n===Xe)throw new Error("invert: expected non-zero number");if(e<=Xe)throw new Error("invert: expected positive modulus, got "+e);let t=xe(n,e),r=e,s=Xe,i=Le;for(;t!==Xe;){const a=r/t,c=r%t,l=s-i*a;r=t,t=c,s=i,i=l}if(r!==Le)throw new Error("invert: does not exist");return xe(s,e)}function G5(n){const e=(n-Le)/In;let t,r,s;for(t=n-Le,r=0;t%In===Xe;t/=In,r++);for(s=In;s<n&&B0(s,e,n)!==n-Le;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const o=(n+Le)/Vl;return function(c,l){const u=c.pow(l,o);if(!c.eql(c.sqr(u),l))throw new Error("Cannot find square root");return u}}const i=(t+Le)/In;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=r,u=a.pow(a.mul(a.ONE,s),t),h=a.pow(c,i),d=a.pow(c,t);for(;!a.eql(d,a.ONE);){if(a.eql(d,a.ZERO))return a.ZERO;let f=1;for(let m=a.sqr(d);f<l&&!a.eql(m,a.ONE);f++)m=a.sqr(m);const p=a.pow(u,Le<<BigInt(l-f-1));u=a.sqr(p),h=a.mul(h,p),d=a.mul(d,u),l=f}return h}}function Q5(n){if(n%Vl===W5){const e=(n+Le)/Vl;return function(r,s){const i=r.pow(s,e);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(n%Ed===vd){const e=(n-vd)/Ed;return function(r,s){const i=r.mul(s,In),o=r.pow(i,e),a=r.mul(s,o),c=r.mul(r.mul(a,In),o),l=r.mul(a,r.sub(c,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return G5(n)}const Y5=(n,e)=>(xe(n,e)&Le)===Le,X5=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Z5(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=X5.reduce((r,s)=>(r[s]="function",r),e);return Jn(n,t)}function j5(n,e,t){if(t<Xe)throw new Error("invalid exponent, negatives unsupported");if(t===Xe)return n.ONE;if(t===Le)return e;let r=n.ONE,s=e;for(;t>Xe;)t&Le&&(r=n.mul(r,s)),s=n.sqr(s),t>>=Le;return r}function J5(n,e){const t=new Array(e.length),r=e.reduce((i,o,a)=>n.is0(o)?i:(t[a]=i,n.mul(i,o)),n.ONE),s=n.inv(r);return e.reduceRight((i,o,a)=>n.is0(o)?i:(t[a]=n.mul(i,t[a]),n.mul(i,o)),s),t}function O0(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function sc(n,e,t=!1,r={}){if(n<=Xe)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:s,nByteLength:i}=O0(n,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:n,isLE:t,BITS:s,BYTES:i,MASK:Gu(s),ZERO:Xe,ONE:Le,create:c=>xe(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Xe<=c&&c<n},is0:c=>c===Xe,isOdd:c=>(c&Le)===Le,neg:c=>xe(-c,n),eql:(c,l)=>c===l,sqr:c=>xe(c*c,n),add:(c,l)=>xe(c+l,n),sub:(c,l)=>xe(c-l,n),mul:(c,l)=>xe(c*l,n),pow:(c,l)=>j5(a,c,l),div:(c,l)=>xe(c*Hl(l,n),n),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Hl(c,n),sqrt:r.sqrt||(c=>(o||(o=Q5(n)),o(a,c))),invertBatch:c=>J5(a,c),cmov:(c,l,u)=>u?l:c,toBytes:c=>t?Ds(c,i):Cs(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?tn(c):Ln(c)}});return Object.freeze(a)}function F0(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function U0(n){const e=F0(n);return e+Math.ceil(e/2)}function e8(n,e,t=!1){const r=n.length,s=F0(e),i=U0(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=t?tn(n):Ln(n),a=xe(o,e-Le)+Le;return t?Ds(a,s):Cs(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Sd=BigInt(0),go=BigInt(1);function Mc(n,e){const t=e.negate();return n?t:e}function $0(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function Lc(n,e){$0(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1);return{windows:t,windowSize:r}}function t8(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function r8(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const Nc=new WeakMap,V0=new WeakMap;function Bc(n){return V0.get(n)||1}function H0(n,e){return{constTimeNegate:Mc,hasPrecomputes(t){return Bc(t)!==1},unsafeLadder(t,r,s=n.ZERO){let i=t;for(;r>Sd;)r&go&&(s=s.add(i)),i=i.double(),r>>=go;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=Lc(r,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,r,s){const{windows:i,windowSize:o}=Lc(t,e);let a=n.ZERO,c=n.BASE;const l=BigInt(2**t-1),u=2**t,h=BigInt(t);for(let d=0;d<i;d++){const f=d*o;let p=Number(s&l);s>>=h,p>o&&(p-=u,s+=go);const m=f,g=f+Math.abs(p)-1,y=d%2!==0,b=p<0;p===0?c=c.add(Mc(y,r[m])):a=a.add(Mc(b,r[g]))}return{p:a,f:c}},wNAFUnsafe(t,r,s,i=n.ZERO){const{windows:o,windowSize:a}=Lc(t,e),c=BigInt(2**t-1),l=2**t,u=BigInt(t);for(let h=0;h<o;h++){const d=h*a;if(s===Sd)break;let f=Number(s&c);if(s>>=u,f>a&&(f-=l,s+=go),f===0)continue;let p=r[d+Math.abs(f)-1];f<0&&(p=p.negate()),i=i.add(p)}return i},getPrecomputes(t,r,s){let i=Nc.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&Nc.set(r,s(i))),i},wNAFCached(t,r,s){const i=Bc(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const o=Bc(t);return o===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),r,i)},setWindowSize(t,r){$0(r,e),V0.set(t,r),Nc.delete(t)}}}function z0(n,e,t,r){if(t8(t,n),r8(r,e),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,i=L0(BigInt(t.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(s),l=Math.floor((e.BITS-1)/o)*o;let u=s;for(let h=l;h>=0;h-=o){c.fill(s);for(let f=0;f<r.length;f++){const p=r[f],m=Number(p>>BigInt(h)&BigInt(a));c[m]=c[m].add(t[f])}let d=s;for(let f=c.length-1,p=s;f>0;f--)p=p.add(c[f]),d=d.add(p);if(u=u.add(d),h!==0)for(let f=0;f<o;f++)u=u.double()}return u}function Qu(n){return Z5(n.Fp),Jn(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...O0(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt=BigInt(0),yt=BigInt(1),mo=BigInt(2),n8=BigInt(8),s8={zip215:!0};function i8(n){const e=Qu(n);return Jn(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function o8(n){const e=i8(n),{Fp:t,n:r,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=mo<<BigInt(a*8)-yt,u=t.create,h=sc(e.n,e.nBitLength),d=e.uvRatio||((x,E)=>{try{return{isValid:!0,value:t.sqrt(x*t.inv(E))}}catch{return{isValid:!1,value:Qt}}}),f=e.adjustScalarBytes||(x=>x),p=e.domain||((x,E,C)=>{if(Mr("phflag",C),E.length||C)throw new Error("Contexts/pre-hash are not supported");return x});function m(x,E){kt("coordinate "+x,E,Qt,l)}function g(x){if(!(x instanceof w))throw new Error("ExtendedPoint expected")}const y=Mi((x,E)=>{const{ex:C,ey:T,ez:U}=x,H=x.is0();E==null&&(E=H?n8:t.inv(U));const W=u(C*E),j=u(T*E),Z=u(U*E);if(H)return{x:Qt,y:yt};if(Z!==yt)throw new Error("invZ was invalid");return{x:W,y:j}}),b=Mi(x=>{const{a:E,d:C}=e;if(x.is0())throw new Error("bad point: ZERO");const{ex:T,ey:U,ez:H,et:W}=x,j=u(T*T),Z=u(U*U),ie=u(H*H),ue=u(ie*ie),Ie=u(j*E),Ae=u(ie*u(Ie+Z)),De=u(ue+u(C*u(j*Z)));if(Ae!==De)throw new Error("bad point: equation left != right (1)");const st=u(T*U),mt=u(H*W);if(st!==mt)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(E,C,T,U){this.ex=E,this.ey=C,this.ez=T,this.et=U,m("x",E),m("y",C),m("z",T),m("t",U),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(E){if(E instanceof w)throw new Error("extended point not allowed");const{x:C,y:T}=E||{};return m("x",C),m("y",T),new w(C,T,yt,u(C*T))}static normalizeZ(E){const C=t.invertBatch(E.map(T=>T.ez));return E.map((T,U)=>T.toAffine(C[U])).map(w.fromAffine)}static msm(E,C){return z0(w,h,E,C)}_setWindowSize(E){A.setWindowSize(this,E)}assertValidity(){b(this)}equals(E){g(E);const{ex:C,ey:T,ez:U}=this,{ex:H,ey:W,ez:j}=E,Z=u(C*j),ie=u(H*U),ue=u(T*j),Ie=u(W*U);return Z===ie&&ue===Ie}is0(){return this.equals(w.ZERO)}negate(){return new w(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:E}=e,{ex:C,ey:T,ez:U}=this,H=u(C*C),W=u(T*T),j=u(mo*u(U*U)),Z=u(E*H),ie=C+T,ue=u(u(ie*ie)-H-W),Ie=Z+W,Ae=Ie-j,De=Z-W,st=u(ue*Ae),mt=u(Ie*De),lt=u(ue*De),lr=u(Ae*Ie);return new w(st,mt,lr,lt)}add(E){g(E);const{a:C,d:T}=e,{ex:U,ey:H,ez:W,et:j}=this,{ex:Z,ey:ie,ez:ue,et:Ie}=E;if(C===BigInt(-1)){const od=u((H-U)*(ie+Z)),ad=u((H+U)*(ie-Z)),Pc=u(ad-od);if(Pc===Qt)return this.double();const cd=u(W*mo*Ie),ld=u(j*mo*ue),ud=ld+cd,hd=ad+od,dd=ld-cd,j4=u(ud*Pc),J4=u(hd*dd),e6=u(ud*dd),t6=u(Pc*hd);return new w(j4,J4,t6,e6)}const Ae=u(U*Z),De=u(H*ie),st=u(j*T*Ie),mt=u(W*ue),lt=u((U+H)*(Z+ie)-Ae-De),lr=mt-st,kr=mt+st,ci=u(De-C*Ae),Q4=u(lt*lr),Y4=u(kr*ci),X4=u(lt*ci),Z4=u(lr*kr);return new w(Q4,Y4,Z4,X4)}subtract(E){return this.add(E.negate())}wNAF(E){return A.wNAFCached(this,E,w.normalizeZ)}multiply(E){const C=E;kt("scalar",C,yt,r);const{p:T,f:U}=this.wNAF(C);return w.normalizeZ([T,U])[0]}multiplyUnsafe(E,C=w.ZERO){const T=E;return kt("scalar",T,Qt,r),T===Qt?_:this.is0()||T===yt?this:A.wNAFCachedUnsafe(this,T,w.normalizeZ,C)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,r).is0()}toAffine(E){return y(this,E)}clearCofactor(){const{h:E}=e;return E===yt?this:this.multiplyUnsafe(E)}static fromHex(E,C=!1){const{d:T,a:U}=e,H=t.BYTES;E=Be("pointHex",E,H),Mr("zip215",C);const W=E.slice(),j=E[H-1];W[H-1]=j&-129;const Z=tn(W),ie=C?l:t.ORDER;kt("pointHex.y",Z,Qt,ie);const ue=u(Z*Z),Ie=u(ue-yt),Ae=u(T*ue-U);let{isValid:De,value:st}=d(Ie,Ae);if(!De)throw new Error("Point.fromHex: invalid y coordinate");const mt=(st&yt)===yt,lt=(j&128)!==0;if(!C&&st===Qt&&lt)throw new Error("Point.fromHex: x=0 and x_0=1");return lt!==mt&&(st=u(-st)),w.fromAffine({x:st,y:Z})}static fromPrivateKey(E){return v(E).point}toRawBytes(){const{x:E,y:C}=this.toAffine(),T=Ds(C,t.BYTES);return T[T.length-1]|=E&yt?128:0,T}toHex(){return zn(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,yt,u(e.Gx*e.Gy)),w.ZERO=new w(Qt,yt,yt,Qt);const{BASE:k,ZERO:_}=w,A=H0(w,a*8);function I(x){return xe(x,r)}function D(x){return I(tn(x))}function v(x){const E=t.BYTES;x=Be("private key",x,E);const C=Be("hashed private key",i(x),2*E),T=f(C.slice(0,E)),U=C.slice(E,2*E),H=D(T),W=k.multiply(H),j=W.toRawBytes();return{head:T,prefix:U,scalar:H,point:W,pointBytes:j}}function M(x){return v(x).pointBytes}function L(x=new Uint8Array,...E){const C=qn(...E);return D(i(p(C,Be("context",x),!!s)))}function N(x,E,C={}){x=Be("message",x),s&&(x=s(x));const{prefix:T,scalar:U,pointBytes:H}=v(E),W=L(C.context,T,x),j=k.multiply(W).toRawBytes(),Z=L(C.context,j,H,x),ie=I(W+Z*U);kt("signature.s",ie,Qt,r);const ue=qn(j,Ds(ie,t.BYTES));return Be("result",ue,t.BYTES*2)}const O=s8;function P(x,E,C,T=O){const{context:U,zip215:H}=T,W=t.BYTES;x=Be("signature",x,2*W),E=Be("message",E),C=Be("publicKey",C,W),H!==void 0&&Mr("zip215",H),s&&(E=s(E));const j=tn(x.slice(W,2*W));let Z,ie,ue;try{Z=w.fromHex(C,H),ie=w.fromHex(x.slice(0,W),H),ue=k.multiplyUnsafe(j)}catch{return!1}if(!H&&Z.isSmallOrder())return!1;const Ie=L(U,ie.toRawBytes(),Z.toRawBytes(),E);return ie.add(Z.multiplyUnsafe(Ie)).subtract(ue).clearCofactor().equals(w.ZERO)}return k._setWindowSize(8),{CURVE:e,getPublicKey:M,sign:N,verify:P,ExtendedPoint:w,utils:{getExtendedPublicKey:v,randomPrivateKey:()=>o(t.BYTES),precompute(x=8,E=w.BASE){return E._setWindowSize(x),E.multiply(BigInt(3)),E}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ls=BigInt(0),Oc=BigInt(1);function a8(n){return Jn(n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n})}function c8(n){const e=a8(n),{P:t}=e,r=b=>xe(b,t),s=e.montgomeryBits,i=Math.ceil(s/8),o=e.nByteLength,a=e.adjustScalarBytes||(b=>b),c=e.powPminus2||(b=>B0(b,t-BigInt(2),t));function l(b,w,k){const _=r(b*(w-k));return w=r(w-_),k=r(k+_),[w,k]}const u=(e.a-BigInt(2))/BigInt(4);function h(b,w){kt("u",b,ls,t),kt("scalar",w,ls,t);const k=w,_=b;let A=Oc,I=ls,D=b,v=Oc,M=ls,L;for(let O=BigInt(s-1);O>=ls;O--){const P=k>>O&Oc;M^=P,L=l(M,A,D),A=L[0],D=L[1],L=l(M,I,v),I=L[0],v=L[1],M=P;const R=A+I,x=r(R*R),E=A-I,C=r(E*E),T=x-C,U=D+v,H=D-v,W=r(H*R),j=r(U*E),Z=W+j,ie=W-j;D=r(Z*Z),v=r(_*r(ie*ie)),A=r(x*C),I=r(T*(x+r(u*T)))}L=l(M,A,D),A=L[0],D=L[1],L=l(M,I,v),I=L[0],v=L[1];const N=c(I);return r(A*N)}function d(b){return Ds(r(b),i)}function f(b){const w=Be("u coordinate",b,i);return o===32&&(w[31]&=127),tn(w)}function p(b){const w=Be("scalar",b),k=w.length;if(k!==i&&k!==o){let _=""+i+" or "+o;throw new Error("invalid scalar, expected "+_+" bytes, got "+k)}return tn(a(w))}function m(b,w){const k=f(w),_=p(b),A=h(k,_);if(A===ls)throw new Error("invalid private or public key received");return d(A)}const g=d(e.Gu);function y(b){return m(b,g)}return{scalarMult:m,scalarMultBase:y,getSharedSecret:(b,w)=>m(b,w),getPublicKey:b=>y(b),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:g}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Li=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),_d=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const l8=BigInt(1),xd=BigInt(2),u8=BigInt(3),h8=BigInt(5),d8=BigInt(8);function q0(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),i=Li,a=n*n%i*n%i,c=Me(a,xd,i)*a%i,l=Me(c,l8,i)*n%i,u=Me(l,h8,i)*l%i,h=Me(u,e,i)*u%i,d=Me(h,t,i)*h%i,f=Me(d,r,i)*d%i,p=Me(f,s,i)*f%i,m=Me(p,s,i)*f%i,g=Me(m,e,i)*u%i;return{pow_p_5_8:Me(g,xd,i)*n%i,b2:a}}function K0(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function f8(n,e){const t=Li,r=xe(e*e*e,t),s=xe(r*r*e,t),i=q0(n*s).pow_p_5_8;let o=xe(n*r*i,t);const a=xe(e*o*o,t),c=o,l=xe(o*_d,t),u=a===n,h=a===xe(-n,t),d=a===xe(-n*_d,t);return u&&(o=c),(h||d)&&(o=l),Y5(o,t)&&(o=xe(-o,t)),{isValid:u||h,value:o}}const p8=sc(Li,void 0,!0),g8={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:p8,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:d8,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:ec,randomBytes:Ja,adjustScalarBytes:K0,uvRatio:f8},ta=o8(g8),yo=c8({P:Li,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:n=>{const e=Li,{pow_p_5_8:t,b2:r}=q0(n);return xe(Me(t,u8,e)*r,e)},adjustScalarBytes:K0,randomBytes:Ja}),ra=32,Wr=64,zl=32;function m8(){const n=ta.utils.randomPrivateKey(),e=ta.getPublicKey(n);return{privateKey:b8(n,e),publicKey:e}}function y8(n,e){const t=n.subarray(0,zl);return ta.sign(e instanceof Uint8Array?e:e.subarray(),t)}function w8(n,e,t){return ta.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}function b8(n,e){const t=new Uint8Array(Wr);for(let r=0;r<zl;r++)t[r]=n[r],t[zl+r]=e[r];return t}class W0{type="Ed25519";raw;constructor(e){this.raw=Ni(e,ra)}toMultihash(){return $n.digest(rr(this))}toCID(){return Y.createV1(114,this.toMultihash())}toString(){return ze.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}verify(e,t){return w8(this.raw,t,e)}}class ql{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Ni(e,Wr),this.publicKey=new W0(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}sign(e){return y8(this.raw,e)}}function G0(n){if(n.length>Wr){n=Ni(n,Wr+ra);const r=n.subarray(0,Wr),s=n.subarray(Wr,n.length);return new ql(r,s)}n=Ni(n,Wr);const e=n.subarray(0,Wr),t=n.subarray(ra);return new ql(e,t)}function Q0(n){return n=Ni(n,ra),new W0(n)}async function v8(){const{privateKey:n,publicKey:e}=m8();return new ql(n,e)}function Ni(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new B(`Key must be a Uint8Array of length ${e}, got ${n.length}`);return n}function oe(n=0){return new Uint8Array(n)}function ct(n=0){return new Uint8Array(n)}const E8=Math.pow(2,7),S8=Math.pow(2,14),_8=Math.pow(2,21),Yu=Math.pow(2,28),Xu=Math.pow(2,35),Zu=Math.pow(2,42),ju=Math.pow(2,49),me=128,it=127;function ye(n){if(n<E8)return 1;if(n<S8)return 2;if(n<_8)return 3;if(n<Yu)return 4;if(n<Xu)return 5;if(n<Zu)return 6;if(n<ju)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Y0(n,e,t=0){switch(ye(n)){case 8:e[t++]=n&255|me,n/=128;case 7:e[t++]=n&255|me,n/=128;case 6:e[t++]=n&255|me,n/=128;case 5:e[t++]=n&255|me,n/=128;case 4:e[t++]=n&255|me,n>>>=7;case 3:e[t++]=n&255|me,n>>>=7;case 2:e[t++]=n&255|me,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function x8(n,e,t=0){switch(ye(n)){case 8:e.set(t++,n&255|me),n/=128;case 7:e.set(t++,n&255|me),n/=128;case 6:e.set(t++,n&255|me),n/=128;case 5:e.set(t++,n&255|me),n/=128;case 4:e.set(t++,n&255|me),n>>>=7;case 3:e.set(t++,n&255|me),n>>>=7;case 2:e.set(t++,n&255|me),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function X0(n,e){let t=n[e],r=0;if(r+=t&it,t<me||(t=n[e+1],r+=(t&it)<<7,t<me)||(t=n[e+2],r+=(t&it)<<14,t<me)||(t=n[e+3],r+=(t&it)<<21,t<me)||(t=n[e+4],r+=(t&it)*Yu,t<me)||(t=n[e+5],r+=(t&it)*Xu,t<me)||(t=n[e+6],r+=(t&it)*Zu,t<me)||(t=n[e+7],r+=(t&it)*ju,t<me))return r;throw new RangeError("Could not decode varint")}function k8(n,e){let t=n.get(e),r=0;if(r+=t&it,t<me||(t=n.get(e+1),r+=(t&it)<<7,t<me)||(t=n.get(e+2),r+=(t&it)<<14,t<me)||(t=n.get(e+3),r+=(t&it)<<21,t<me)||(t=n.get(e+4),r+=(t&it)*Yu,t<me)||(t=n.get(e+5),r+=(t&it)*Xu,t<me)||(t=n.get(e+6),r+=(t&it)*Zu,t<me)||(t=n.get(e+7),r+=(t&it)*ju,t<me))return r;throw new RangeError("Could not decode varint")}function Ze(n,e,t=0){return e==null&&(e=ct(ye(n))),e instanceof Uint8Array?Y0(n,e,t):x8(n,e,t)}function ar(n,e=0){return n instanceof Uint8Array?X0(n,e):k8(n,e)}const Ju=new Float32Array([-0]),Xr=new Uint8Array(Ju.buffer);function I8(n,e,t){Ju[0]=n,e[t]=Xr[0],e[t+1]=Xr[1],e[t+2]=Xr[2],e[t+3]=Xr[3]}function A8(n,e){return Xr[0]=n[e],Xr[1]=n[e+1],Xr[2]=n[e+2],Xr[3]=n[e+3],Ju[0]}const eh=new Float64Array([-0]),ot=new Uint8Array(eh.buffer);function T8(n,e,t){eh[0]=n,e[t]=ot[0],e[t+1]=ot[1],e[t+2]=ot[2],e[t+3]=ot[3],e[t+4]=ot[4],e[t+5]=ot[5],e[t+6]=ot[6],e[t+7]=ot[7]}function P8(n,e){return ot[0]=n[e],ot[1]=n[e+1],ot[2]=n[e+2],ot[3]=n[e+3],ot[4]=n[e+4],ot[5]=n[e+5],ot[6]=n[e+6],ot[7]=n[e+7],eh[0]}const C8=BigInt(Number.MAX_SAFE_INTEGER),D8=BigInt(Number.MIN_SAFE_INTEGER);class at{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return Nn;if(e<C8&&e>D8)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,s=e-(r<<32n);return t&&(r=~r|0n,s=~s|0n,++s>kd&&(s=0n,++r>kd&&(r=0n))),new at(Number(s),Number(r))}static fromNumber(e){if(e===0)return Nn;const t=e<0;t&&(e=-e);let r=e>>>0,s=(e-r)/4294967296>>>0;return t&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new at(r,s)}static from(e){return typeof e=="number"?at.fromNumber(e):typeof e=="bigint"?at.fromBigInt(e):typeof e=="string"?at.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new at(e.low>>>0,e.high>>>0):Nn}}const Nn=new at(0,0);Nn.toBigInt=function(){return 0n};Nn.zzEncode=Nn.zzDecode=function(){return this};Nn.length=function(){return 1};const kd=4294967296n;function R8(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function M8(n,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=n[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Z0(n,e,t){const r=t;let s,i;for(let o=0;o<n.length;++o)s=n.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=n.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-r}function Yt(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function wo(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}class L8{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Yt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Yt(this,4);return wo(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Yt(this,4);return wo(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Yt(this,4);const e=A8(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Yt(this,4);const e=P8(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw Yt(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return M8(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Yt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Yt(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new at(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Yt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Yt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Yt(this,8);const e=wo(this.buf,this.pos+=4),t=wo(this.buf,this.pos+=4);return new at(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=X0(this.buf,this.pos);return this.pos+=ye(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function N8(n){return new L8(n instanceof Uint8Array?n:n.subarray())}function J(n,e,t){const r=N8(n);return e.decode(r,void 0,t)}const B8=Ji({prefix:"9",name:"base10",alphabet:"0123456789"}),O8=Object.freeze(Object.defineProperty({__proto__:null,base10:B8},Symbol.toStringTag,{value:"Module"})),F8=nt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),U8=nt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),$8=Object.freeze(Object.defineProperty({__proto__:null,base16:F8,base16upper:U8},Symbol.toStringTag,{value:"Module"})),V8=nt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),H8=Object.freeze(Object.defineProperty({__proto__:null,base2:V8},Symbol.toStringTag,{value:"Module"})),j0=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),z8=j0.reduce((n,e,t)=>(n[t]=e,n),[]),q8=j0.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function K8(n){return n.reduce((e,t)=>(e+=z8[t],e),"")}function W8(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const s=q8[r];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const G8=Xa({prefix:"🚀",name:"base256emoji",encode:K8,decode:W8}),Q8=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:G8},Symbol.toStringTag,{value:"Module"})),qt=nt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Y8=nt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),th=nt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),X8=nt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Z8=Object.freeze(Object.defineProperty({__proto__:null,base64:qt,base64pad:Y8,base64url:th,base64urlpad:X8},Symbol.toStringTag,{value:"Module"})),j8=nt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),J8=Object.freeze(Object.defineProperty({__proto__:null,base8:j8},Symbol.toStringTag,{value:"Module"})),e7=Xa({prefix:"\0",name:"identity",encode:n=>h6(n),decode:n=>u6(n)}),t7=Object.freeze(Object.defineProperty({__proto__:null,identity:e7},Symbol.toStringTag,{value:"Module"})),r7=new TextEncoder,n7=new TextDecoder,s7="json",J0=512;function i7(n){return r7.encode(JSON.stringify(n))}function o7(n){return JSON.parse(n7.decode(n))}const a7=Object.freeze(Object.defineProperty({__proto__:null,code:J0,decode:o7,encode:i7,name:s7},Symbol.toStringTag,{value:"Module"})),c7="raw",ic=85;function l7(n){return Zs(n)}function u7(n){return Zs(n)}const h7=Object.freeze(Object.defineProperty({__proto__:null,code:ic,decode:u7,encode:l7,name:c7},Symbol.toStringTag,{value:"Module"}));function e2({name:n,code:e,encode:t}){return new d7(n,e,t)}class d7{name;code;encode;constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Br(this.code,t):t.then(r=>Br(this.code,r))}else throw Error("Unknown type, must be binary type")}}function t2(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const Nt=e2({name:"sha2-256",code:18,encode:t2("SHA-256")}),Id=e2({name:"sha2-512",code:19,encode:t2("SHA-512")}),na={...t7,...H8,...J8,...O8,...$8,...D6,...M6,...S6,...Z8,...Q8};function r2(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const Ad=r2("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),Fc=r2("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=ct(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),n2={utf8:Ad,"utf-8":Ad,hex:na.base16,latin1:Fc,ascii:Fc,binary:Fc,...na};function V(n,e="utf8"){const t=n2[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function f7(n){let r,s=8192;return function(o){if(o<1||o>4096)return ct(o);s+o>8192&&(r=ct(8192),s=0);const a=r.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class mi{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function Uc(){}class p7{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const g7=f7();function m7(n){return globalThis.Buffer!=null?ct(n):g7(n)}class Kl{len;head;tail;states;constructor(){this.len=0,this.head=new mi(Uc,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new mi(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new w7((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(bo,10,at.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=at.fromBigInt(e);return this._push(bo,t.length(),t)}uint64Number(e){return this._push(Y0,ye(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=at.fromBigInt(e).zzEncode();return this._push(bo,t.length(),t)}sint64Number(e){const t=at.fromNumber(e).zzEncode();return this._push(bo,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push($c,1,e?1:0)}fixed32(e){return this._push(ui,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=at.fromBigInt(e);return this._push(ui,4,t.lo)._push(ui,4,t.hi)}fixed64Number(e){const t=at.fromNumber(e);return this._push(ui,4,t.lo)._push(ui,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(I8,4,e)}double(e){return this._push(T8,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push($c,1,0):this.uint32(t)._push(b7,t,e)}string(e){const t=R8(e);return t!==0?this.uint32(t)._push(Z0,t,e):this._push($c,1,0)}fork(){return this.states=new p7(this),this.head=this.tail=new mi(Uc,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new mi(Uc,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=m7(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}}function $c(n,e,t){e[t]=n&255}function y7(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}class w7 extends mi{next;constructor(e,t){super(y7,e,t),this.next=void 0}}function bo(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function ui(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function b7(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(Kl.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(v7,e,n),this},Kl.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(E7,e,n),this});function v7(n,e,t){e.set(n,t)}function E7(n,e,t){n.length<40?Z0(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set(V(n),t)}function S7(){return new Kl}function ee(n,e){const t=S7();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var sa;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(sa||(sa={}));function s2(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function At(n){function e(s){if(n[s.toString()]==null)throw new Error("Invalid enum value");return n[s]}const t=function(i,o){const a=e(i);o.int32(a)},r=function(i){const o=i.int32();return e(o)};return s2("enum",sa.VARINT,t,r)}function te(n,e){return s2("message",sa.LENGTH_DELIMITED,n,e)}class _e extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Td extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var $e;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1"})($e||($e={}));var Wl;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1"})(Wl||(Wl={}));(function(n){n.codec=()=>At(Wl)})($e||($e={}));var ln;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),$e.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=$e.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(ln||(ln={}));var ia;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),$e.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=$e.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(ia||(ia={}));const _7=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Vr=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Hr=new Uint32Array(64);class x7 extends Ku{constructor(){super(64,32,8,!1),this.A=Vr[0]|0,this.B=Vr[1]|0,this.C=Vr[2]|0,this.D=Vr[3]|0,this.E=Vr[4]|0,this.F=Vr[5]|0,this.G=Vr[6]|0,this.H=Vr[7]|0}get(){const{A:e,B:t,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,r,s,i,o,a,c]}set(e,t,r,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let h=0;h<16;h++,t+=4)Hr[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const d=Hr[h-15],f=Hr[h-2],p=ur(d,7)^ur(d,18)^d>>>3,m=ur(f,17)^ur(f,19)^f>>>10;Hr[h]=m+Hr[h-7]+p+Hr[h-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let h=0;h<64;h++){const d=ur(a,6)^ur(a,11)^ur(a,25),f=u+d+D0(a,c,l)+_7[h]+Hr[h]|0,m=(ur(r,2)^ur(r,13)^ur(r,22))+R0(r,s,i)|0;u=l,l=c,c=a,a=o+f|0,o=i,i=s,s=r,r=f+m|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,s,i,o,a,c,l,u)}roundClean(){Hr.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const rn=qu(()=>new x7);/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const k7="[object ArrayBuffer]";class Ee{static isArrayBuffer(e){return Object.prototype.toString.call(e)===k7}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=Ee.toUint8Array(e),s=Ee.toUint8Array(t);if(r.length!==s.byteLength)return!1;for(let i=0;i<r.length;i++)if(r[i]!==s[i])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let r=0;for(const o of t)r+=o.byteLength;const s=new Uint8Array(r);let i=0;for(const o of t){const a=this.toUint8Array(o);s.set(a,i),i+=a.length}return e[e.length-1]instanceof Function?this.toView(s,e[e.length-1]):s.buffer}}const Vc="string",I7=/^[0-9a-f\s]+$/i,A7=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,T7=/^[a-zA-Z0-9-_]+$/;class Pd{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return r.buffer}static toString(e){const t=Ee.toUint8Array(e);let r="";for(let i=0;i<t.length;i++)r+=String.fromCharCode(t[i]);return decodeURIComponent(escape(r))}}class hr{static toString(e,t=!1){const r=Ee.toArrayBuffer(e),s=new DataView(r);let i="";for(let o=0;o<r.byteLength;o+=2){const a=s.getUint16(o,t);i+=String.fromCharCode(a)}return i}static fromString(e,t=!1){const r=new ArrayBuffer(e.length*2),s=new DataView(r);for(let i=0;i<e.length;i++)s.setUint16(i*2,e.charCodeAt(i),t);return r}}class Oe{static isHex(e){return typeof e===Vc&&I7.test(e)}static isBase64(e){return typeof e===Vc&&A7.test(e)}static isBase64Url(e){return typeof e===Vc&&T7.test(e)}static ToString(e,t="utf8"){const r=Ee.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return hr.toString(r,!0);case"utf16":case"utf16be":return hr.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return hr.fromString(e,!0);case"utf16":case"utf16be":return hr.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=Ee.toUint8Array(e);if(typeof btoa<"u"){const r=this.ToString(t,"binary");return btoa(r)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Oe.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Oe.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=Oe.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Pd.fromString(e);case"utf16":case"utf16be":return hr.fromString(e);case"utf16le":case"usc2":return hr.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=Oe.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Pd.toString(e);case"utf16":case"utf16be":return hr.toString(e);case"utf16le":case"usc2":return hr.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const t=Ee.toUint8Array(e);let r="";for(let s=0;s<t.length;s++)r+=String.fromCharCode(t[s]);return r}static ToHex(e){const t=Ee.toUint8Array(e);let r="";const s=t.length;for(let i=0;i<s;i++){const o=t[i];o<16&&(r+="0"),r+=o.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Oe.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let s=0;s<t.length;s=s+2){const i=t.slice(s,s+2);r[s/2]=parseInt(i,16)}return r.buffer}static ToUtf16String(e,t=!1){return hr.toString(e,t)}static FromUtf16String(e,t=!1){return hr.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}}Oe.DEFAULT_UTF8_ENCODING="utf8";/*!
 Copyright (c) Peculiar Ventures, LLC
*/function Rs(n,e){let t=0;if(n.length===1)return n[0];for(let r=n.length-1;r>=0;r--)t+=n[n.length-1-r]*Math.pow(2,e*r);return t}function Kn(n,e,t=-1){const r=t;let s=n,i=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(n<o){let c;if(r<0)c=new ArrayBuffer(a),i=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),i=r}const l=new Uint8Array(c);for(let u=a-1;u>=0;u--){const h=Math.pow(2,u*e);l[i-u-1]=Math.floor(s/h),s-=l[i-u-1]*h}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Gl(...n){let e=0,t=0;for(const i of n)e+=i.length;const r=new ArrayBuffer(e),s=new Uint8Array(r);for(const i of n)s.set(i,t),t+=i.length;return s}function i2(){const n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=n[0]===255&&n[1]&128,c=n[0]===0&&(n[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=n[0]&128;const r=Rs(t,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)i[a]=n[a];return i[0]&=127,Rs(i,8)-r}function P7(n){const e=n<0?n*-1:n;let t=128;for(let r=1;r<8;r++){if(e<=t){if(n<0){const o=t-e,a=Kn(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let s=Kn(e,8,r),i=new Uint8Array(s);if(i[0]&128){const o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)i[c+1]=a[c];i[0]=0}return s}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function C7(n,e){if(n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let s=0;s<t.length;s++)if(t[s]!==r[s])return!1;return!0}function Rt(n,e){const t=n.toString(10);if(e<t.length)return"";const r=e-t.length,s=new Array(r);for(let o=0;o<r;o++)s[o]="0";return s.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function oa(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function rh(n){let e=0,t=0;for(let s=0;s<n.length;s++){const i=n[s];e+=i.byteLength}const r=new Uint8Array(e);for(let s=0;s<n.length;s++){const i=n[s];r.set(new Uint8Array(i),t),t+=i.byteLength}return r.buffer}function Or(n,e,t,r){return e instanceof Uint8Array?e.byteLength?t<0?(n.error="Wrong parameter: inputOffset less than zero",!1):r<0?(n.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-r<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class nh{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return rh(this.items)}}const hi=[new Uint8Array([1])],Cd="0123456789",js="",cr=new ArrayBuffer(0),sh=new Uint8Array(0),Bi="EndOfContent",o2="OCTET STRING",a2="BIT STRING";function Fr(n){var e;return e=class extends n{constructor(...r){var s;super(...r);const i=r[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?Ee.toUint8Array(i.valueHex):sh}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}fromBER(r,s,i){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!Or(this,o,s,i))return-1;const a=s+i;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=i,a):(this.warnings.push("Zero buffer length"),s)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",cr)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:Oe.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class es{constructor({blockLength:e=0,error:t=js,warnings:r=[],valueBeforeDecode:s=sh}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=Ee.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Oe.ToHex(this.valueBeforeDecodeView)}}}es.NAME="baseBlock";class Pt extends es{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}Pt.NAME="valueBlock";class c2 extends Fr(es){constructor({idBlock:e={}}={}){var t,r,s,i;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?Ee.toUint8Array(e.valueHex):sh,this.tagClass=(r=e.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(s=e.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=e.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",cr}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const s=new Uint8Array(1);if(!e){let i=this.tagNumber;i&=31,t|=i,s[0]=t}return s.buffer}if(!this.isHexOnly){const s=Kn(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=i[c]|128;a[o]=i[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=t|31,!e){const s=this.valueHexView;for(let i=0;i<s.length-1;i++)r[i+1]=s[i]|128;r[this.valueHexView.byteLength]=s[s.length-1]}return r.buffer}fromBER(e,t,r){const s=Ee.toUint8Array(e);if(!Or(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;const a=i[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;i[c]&128;){if(l[c-1]=i[c]&127,c++,c>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;const d=new Uint8Array(u);for(let f=0;f<l.length;f++)d[f]=l[f];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=i[c]&127;const h=new Uint8Array(c);for(let d=0;d<c;d++)h[d]=l[d];l=this.valueHexView=new Uint8Array(c),l.set(h),this.blockLength<=9?this.tagNumber=Rs(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}c2.NAME="identificationBlock";class l2 extends es{constructor({lenBlock:e={}}={}){var t,r,s;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(r=e.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(s=e.length)!==null&&s!==void 0?s:0}fromBER(e,t,r){const s=Ee.toUint8Array(e);if(!Or(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,t+this.blockLength;const o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Rs(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const s=Kn(this.length,8);if(s.byteLength>127)return this.error="Too big length",cr;if(t=new ArrayBuffer(s.byteLength+1),e)return t;const i=new Uint8Array(s);r=new Uint8Array(t),r[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)r[o+1]=i[o];return t}return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}l2.NAME="lengthBlock";const q={};class ft extends es{constructor({name:e=js,optional:t=!1,primitiveSchema:r,...s}={},i){super(s),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new c2(s),this.lenBlock=new l2(s),this.valueBlock=i?new i(s):new Pt(s)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){const r=t||new nh;t||u2(this);const s=this.idBlock.toBER(e);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const i=this.valueBlock.toBER(e);this.lenBlock.length=i.byteLength;const o=this.lenBlock.toBER(e);r.write(o),r.write(i)}return t?cr:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():Oe.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${Oe.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),r=e.toBER();return C7(t,r)}}ft.NAME="BaseBlock";function u2(n){if(n instanceof q.Constructed)for(const e of n.valueBlock.value)u2(e)&&(n.lenBlock.isIndefiniteForm=!0);return!!n.lenBlock.isIndefiniteForm}class h2 extends ft{constructor({value:e=js,...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}h2.NAME="BaseStringBlock";class d2 extends Fr(Pt){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}d2.NAME="PrimitiveValueBlock";var f2;class p2 extends ft{constructor(e={}){super(e,d2),this.idBlock.isConstructed=!1}}f2=p2;q.Primitive=f2;p2.NAME="PRIMITIVE";function D7(n,e){if(n instanceof e)return n;const t=new e;return t.idBlock=n.idBlock,t.lenBlock=n.lenBlock,t.warnings=n.warnings,t.valueBeforeDecodeView=n.valueBeforeDecodeView,t}function oc(n,e=0,t=n.length){const r=e;let s=new ft({},Pt);const i=new es;if(!Or(i,n,e,t))return s.error=i.error,{offset:-1,result:s};if(!n.subarray(e,e+t).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(n,e,t);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(e=a,t-=s.idBlock.blockLength,a=s.lenBlock.fromBER(n,e,t),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=a,t-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=ft;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=q.EndOfContent;break;case 1:c=q.Boolean;break;case 2:c=q.Integer;break;case 3:c=q.BitString;break;case 4:c=q.OctetString;break;case 5:c=q.Null;break;case 6:c=q.ObjectIdentifier;break;case 10:c=q.Enumerated;break;case 12:c=q.Utf8String;break;case 13:c=q.RelativeObjectIdentifier;break;case 14:c=q.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=q.Sequence;break;case 17:c=q.Set;break;case 18:c=q.NumericString;break;case 19:c=q.PrintableString;break;case 20:c=q.TeletexString;break;case 21:c=q.VideotexString;break;case 22:c=q.IA5String;break;case 23:c=q.UTCTime;break;case 24:c=q.GeneralizedTime;break;case 25:c=q.GraphicString;break;case 26:c=q.VisibleString;break;case 27:c=q.GeneralString;break;case 28:c=q.UniversalString;break;case 29:c=q.CharacterString;break;case 30:c=q.BmpString;break;case 31:c=q.DATE;break;case 32:c=q.TimeOfDay;break;case 33:c=q.DateTime;break;case 34:c=q.Duration;break;default:{const l=s.idBlock.isConstructed?new q.Constructed:new q.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?q.Constructed:q.Primitive}return s=D7(s,c),a=s.fromBER(n,e,s.lenBlock.isIndefiniteForm?t:s.lenBlock.length),s.valueBeforeDecodeView=n.subarray(r,r+s.blockLength),{offset:a,result:s}}function _i(n){if(!n.byteLength){const e=new ft({},Pt);return e.error="Input buffer has zero length",{offset:-1,result:e}}return oc(Ee.toUint8Array(n).slice(),0,n.byteLength)}function R7(n,e){return n?1:e}class nn extends Pt{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const s=Ee.toUint8Array(e);if(!Or(this,s,t,r))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let i=t;for(;R7(this.isIndefiniteForm,r)>0;){const o=oc(s,i,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===Bi)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Bi?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(e,t){const r=t||new nh;for(let s=0;s<this.value.length;s++)this.value[s].toBER(e,r);return t?cr:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}nn.NAME="ConstructedValueBlock";var g2;class Js extends ft{constructor(e={}){super(e,nn),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const e=[];for(const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map(s=>`  ${s}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}g2=Js;q.Constructed=g2;Js.NAME="CONSTRUCTED";class m2 extends Pt{fromBER(e,t,r){return t}toBER(e){return cr}}m2.override="EndOfContentValueBlock";var y2;class w2 extends ft{constructor(e={}){super(e,m2),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}y2=w2;q.EndOfContent=y2;w2.NAME=Bi;var b2;class Oi extends ft{constructor(e={}){super(e,Pt),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const s=new Uint8Array(r);s[0]=5,s[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}b2=Oi;q.Null=b2;Oi.NAME="NULL";class v2 extends Fr(Pt){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=Ee.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const s=Ee.toUint8Array(e);return Or(this,s,t,r)?(this.valueHexView=s.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,i2.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}v2.NAME="BooleanValueBlock";var E2;let S2=class extends ft{constructor(e={}){super(e,v2),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};E2=S2;q.Boolean=E2;S2.NAME="BOOLEAN";class _2 extends Fr(nn){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=nn.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(let i=0;i<this.value.length;i++){const o=this.value[i].constructor.NAME;if(o===Bi){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==o2)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e,t){return this.isConstructed?nn.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}_2.NAME="OctetStringValueBlock";var x2;class Zr extends ft{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},_2),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const i=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(i.byteLength){const o=oc(i,0,i.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?Js.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${Oe.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof Zr&&e.push(t.valueBlock.valueHexView);return Ee.concat(e)}}x2=Zr;q.OctetString=x2;Zr.NAME=o2;class k2 extends Fr(nn){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let s=-1;if(this.isConstructed){if(s=nn.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(const a of this.value){const c=a.constructor.NAME;if(c===Bi){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==a2)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return s}const i=Ee.toUint8Array(e);if(!Or(this,i,t,r))return-1;const o=i.subarray(t,t+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=oc(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+r}toBER(e,t){if(this.isConstructed)return nn.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return cr;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}k2.NAME="BitStringValueBlock";var I2;class ih extends ft{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},k2),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Js.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const s of t)e.push(s.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}I2=ih;q.BitString=I2;ih.NAME=a2;var A2;function M7(n,e){const t=new Uint8Array([0]),r=new Uint8Array(n),s=new Uint8Array(e);let i=r.slice(0);const o=i.length-1,a=s.slice(0),c=a.length-1;let l=0;const u=c<o?o:c;let h=0;for(let d=u;d>=0;d--,h++){switch(!0){case h<a.length:l=i[o-h]+a[c-h]+t[0];break;default:l=i[o-h]+t[0]}switch(t[0]=l/10,!0){case h>=i.length:i=Gl(new Uint8Array([l%10]),i);break;default:i[o-h]=l%10}}return t[0]>0&&(i=Gl(t,i)),i}function Dd(n){if(n>=hi.length)for(let e=hi.length;e<=n;e++){const t=new Uint8Array([0]);let r=hi[e-1].slice(0);for(let s=r.length-1;s>=0;s--){const i=new Uint8Array([(r[s]<<1)+t[0]]);t[0]=i[0]/10,r[s]=i[0]%10}t[0]>0&&(r=Gl(t,r)),hi.push(r)}return hi[n]}function L7(n,e){let t=0;const r=new Uint8Array(n),s=new Uint8Array(e),i=r.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1;let l,u=0;for(let h=c;h>=0;h--,u++)switch(l=i[o-u]-a[c-u]-t,!0){case l<0:t=1,i[o-u]=l+10;break;default:t=0,i[o-u]=l}if(t>0)for(let h=o-c+1;h>=0;h--,u++)if(l=i[o-u]-t,l<0)t=1,i[o-u]=l+10;else{t=0,i[o-u]=l;break}return i.slice()}class oh extends Fr(Pt){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=i2.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(P7(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const i=this.fromBER(e,t,r);if(i===-1)return i;const o=this.valueHexView;return o[0]===0&&o[1]&128?this.valueHexView=o.subarray(1):s!==0&&o.length<s&&(s-o.length>1&&(s=o.length+1),this.valueHexView=o.subarray(s-o.length)),i}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(t,1),this.valueHexView=r}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return s===-1||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),r=0,s;const i=this.valueHexView;let o="",a=!1;for(let c=i.byteLength-1;c>=0;c--){s=i[c];for(let l=0;l<8;l++){if((s&1)===1)switch(r){case e:t=L7(Dd(r),t),o="-";break;default:t=M7(t,Dd(r))}r++,s>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=Cd.charAt(t[c]));return a===!1&&(o+=Cd.charAt(0)),o}}A2=oh;oh.NAME="IntegerValueBlock";Object.defineProperty(A2.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var T2;class Fe extends ft{constructor(e={}){super(e,oh),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return oa(),BigInt(this.valueBlock.toString())}static fromBigInt(e){oa();const t=BigInt(e),r=new nh,s=t.toString(16).replace(/^-/,""),i=new Uint8Array(Oe.FromHex(s));if(t<0){const a=new Uint8Array(i.length+(i[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${Oe.ToHex(a)}`)+t,u=Ee.toUint8Array(Oe.FromHex(l.toString(16)));u[0]|=128,r.write(u)}else i[0]&128&&r.write(new Uint8Array([0])),r.write(i);return new Fe({valueHex:r.final()})}convertToDER(){const e=new Fe({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new Fe({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}T2=Fe;q.Integer=T2;Fe.NAME="INTEGER";var P2;class C2 extends Fe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}P2=C2;q.Enumerated=P2;C2.NAME="ENUMERATED";class Ql extends Fr(Pt){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const s=Ee.toUint8Array(e);if(!Or(this,s,t,r))return-1;const i=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Rs(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){oa();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let s=0;s<r.length;s++)r[s]=parseInt(t.slice(s*7,s*7+7),2)+(s+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const t=Kn(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",cr;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r}toString(){let e="";if(this.isHexOnly)e=Oe.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Ql.NAME="sidBlock";class D2 extends Pt{constructor({value:e=js,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const i=new Ql;if(s=i.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.value.length===0&&(i.isFirstSid=!0),this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(s.byteLength===0)return this.error=this.value[r].error,cr;t.push(s)}return rh(t)}fromString(e){this.value=[];let t=0,r=0,s="",i=!1;do if(r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1,i){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(s,10);if(isNaN(c))return;o.valueDec=c+a,i=!1}else{const o=new Ql;if(s>Number.MAX_SAFE_INTEGER){oa();const a=BigInt(s);o.valueBigInt=a}else if(o.valueDec=parseInt(s,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,i=!0),this.value.push(o)}while(r!==-1)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}D2.NAME="ObjectIdentifierValueBlock";var R2;class Gr extends ft{constructor(e={}){super(e,D2),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}R2=Gr;q.ObjectIdentifier=R2;Gr.NAME="OBJECT IDENTIFIER";class Yl extends Fr(es){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(r===0)return t;const s=Ee.toUint8Array(e);if(!Or(this,s,t,r))return-1;const i=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Rs(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const t=Kn(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",cr;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r.buffer}toString(){let e="";return this.isHexOnly?e=Oe.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Yl.NAME="relativeSidBlock";class M2 extends Pt{constructor({value:e=js,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const i=new Yl;if(s=i.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(e,t){const r=[];for(let s=0;s<this.value.length;s++){const i=this.value[s].toBER(e);if(i.byteLength===0)return this.error=this.value[s].error,cr;r.push(i)}return rh(r)}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1;const i=new Yl;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(r!==-1);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t&&(s=`{${s}}`),e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}M2.NAME="RelativeObjectIdentifierValueBlock";var L2;class N2 extends ft{constructor(e={}){super(e,M2),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}L2=N2;q.RelativeObjectIdentifier=L2;N2.NAME="RelativeObjectIdentifier";var B2;class ut extends Js{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}B2=ut;q.Sequence=B2;ut.NAME="SEQUENCE";var O2;let F2=class extends Js{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};O2=F2;q.Set=O2;F2.NAME="SET";class U2 extends Fr(Pt){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=js}toJSON(){return{...super.toJSON(),value:this.value}}}U2.NAME="StringValueBlock";class $2 extends U2{}$2.NAME="SimpleStringValueBlock";class Ot extends h2{constructor({...e}={}){super(e,$2)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,Ee.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}Ot.NAME="SIMPLE STRING";class V2 extends Ot{fromBuffer(e){this.valueBlock.valueHexView=Ee.toUint8Array(e);try{this.valueBlock.value=Oe.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=Oe.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(Oe.FromUtf8String(e)),this.valueBlock.value=e}}V2.NAME="Utf8StringValueBlock";var H2;class ts extends V2{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}H2=ts;q.Utf8String=H2;ts.NAME="UTF8String";class z2 extends Ot{fromBuffer(e){this.valueBlock.value=Oe.ToUtf16String(e),this.valueBlock.valueHexView=Ee.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(Oe.FromUtf16String(e))}}z2.NAME="BmpStringValueBlock";var q2;class K2 extends z2{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}q2=K2;q.BmpString=q2;K2.NAME="BMPString";class W2 extends Ot{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let s=0;s<r.length;s+=4)r[s]=r[s+3],r[s+1]=r[s+2],r[s+2]=0,r[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let s=0;s<t;s++){const i=Kn(e.charCodeAt(s),8),o=new Uint8Array(i);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[s*4+c+a]=o[c]}this.valueBlock.value=e}}W2.NAME="UniversalStringValueBlock";var G2;class Q2 extends W2{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}G2=Q2;q.UniversalString=G2;Q2.NAME="UniversalString";var Y2;class X2 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}Y2=X2;q.NumericString=Y2;X2.NAME="NumericString";var Z2;class j2 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Z2=j2;q.PrintableString=Z2;j2.NAME="PrintableString";var J2;class e3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}J2=e3;q.TeletexString=J2;e3.NAME="TeletexString";var t3;class r3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}t3=r3;q.VideotexString=t3;r3.NAME="VideotexString";var n3;class s3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}n3=s3;q.IA5String=n3;s3.NAME="IA5String";var i3;class o3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}i3=o3;q.GraphicString=i3;o3.NAME="GraphicString";var a3;class ah extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}a3=ah;q.VisibleString=a3;ah.NAME="VisibleString";var c3;class l3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}c3=l3;q.GeneralString=c3;l3.NAME="GeneralString";var u3;class h3 extends Ot{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}u3=h3;q.CharacterString=u3;h3.NAME="CharacterString";var d3;class ch extends ah{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let s=0;s<e.length;s++)this.valueBlock.valueHexView[s]=e.charCodeAt(s)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,Ee.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(r===null){this.error="Wrong input string for conversion";return}const s=parseInt(r[1],10);s>=50?this.year=1900+s:this.year=2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=Rt(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=Rt(this.month,2),t[2]=Rt(this.day,2),t[3]=Rt(this.hour,2),t[4]=Rt(this.minute,2),t[5]=Rt(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}d3=ch;q.UTCTime=d3;ch.NAME="UTCTime";var f3;class p3 extends ch{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t=!1,r="",s="",i=0,o,a=0,c=0;if(e[e.length-1]==="Z")r=e.substring(0,e.length-1),t=!0;else{const h=new Number(e[e.length-1]);if(isNaN(h.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(t){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let h=1,d=r.indexOf("+"),f="";if(d===-1&&(d=r.indexOf("-"),h=-1),d!==-1){if(f=r.substring(d+1),r=r.substring(0,d),f.length!==2&&f.length!==4)throw new Error("Wrong input string for conversion");let p=parseInt(f.substring(0,2),10);if(isNaN(p.valueOf()))throw new Error("Wrong input string for conversion");if(a=h*p,f.length===4){if(p=parseInt(f.substring(2,4),10),isNaN(p.valueOf()))throw new Error("Wrong input string for conversion");c=h*p}}}let l=r.indexOf(".");if(l===-1&&(l=r.indexOf(",")),l!==-1){const h=new Number(`0${r.substring(l)}`);if(isNaN(h.valueOf()))throw new Error("Wrong input string for conversion");i=h.valueOf(),s=r.substring(0,l)}else s=r;switch(!0){case s.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case s.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let h=60*i;this.minute=Math.floor(h),h=60*(h-this.minute),this.second=Math.floor(h),h=1e3*(h-this.second),this.millisecond=Math.floor(h)}break;case s.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let h=60*i;this.second=Math.floor(h),h=1e3*(h-this.second),this.millisecond=Math.floor(h)}break;case s.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const h=1e3*i;this.millisecond=Math.floor(h)}break;default:throw new Error("Wrong input string for conversion")}const u=o.exec(s);if(u===null)throw new Error("Wrong input string for conversion");for(let h=1;h<u.length;h++)switch(h){case 1:this.year=parseInt(u[h],10);break;case 2:this.month=parseInt(u[h],10);break;case 3:this.day=parseInt(u[h],10);break;case 4:this.hour=parseInt(u[h],10)+a;break;case 5:this.minute=parseInt(u[h],10)+c;break;case 6:this.second=parseInt(u[h],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const h=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=h.getUTCFullYear(),this.month=h.getUTCMonth(),this.day=h.getUTCDay(),this.hour=h.getUTCHours(),this.minute=h.getUTCMinutes(),this.second=h.getUTCSeconds(),this.millisecond=h.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(Rt(this.year,4)),t.push(Rt(this.month,2)),t.push(Rt(this.day,2)),t.push(Rt(this.hour,2)),t.push(Rt(this.minute,2)),t.push(Rt(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(Rt(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}f3=p3;q.GeneralizedTime=f3;p3.NAME="GeneralizedTime";var g3;class m3 extends ts{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}g3=m3;q.DATE=g3;m3.NAME="DATE";var y3;class w3 extends ts{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}y3=w3;q.TimeOfDay=y3;w3.NAME="TimeOfDay";var b3;class v3 extends ts{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}b3=v3;q.DateTime=b3;v3.NAME="DateTime";var E3;class S3 extends ts{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}E3=S3;q.Duration=E3;S3.NAME="Duration";var _3;class x3 extends ts{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}_3=x3;q.TIME=_3;x3.NAME="TIME";function K(n,e="utf8"){const t=n2[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}function un(n){if(isNaN(n)||n<=0)throw new B("random bytes length must be a Number bigger than 0");return Ja(n)}class Rd extends Error{constructor(e="An error occurred while signing a message"){super(e),this.name="SigningError"}}class Md extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class N7 extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Er={get(n=globalThis){const e=n.crypto;if(e?.subtle==null)throw new N7("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}};async function B7(n){const e=await Er.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:n,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),t=await U7(e);return{privateKey:t[0],publicKey:t[1]}}async function O7(n,e){const t=await Er.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await Er.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},t,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(r,0,r.byteLength)}async function F7(n,e,t){const r=await Er.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return Er.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,e,t instanceof Uint8Array?t:t.subarray())}async function U7(n){if(n.privateKey==null||n.publicKey==null)throw new B("Private and public key are required");return Promise.all([Er.get().subtle.exportKey("jwk",n.privateKey),Er.get().subtle.exportKey("jwk",n.publicKey)])}function k3(n){if(n.kty!=="RSA")throw new B("invalid key type");if(n.n==null)throw new B("invalid key modulus");return V(n.n,"base64url").length*8}class lh{type="RSA";_key;_raw;_multihash;constructor(e,t){this._key=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=hh(this._key)),this._raw}toMultihash(){return this._multihash}toCID(){return Y.createV1(114,this._multihash)}toString(){return ze.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}verify(e,t){return F7(this._key,t,e)}}class I3{type="RSA";_key;_raw;publicKey;constructor(e,t){this._key=e,this.publicKey=t}get raw(){return this._raw==null&&(this._raw=V7(this._key)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}sign(e){return O7(this._key,e)}}const A3=8192,uh=18;function $7(n){const{result:e}=_i(n),t=e.valueBlock.value;return{n:fr(t[1]),e:fr(t[2]),d:fr(t[3]),p:fr(t[4]),q:fr(t[5]),dp:fr(t[6]),dq:fr(t[7]),qi:fr(t[8]),kty:"RSA",alg:"RS256"}}function V7(n){if(n.n==null||n.e==null||n.d==null||n.p==null||n.q==null||n.dp==null||n.dq==null||n.qi==null)throw new B("JWK was missing components");const t=new ut({value:[new Fe({value:0}),Fe.fromBigInt(pr(V(n.n,"base64url"))),Fe.fromBigInt(pr(V(n.e,"base64url"))),Fe.fromBigInt(pr(V(n.d,"base64url"))),Fe.fromBigInt(pr(V(n.p,"base64url"))),Fe.fromBigInt(pr(V(n.q,"base64url"))),Fe.fromBigInt(pr(V(n.dp,"base64url"))),Fe.fromBigInt(pr(V(n.dq,"base64url"))),Fe.fromBigInt(pr(V(n.qi,"base64url")))]}).toBER();return new Uint8Array(t,0,t.byteLength)}function H7(n){const{result:e}=_i(n),t=e.valueBlock.value[1].valueBlock.value[0].valueBlock.value;return{kty:"RSA",n:fr(t[0]),e:fr(t[1])}}function hh(n){if(n.n==null||n.e==null)throw new B("JWK was missing components");const t=new ut({value:[new ut({value:[new Gr({value:"1.2.840.113549.1.1.1"}),new Oi]}),new ih({valueHex:new ut({value:[Fe.fromBigInt(pr(V(n.n,"base64url"))),Fe.fromBigInt(pr(V(n.e,"base64url")))]}).toBER()})]}).toBER();return new Uint8Array(t,0,t.byteLength)}function fr(n){let e=n.valueBlock.valueHexView;for(;e[0]===0;)e=e.subarray(1);return K(e,"base64url")}function pr(n){const e=[];return n.forEach(function(t){let r=t.toString(16);r.length%2>0&&(r=`0${r}`),e.push(r)}),BigInt("0x"+e.join(""))}function T3(n){const e=$7(n);return q7(e)}function z7(n){const e=H7(n);if(k3(e)>A3)throw new Xo("Key size is too large");const t=rn(ln.encode({Type:$e.RSA,Data:n})),r=Br(uh,t);return new lh(e,r)}function q7(n){if(k3(n)>A3)throw new B("Key size is too large");const e=W7(n),t=rn(ln.encode({Type:$e.RSA,Data:hh(e.publicKey)})),r=Br(uh,t);return new I3(e.privateKey,new lh(e.publicKey,r))}async function K7(n){const e=await B7(n),t=rn(ln.encode({Type:$e.RSA,Data:hh(e.publicKey)})),r=Br(uh,t);return new I3(e.privateKey,new lh(e.publicKey,r))}function W7(n){if(n==null)throw new B("Missing key parameter");return{privateKey:n,publicKey:{kty:n.kty,n:n.n,e:n.e}}}class P3 extends C0{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ja(e);const r=Vn(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),i.fill(0)}update(e){return ea(this),this.iHash.update(e),this}digestInto(e){ea(this),Za(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const to=(n,e,t)=>new P3(n,e).update(t).digest();to.create=(n,e)=>new P3(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ld(n){n.lowS!==void 0&&Mr("lowS",n.lowS),n.prehash!==void 0&&Mr("prehash",n.prehash)}function G7(n){const e=Qu(n);Jn(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Q7,hexToBytes:Y7}=K5;class X7 extends Error{constructor(e=""){super(e)}}const Dr={Err:X7,_tlv:{encode:(n,e)=>{const{Err:t}=Dr;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=ys(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?ys(s.length/2|128):"";return ys(n)+i+s+e},decode(n,e){const{Err:t}=Dr;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(r,r+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=Dr;if(n<Rr)throw new e("integer: negative integers are not allowed");let t=ys(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=Dr;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Q7(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=Dr,s=typeof n=="string"?Y7(n):n;eo(s);const{v:i,l:o}=r.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:l,l:u}=r.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(n){const{_tlv:e,_int:t}=Dr,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),i=r+s;return e.encode(48,i)}},Rr=BigInt(0),Qe=BigInt(1);BigInt(2);const Nd=BigInt(3);BigInt(4);function Z7(n){const e=G7(n),{Fp:t}=e,r=sc(e.n,e.nBitLength),s=e.toBytes||((m,g,y)=>{const b=g.toAffine();return qn(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),i=e.fromBytes||(m=>{const g=m.subarray(1),y=t.fromBytes(g.subarray(0,t.BYTES)),b=t.fromBytes(g.subarray(t.BYTES,2*t.BYTES));return{x:y,y:b}});function o(m){const{a:g,b:y}=e,b=t.sqr(m),w=t.mul(b,m);return t.add(t.add(w,t.mul(m,g)),y)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(m){return nc(m,Qe,e.n)}function c(m){const{allowedPrivateKeyLengths:g,nByteLength:y,wrapPrivateKey:b,n:w}=e;if(g&&typeof m!="bigint"){if(Hn(m)&&(m=zn(m)),typeof m!="string"||!g.includes(m.length))throw new Error("invalid private key");m=m.padStart(y*2,"0")}let k;try{k=typeof m=="bigint"?m:Ln(Be("private key",m,y))}catch{throw new Error("invalid private key, expected hex or "+y+" bytes, got "+typeof m)}return b&&(k=xe(k,w)),kt("private key",k,Qe,w),k}function l(m){if(!(m instanceof d))throw new Error("ProjectivePoint expected")}const u=Mi((m,g)=>{const{px:y,py:b,pz:w}=m;if(t.eql(w,t.ONE))return{x:y,y:b};const k=m.is0();g==null&&(g=k?t.ONE:t.inv(w));const _=t.mul(y,g),A=t.mul(b,g),I=t.mul(w,g);if(k)return{x:t.ZERO,y:t.ZERO};if(!t.eql(I,t.ONE))throw new Error("invZ was invalid");return{x:_,y:A}}),h=Mi(m=>{if(m.is0()){if(e.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:g,y}=m.toAffine();if(!t.isValid(g)||!t.isValid(y))throw new Error("bad point: x or y not FE");const b=t.sqr(y),w=o(g);if(!t.eql(b,w))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(g,y,b){if(this.px=g,this.py=y,this.pz=b,g==null||!t.isValid(g))throw new Error("x required");if(y==null||!t.isValid(y))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required");Object.freeze(this)}static fromAffine(g){const{x:y,y:b}=g||{};if(!g||!t.isValid(y)||!t.isValid(b))throw new Error("invalid affine point");if(g instanceof d)throw new Error("projective point not allowed");const w=k=>t.eql(k,t.ZERO);return w(y)&&w(b)?d.ZERO:new d(y,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(g){const y=t.invertBatch(g.map(b=>b.pz));return g.map((b,w)=>b.toAffine(y[w])).map(d.fromAffine)}static fromHex(g){const y=d.fromAffine(i(Be("pointHex",g)));return y.assertValidity(),y}static fromPrivateKey(g){return d.BASE.multiply(c(g))}static msm(g,y){return z0(d,r,g,y)}_setWindowSize(g){p.setWindowSize(this,g)}assertValidity(){h(this)}hasEvenY(){const{y:g}=this.toAffine();if(t.isOdd)return!t.isOdd(g);throw new Error("Field doesn't support isOdd")}equals(g){l(g);const{px:y,py:b,pz:w}=this,{px:k,py:_,pz:A}=g,I=t.eql(t.mul(y,A),t.mul(k,w)),D=t.eql(t.mul(b,A),t.mul(_,w));return I&&D}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:g,b:y}=e,b=t.mul(y,Nd),{px:w,py:k,pz:_}=this;let A=t.ZERO,I=t.ZERO,D=t.ZERO,v=t.mul(w,w),M=t.mul(k,k),L=t.mul(_,_),N=t.mul(w,k);return N=t.add(N,N),D=t.mul(w,_),D=t.add(D,D),A=t.mul(g,D),I=t.mul(b,L),I=t.add(A,I),A=t.sub(M,I),I=t.add(M,I),I=t.mul(A,I),A=t.mul(N,A),D=t.mul(b,D),L=t.mul(g,L),N=t.sub(v,L),N=t.mul(g,N),N=t.add(N,D),D=t.add(v,v),v=t.add(D,v),v=t.add(v,L),v=t.mul(v,N),I=t.add(I,v),L=t.mul(k,_),L=t.add(L,L),v=t.mul(L,N),A=t.sub(A,v),D=t.mul(L,M),D=t.add(D,D),D=t.add(D,D),new d(A,I,D)}add(g){l(g);const{px:y,py:b,pz:w}=this,{px:k,py:_,pz:A}=g;let I=t.ZERO,D=t.ZERO,v=t.ZERO;const M=e.a,L=t.mul(e.b,Nd);let N=t.mul(y,k),O=t.mul(b,_),P=t.mul(w,A),R=t.add(y,b),x=t.add(k,_);R=t.mul(R,x),x=t.add(N,O),R=t.sub(R,x),x=t.add(y,w);let E=t.add(k,A);return x=t.mul(x,E),E=t.add(N,P),x=t.sub(x,E),E=t.add(b,w),I=t.add(_,A),E=t.mul(E,I),I=t.add(O,P),E=t.sub(E,I),v=t.mul(M,x),I=t.mul(L,P),v=t.add(I,v),I=t.sub(O,v),v=t.add(O,v),D=t.mul(I,v),O=t.add(N,N),O=t.add(O,N),P=t.mul(M,P),x=t.mul(L,x),O=t.add(O,P),P=t.sub(N,P),P=t.mul(M,P),x=t.add(x,P),N=t.mul(O,x),D=t.add(D,N),N=t.mul(E,x),I=t.mul(R,I),I=t.sub(I,N),N=t.mul(R,O),v=t.mul(E,v),v=t.add(v,N),new d(I,D,v)}subtract(g){return this.add(g.negate())}is0(){return this.equals(d.ZERO)}wNAF(g){return p.wNAFCached(this,g,d.normalizeZ)}multiplyUnsafe(g){const{endo:y,n:b}=e;kt("scalar",g,Rr,b);const w=d.ZERO;if(g===Rr)return w;if(this.is0()||g===Qe)return this;if(!y||p.hasPrecomputes(this))return p.wNAFCachedUnsafe(this,g,d.normalizeZ);let{k1neg:k,k1:_,k2neg:A,k2:I}=y.splitScalar(g),D=w,v=w,M=this;for(;_>Rr||I>Rr;)_&Qe&&(D=D.add(M)),I&Qe&&(v=v.add(M)),M=M.double(),_>>=Qe,I>>=Qe;return k&&(D=D.negate()),A&&(v=v.negate()),v=new d(t.mul(v.px,y.beta),v.py,v.pz),D.add(v)}multiply(g){const{endo:y,n:b}=e;kt("scalar",g,Qe,b);let w,k;if(y){const{k1neg:_,k1:A,k2neg:I,k2:D}=y.splitScalar(g);let{p:v,f:M}=this.wNAF(A),{p:L,f:N}=this.wNAF(D);v=p.constTimeNegate(_,v),L=p.constTimeNegate(I,L),L=new d(t.mul(L.px,y.beta),L.py,L.pz),w=v.add(L),k=M.add(N)}else{const{p:_,f:A}=this.wNAF(g);w=_,k=A}return d.normalizeZ([w,k])[0]}multiplyAndAddUnsafe(g,y,b){const w=d.BASE,k=(A,I)=>I===Rr||I===Qe||!A.equals(w)?A.multiplyUnsafe(I):A.multiply(I),_=k(this,y).add(k(g,b));return _.is0()?void 0:_}toAffine(g){return u(this,g)}isTorsionFree(){const{h:g,isTorsionFree:y}=e;if(g===Qe)return!0;if(y)return y(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:g,clearCofactor:y}=e;return g===Qe?this:y?y(d,this):this.multiplyUnsafe(e.h)}toRawBytes(g=!0){return Mr("isCompressed",g),this.assertValidity(),s(d,this,g)}toHex(g=!0){return Mr("isCompressed",g),zn(this.toRawBytes(g))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const f=e.nBitLength,p=H0(d,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function j7(n){const e=Qu(n);return Jn(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function J7(n){const e=j7(n),{Fp:t,n:r}=e,s=t.BYTES+1,i=2*t.BYTES+1;function o(P){return xe(P,r)}function a(P){return Hl(P,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:u,isWithinCurveOrder:h}=Z7({...e,toBytes(P,R,x){const E=R.toAffine(),C=t.toBytes(E.x),T=qn;return Mr("isCompressed",x),x?T(Uint8Array.from([R.hasEvenY()?2:3]),C):T(Uint8Array.from([4]),C,t.toBytes(E.y))},fromBytes(P){const R=P.length,x=P[0],E=P.subarray(1);if(R===s&&(x===2||x===3)){const C=Ln(E);if(!nc(C,Qe,t.ORDER))throw new Error("Point is not on curve");const T=u(C);let U;try{U=t.sqrt(T)}catch(j){const Z=j instanceof Error?": "+j.message:"";throw new Error("Point is not on curve"+Z)}const H=(U&Qe)===Qe;return(x&1)===1!==H&&(U=t.neg(U)),{x:C,y:U}}else if(R===i&&x===4){const C=t.fromBytes(E.subarray(0,t.BYTES)),T=t.fromBytes(E.subarray(t.BYTES,2*t.BYTES));return{x:C,y:T}}else{const C=s,T=i;throw new Error("invalid Point, expected length of "+C+", or uncompressed "+T+", got "+R)}}}),d=P=>zn(Cs(P,e.nByteLength));function f(P){const R=r>>Qe;return P>R}function p(P){return f(P)?o(-P):P}const m=(P,R,x)=>Ln(P.slice(R,x));class g{constructor(R,x,E){this.r=R,this.s=x,this.recovery=E,this.assertValidity()}static fromCompact(R){const x=e.nByteLength;return R=Be("compactSignature",R,x*2),new g(m(R,0,x),m(R,x,2*x))}static fromDER(R){const{r:x,s:E}=Dr.toSig(Be("DER",R));return new g(x,E)}assertValidity(){kt("r",this.r,Qe,r),kt("s",this.s,Qe,r)}addRecoveryBit(R){return new g(this.r,this.s,R)}recoverPublicKey(R){const{r:x,s:E,recovery:C}=this,T=A(Be("msgHash",R));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const U=C===2||C===3?x+e.n:x;if(U>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const H=C&1?"03":"02",W=c.fromHex(H+d(U)),j=a(U),Z=o(-T*j),ie=o(E*j),ue=c.BASE.multiplyAndAddUnsafe(W,Z,ie);if(!ue)throw new Error("point at infinify");return ue.assertValidity(),ue}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Ps(this.toDERHex())}toDERHex(){return Dr.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ps(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const y={isValidPrivateKey(P){try{return l(P),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const P=U0(e.n);return e8(e.randomBytes(P),e.n)},precompute(P=8,R=c.BASE){return R._setWindowSize(P),R.multiply(BigInt(3)),R}};function b(P,R=!0){return c.fromPrivateKey(P).toRawBytes(R)}function w(P){const R=Hn(P),x=typeof P=="string",E=(R||x)&&P.length;return R?E===s||E===i:x?E===2*s||E===2*i:P instanceof c}function k(P,R,x=!0){if(w(P))throw new Error("first arg must be private key");if(!w(R))throw new Error("second arg must be public key");return c.fromHex(R).multiply(l(P)).toRawBytes(x)}const _=e.bits2int||function(P){if(P.length>8192)throw new Error("input is too large");const R=Ln(P),x=P.length*8-e.nBitLength;return x>0?R>>BigInt(x):R},A=e.bits2int_modN||function(P){return o(_(P))},I=Gu(e.nBitLength);function D(P){return kt("num < 2^"+e.nBitLength,P,Rr,I),Cs(P,e.nByteLength)}function v(P,R,x=M){if(["recovered","canonical"].some(Ae=>Ae in x))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:C}=e;let{lowS:T,prehash:U,extraEntropy:H}=x;T==null&&(T=!0),P=Be("msgHash",P),Ld(x),U&&(P=Be("prehashed msgHash",E(P)));const W=A(P),j=l(R),Z=[D(j),D(W)];if(H!=null&&H!==!1){const Ae=H===!0?C(t.BYTES):H;Z.push(Be("extraEntropy",Ae))}const ie=qn(...Z),ue=W;function Ie(Ae){const De=_(Ae);if(!h(De))return;const st=a(De),mt=c.BASE.multiply(De).toAffine(),lt=o(mt.x);if(lt===Rr)return;const lr=o(st*o(ue+lt*j));if(lr===Rr)return;let kr=(mt.x===lt?0:2)|Number(mt.y&Qe),ci=lr;return T&&f(lr)&&(ci=p(lr),kr^=1),new g(lt,ci,kr)}return{seed:ie,k2sig:Ie}}const M={lowS:e.lowS,prehash:!1},L={lowS:e.lowS,prehash:!1};function N(P,R,x=M){const{seed:E,k2sig:C}=v(P,R,x),T=e;return N0(T.hash.outputLen,T.nByteLength,T.hmac)(E,C)}c.BASE._setWindowSize(8);function O(P,R,x,E=L){const C=P;R=Be("msgHash",R),x=Be("publicKey",x);const{lowS:T,prehash:U,format:H}=E;if(Ld(E),"strict"in E)throw new Error("options.strict was renamed to lowS");if(H!==void 0&&H!=="compact"&&H!=="der")throw new Error("format must be compact or der");const W=typeof C=="string"||Hn(C),j=!W&&!H&&typeof C=="object"&&C!==null&&typeof C.r=="bigint"&&typeof C.s=="bigint";if(!W&&!j)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Z,ie;try{if(j&&(Z=new g(C.r,C.s)),W){try{H!=="compact"&&(Z=g.fromDER(C))}catch(kr){if(!(kr instanceof Dr.Err))throw kr}!Z&&H!=="der"&&(Z=g.fromCompact(C))}ie=c.fromHex(x)}catch{return!1}if(!Z||T&&Z.hasHighS())return!1;U&&(R=e.hash(R));const{r:ue,s:Ie}=Z,Ae=A(R),De=a(Ie),st=o(Ae*De),mt=o(ue*De),lt=c.BASE.multiplyAndAddUnsafe(ie,st,mt)?.toAffine();return lt?o(lt.x)===ue:!1}return{CURVE:e,getPublicKey:b,getSharedSecret:k,sign:N,verify:O,ProjectivePoint:c,Signature:g,utils:y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function em(n){return{hash:n,hmac:(e,...t)=>to(n,e,l5(...t)),randomBytes:Ja}}function tm(n,e){const t=r=>J7({...n,...em(r)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C3=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Bd=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),rm=BigInt(1),Xl=BigInt(2),Od=(n,e)=>(n+e/Xl)/e;function nm(n){const e=C3,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=n*n*n%e,u=l*l*n%e,h=Me(u,t,e)*u%e,d=Me(h,t,e)*u%e,f=Me(d,Xl,e)*l%e,p=Me(f,s,e)*f%e,m=Me(p,i,e)*p%e,g=Me(m,a,e)*m%e,y=Me(g,c,e)*g%e,b=Me(y,a,e)*m%e,w=Me(b,t,e)*u%e,k=Me(w,o,e)*p%e,_=Me(k,r,e)*l%e,A=Me(_,Xl,e);if(!Zl.eql(Zl.sqr(A),n))throw new Error("Cannot find square root");return A}const Zl=sc(C3,void 0,void 0,{sqrt:nm}),Sr=tm({a:BigInt(0),b:BigInt(7),Fp:Zl,n:Bd,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Bd,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-rm*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Od(i*n,e),c=Od(-r*n,e);let l=xe(n-a*t-c*s,e),u=xe(-a*r-c*i,e);const h=l>o,d=u>o;if(h&&(l=e-l),d&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:h,k1:l,k2neg:d,k2:u}}}},rn);BigInt(0);Sr.ProjectivePoint;function We(n,e){e==null&&(e=n.reduce((s,i)=>s+i.length,0));const t=ct(e);let r=0;for(const s of n)t.set(s,r),r+=s.length;return t}function D3(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function sm(n,e){const t=Nt.digest(e instanceof Uint8Array?e:e.subarray());if(D3(t))return t.then(({digest:r})=>Sr.sign(r,n).toDERRawBytes()).catch(r=>{throw new Rd(String(r))});try{return Sr.sign(t.digest,n).toDERRawBytes()}catch(r){throw new Rd(String(r))}}function im(n,e,t){const r=Nt.digest(t instanceof Uint8Array?t:t.subarray());if(D3(r))return r.then(({digest:s})=>Sr.verify(e,s,n)).catch(s=>{throw new Md(String(s))});try{return Sr.verify(e,r.digest,n)}catch(s){throw new Md(String(s))}}class R3{type="secp256k1";raw;_key;constructor(e){this._key=lm(e),this.raw=am(this._key)}toMultihash(){return $n.digest(rr(this))}toCID(){return Y.createV1(114,this.toMultihash())}toString(){return ze.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}verify(e,t){return im(this._key,t,e)}}class M3{type="secp256k1";raw;publicKey;constructor(e,t){this.raw=cm(e),this.publicKey=new R3(t??um(e))}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:pe(this.raw,e.raw)}sign(e){return sm(this.raw,e)}}function L3(n){return new M3(n)}function N3(n){return new R3(n)}async function om(){const n=hm();return new M3(n)}function am(n){return Sr.ProjectivePoint.fromHex(n).toRawBytes(!0)}function cm(n){try{return Sr.getPublicKey(n,!0),n}catch(e){throw new E0(String(e))}}function lm(n){try{return Sr.ProjectivePoint.fromHex(n),n}catch(e){throw new Xo(String(e))}}function um(n){try{return Sr.getPublicKey(n,!0)}catch(e){throw new E0(String(e))}}function hm(){return Sr.utils.randomPrivateKey()}async function B3(n,e){if(n==="Ed25519")return v8();if(n==="secp256k1")return om();if(n==="RSA")return K7(2048);throw new Xs}function Tt(n){const{Type:e,Data:t}=ln.decode(n),r=t??new Uint8Array;switch(e){case $e.RSA:return z7(r);case $e.Ed25519:return Q0(r);case $e.secp256k1:return N3(r);default:throw new Xs}}function O3(n){const{Type:e,Data:t}=ln.decode(n.digest),r=t??new Uint8Array;switch(e){case $e.Ed25519:return Q0(r);case $e.secp256k1:return N3(r);default:throw new Xs}}function rr(n){return ln.encode({Type:$e[n.type],Data:n.raw})}function dm(n){const e=ia.decode(n),t=e.Data??new Uint8Array;switch(e.Type){case $e.RSA:return T3(t);case $e.Ed25519:return G0(t);case $e.secp256k1:return L3(t);default:throw new Xs}}function fm(n){return n.byteLength===64?G0(n):n.byteLength===32?L3(n):T3(n)}function ac(n){return ia.encode({Type:$e[n.type],Data:n.raw})}const F3=Symbol.for("nodejs.util.inspect.custom"),pm=114;class dh{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Ou]=!0;toString(){return this.string==null&&(this.string=ze.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Y.createV1(pm,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return pe(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return pe(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[F3](){return`PeerId(${this.toString()})`}}class U3 extends dh{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class $3 extends dh{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class V3 extends dh{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const gm=2336;class H3{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=$n.digest(V(this.url))}[F3](){return`PeerId(${this.url})`}[Ou]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Y.createV1(gm,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=K(e)),e.toString()===this.toString())}}const mm=114,Fd=2336;function Ue(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=je(ze.decode(`z${n}`));else throw new B('Please pass a multibase decoder for strings that do not start with "1" or "Q"');return Ft(t)}function Ms(n){if(n.type==="Ed25519")return new $3({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new V3({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new U3({multihash:n.toCID().multihash,publicKey:n});throw new Xs}function ym(n){return Ms(n.publicKey)}function Ft(n){if(bm(n))return new U3({multihash:n});if(wm(n))try{const e=O3(n);if(e.type==="Ed25519")return new $3({multihash:n,publicKey:e});if(e.type==="secp256k1")return new V3({multihash:n,publicKey:e})}catch{const t=K(n.digest);return new H3(new URL(t))}throw new $u("Supplied PeerID Multihash is invalid")}function ro(n){if(n?.multihash==null||n.version==null||n.version===1&&n.code!==mm&&n.code!==Fd)throw new o6("Supplied PeerID CID is invalid");if(n.code===Fd){const e=K(n.multihash.digest);return new H3(new URL(e))}return Ft(n.multihash)}function wm(n){return n.code===$n.code}function bm(n){return n.code===Nt.code}const z3=Symbol.for("@achingbrain/uint8arraylist");function Ud(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const s=t+r.byteLength;if(e<s)return{buf:r,index:e-t};t=s}throw new RangeError("index is out of bounds")}function yi(n){return!!n?.[z3]}class ge{bufs;length;[z3]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(yi(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(yi(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Ud(this.bufs,e);return t.buf[t.index]}set(e,t){const r=Ud(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(yi(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:s}=this._subList(e,t);return We(r,s)}subarray(e,t){const{bufs:r,length:s}=this._subList(e,t);return r.length===1?r[0]:We(r,s)}sublist(e,t){const{bufs:r,length:s}=this._subList(e,t),i=new ge;return i.length=s,i.bufs=[...r],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){r.push(o);break}const h=e-a;r.push(o.subarray(h,h+(t-e)));break}if(l){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(u){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!yi(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[r[h]]=h;const a=o,c=this.byteLength-r.byteLength,l=r.byteLength-1;let u;for(let h=t;h<=c;h+=u){u=0;for(let d=l;d>=0;d--){const f=this.get(h+d);if(r[d]!==f){u=Math.max(1,d-a[f]);break}}if(u===0)return h}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=ct(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const s=oe(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,r),this.write(s,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,r),this.write(s,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,r),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=ct(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const s=oe(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,r),this.write(s,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,r),this.write(s,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,r),this.write(s,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,r),this.write(s,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,r),this.write(s,e)}equals(e){if(e==null||!(e instanceof ge)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!pe(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new ge;return r.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),r.length=t,r}}function q3(n){return n[Symbol.asyncIterator]!=null}const cc=n=>{const e=ye(n),t=ct(e);return Ze(n,t),cc.bytes=e,t};cc.bytes=0;function lc(n,e){e=e??{};const t=e.lengthEncoder??cc;function*r(s){const i=t(s.byteLength);i instanceof Uint8Array?yield i:yield*i,s instanceof Uint8Array?yield s:yield*s}return q3(n)?async function*(){for await(const s of n)yield*r(s)}():function*(){for(const s of n)yield*r(s)}()}lc.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??cc;return new ge(t(n.byteLength),n)};let vm=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Em=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Sm=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},$d=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};const _m=8,xm=1024*1024*4;var An;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(An||(An={}));const fh=n=>{const e=ar(n);return fh.bytes=ye(e),e};fh.bytes=0;function Fi(n,e){const t=new ge;let r=An.LENGTH,s=-1;const i=e?.lengthDecoder??fh,o=e?.maxLengthLength??_m,a=e?.maxDataLength??xm;function*c(){for(;t.byteLength>0;){if(r===An.LENGTH)try{if(s=i(t),s<0)throw new vm("Invalid message length");if(s>a)throw new Em("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),r=An.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new Sm("Message length length too long");break}throw l}if(r===An.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,r=An.LENGTH}}}return q3(n)?async function*(){for await(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new $d("Unexpected end of input")}():function*(){for(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new $d("Unexpected end of input")}()}Fi.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Fi(r,{...e??{},onLength:i=>{t=i}})};function ae(){const n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}class Vd{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class Hc{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Vd(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Vd(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let km=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function _r(n={}){return Im(t=>{const r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function Im(n,e){e=e??{};let t=e.onEnd,r=new Hc,s,i,o,a=ae();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((g,y)=>{i=b=>{i=null,r.push(b);try{g(n(r))}catch(w){y(w)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=ae()})}},l=g=>i!=null?i(g):(r.push(g),s),u=g=>(r=new Hc,i!=null?i({error:g}):(r.push({error:g}),s)),h=g=>{if(o)return s;if(e?.objectMode!==!0&&g?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:g})},d=g=>o?s:(o=!0,g!=null?u(g):l({done:!0})),f=()=>(r=new Hc,d(),{done:!0}),p=g=>(d(g),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:f,throw:p,push:h,end:d,get readableLength(){return r.size},onEmpty:async g=>{const y=g?.signal;if(y?.throwIfAborted(),r.isEmpty())return;let b,w;y!=null&&(b=new Promise((k,_)=>{w=()=>{_(new km)},y.addEventListener("abort",w)}));try{await Promise.race([a.promise,b])}finally{w!=null&&y!=null&&y?.removeEventListener("abort",w)}}},t==null)return s;const m=s;return s={[Symbol.asyncIterator](){return this},next(){return m.next()},throw(g){return m.throw(g),t!=null&&(t(g),t=void 0),{done:!0}},return(){return m.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(g){return m.end(g),t!=null&&(t(g),t=void 0),s},get readableLength(){return m.readableLength},onEmpty:g=>m.onEmpty(g)},s}function Am(n){return n[Symbol.asyncIterator]!=null}function sn(...n){const e=[];for(const t of n)Am(t)||e.push(t);return e.length===n.length?function*(){for(const t of e)yield*t}():async function*(){const t=_r({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(n.map(async r=>{for await(const s of r)t.push(s)})),t.end()}catch(r){t.end(r)}}),yield*t}()}function Bt(n,...e){if(n==null)throw new Error("Empty pipeline");if(zc(n)){const r=n;n=()=>r.source}else if(W3(n)||K3(n)){const r=n;n=()=>r}const t=[n,...e];if(t.length>1&&zc(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let r=1;r<t.length-1;r++)zc(t[r])&&(t[r]=Pm(t[r]));return Tm(...t)}const Tm=(...n)=>{let e;for(;n.length>0;)e=n.shift()(e);return e},K3=n=>n?.[Symbol.asyncIterator]!=null,W3=n=>n?.[Symbol.iterator]!=null,zc=n=>n==null?!1:n.sink!=null&&n.source!=null,Pm=n=>e=>{const t=n.sink(e);if(t?.then!=null){const r=_r({objectMode:!0});t.then(()=>{r.end()},o=>{r.end(o)});let s;const i=n.source;if(K3(i))s=async function*(){yield*i,r.end()};else if(W3(i))s=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return sn(r,s())}return n.source},ei=1e3,ph=60*ei,Hd="/floodsub/1.0.0",zd="/meshsub/1.0.0",Cm="/meshsub/1.1.0",qc="/meshsub/1.2.0",Dm=6,Rm=4,Mm=12,Lm=4,Nm=2,Bm=5,Om=3,Fm=6,Um=.25,$m=3,qd=100,Vm=ei,Hm=ph,zm=16,qm=ph,Km=10*ei,Wm=15,Gm=300,Qm=ei,Ym=60,Xm=2,Zm=10*ei,us=5e3,jm=10,Jm=3*ei,e9=2*ph,t9=120*1e3,r9="ERR_TOPIC_VALIDATOR_REJECT",n9="ERR_TOPIC_VALIDATOR_IGNORE",s9=0,i9=128,o9=1e3,a9=1e3,c9=1,l9=512,u9=512,h9={maxSubscriptions:1/0,maxMessages:1/0,maxIhaveMessageIDs:1/0,maxIwantMessageIDs:1/0,maxIdontwantMessageIDs:1/0,maxControlMessages:1/0,maxPeerInfos:1/0};var Bn;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.subscribe!=null&&(i.uint32(8),i.bool(s.subscribe)),s.topic!=null&&(i.uint32(18),i.string(s.topic)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.subscribe=s.bool();break}case 2:{a.topic=s.string();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)})(n.SubOpts||(n.SubOpts={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.from!=null&&(i.uint32(10),i.bytes(s.from)),s.data!=null&&(i.uint32(18),i.bytes(s.data)),s.seqno!=null&&(i.uint32(26),i.bytes(s.seqno)),s.topic!=null&&s.topic!==""&&(i.uint32(34),i.string(s.topic)),s.signature!=null&&(i.uint32(42),i.bytes(s.signature)),s.key!=null&&(i.uint32(50),i.bytes(s.key)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={topic:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.from=s.bytes();break}case 2:{a.data=s.bytes();break}case 3:{a.seqno=s.bytes();break}case 4:{a.topic=s.string();break}case 5:{a.signature=s.bytes();break}case 6:{a.key=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.Message||(n.Message={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.ihave!=null)for(const a of s.ihave)i.uint32(10),n.ControlIHave.codec().encode(a,i);if(s.iwant!=null)for(const a of s.iwant)i.uint32(18),n.ControlIWant.codec().encode(a,i);if(s.graft!=null)for(const a of s.graft)i.uint32(26),n.ControlGraft.codec().encode(a,i);if(s.prune!=null)for(const a of s.prune)i.uint32(34),n.ControlPrune.codec().encode(a,i);if(s.idontwant!=null)for(const a of s.idontwant)i.uint32(42),n.ControlIDontWant.codec().encode(a,i);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={ihave:[],iwant:[],graft:[],prune:[],idontwant:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{if(o.limits?.ihave!=null&&a.ihave.length===o.limits.ihave)throw new _e('Decode error - map field "ihave" had too many elements');a.ihave.push(n.ControlIHave.codec().decode(s,s.uint32(),{limits:o.limits?.ihave$}));break}case 2:{if(o.limits?.iwant!=null&&a.iwant.length===o.limits.iwant)throw new _e('Decode error - map field "iwant" had too many elements');a.iwant.push(n.ControlIWant.codec().decode(s,s.uint32(),{limits:o.limits?.iwant$}));break}case 3:{if(o.limits?.graft!=null&&a.graft.length===o.limits.graft)throw new _e('Decode error - map field "graft" had too many elements');a.graft.push(n.ControlGraft.codec().decode(s,s.uint32(),{limits:o.limits?.graft$}));break}case 4:{if(o.limits?.prune!=null&&a.prune.length===o.limits.prune)throw new _e('Decode error - map field "prune" had too many elements');a.prune.push(n.ControlPrune.codec().decode(s,s.uint32(),{limits:o.limits?.prune$}));break}case 5:{if(o.limits?.idontwant!=null&&a.idontwant.length===o.limits.idontwant)throw new _e('Decode error - map field "idontwant" had too many elements');a.idontwant.push(n.ControlIDontWant.codec().decode(s,s.uint32(),{limits:o.limits?.idontwant$}));break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlMessage||(n.ControlMessage={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(18),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.topicID=s.string();break}case 2:{if(o.limits?.messageIDs!=null&&a.messageIDs.length===o.limits.messageIDs)throw new _e('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlIHave||(n.ControlIHave={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(10),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{if(o.limits?.messageIDs!=null&&a.messageIDs.length===o.limits.messageIDs)throw new _e('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlIWant||(n.ControlIWant={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.topicID=s.string();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlGraft||(n.ControlGraft={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),s.peers!=null)for(const a of s.peers)i.uint32(18),n.PeerInfo.codec().encode(a,i);s.backoff!=null&&(i.uint32(24),i.uint64Number(s.backoff)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={peers:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.topicID=s.string();break}case 2:{if(o.limits?.peers!=null&&a.peers.length===o.limits.peers)throw new _e('Decode error - map field "peers" had too many elements');a.peers.push(n.PeerInfo.codec().decode(s,s.uint32(),{limits:o.limits?.peers$}));break}case 3:{a.backoff=s.uint64Number();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlPrune||(n.ControlPrune={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.peerID!=null&&(i.uint32(10),i.bytes(s.peerID)),s.signedPeerRecord!=null&&(i.uint32(18),i.bytes(s.signedPeerRecord)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.peerID=s.bytes();break}case 2:{a.signedPeerRecord=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.PeerInfo||(n.PeerInfo={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(10),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{if(o.limits?.messageIDs!=null&&a.messageIDs.length===o.limits.messageIDs)throw new _e('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.ControlIDontWant||(n.ControlIDontWant={}));let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.subscriptions!=null)for(const i of t.subscriptions)r.uint32(10),n.SubOpts.codec().encode(i,r);if(t.messages!=null)for(const i of t.messages)r.uint32(18),n.Message.codec().encode(i,r);t.control!=null&&(r.uint32(26),n.ControlMessage.codec().encode(t.control,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={subscriptions:[],messages:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.subscriptions!=null&&i.subscriptions.length===s.limits.subscriptions)throw new _e('Decode error - map field "subscriptions" had too many elements');i.subscriptions.push(n.SubOpts.codec().decode(t,t.uint32(),{limits:s.limits?.subscriptions$}));break}case 2:{if(s.limits?.messages!=null&&i.messages.length===s.limits.messages)throw new _e('Decode error - map field "messages" had too many elements');i.messages.push(n.Message.codec().decode(t,t.uint32(),{limits:s.limits?.messages$}));break}case 3:{i.control=n.ControlMessage.codec().decode(t,t.uint32(),{limits:s.limits?.control});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Bn||(Bn={}));class d9{gossip;msgs=new Map;msgIdToStrFn;history=[];notValidatedCount=0;constructor(e,t,r){this.gossip=e,this.msgIdToStrFn=r;for(let s=0;s<t;s++)this.history[s]=[]}get size(){return this.msgs.size}put(e,t,r=!1){const{msgIdStr:s}=e;return this.msgs.has(s)?!1:(this.msgs.set(s,{message:t,validated:r,originatingPeers:new Set,iwantCounts:new Map}),this.history[0].push({...e,topic:t.topic}),r||this.notValidatedCount++,!0)}observeDuplicate(e,t){const r=this.msgs.get(e);r!=null&&!r.validated&&r.originatingPeers.add(t)}get(e){return this.msgs.get(this.msgIdToStrFn(e))?.message}getWithIWantCount(e,t){const r=this.msgs.get(e);if(r==null)return null;const s=(r.iwantCounts.get(t)??0)+1;return r.iwantCounts.set(t,s),{msg:r.message,count:s}}getGossipIDs(e){const t=new Map;for(let r=0;r<this.gossip;r++)this.history[r].forEach(s=>{if((this.msgs.get(s.msgIdStr)?.validated??!1)&&e.has(s.topic)){let o=t.get(s.topic);o==null&&(o=[],t.set(s.topic,o)),o.push(s.msgId)}});return t}validate(e){const t=this.msgs.get(e);if(t==null)return null;t.validated||this.notValidatedCount--;const{message:r,originatingPeers:s}=t;return t.validated=!0,t.originatingPeers=new Set,{message:r,originatingPeers:s}}shift(){this.history[this.history.length-1].forEach(t=>{const r=this.msgs.get(t.msgIdStr);r!=null&&(this.msgs.delete(t.msgIdStr),r.validated||this.notValidatedCount--)}),this.history.pop(),this.history.unshift([])}remove(e){const t=this.msgs.get(e);return t==null?null:(this.msgs.delete(e),t)}}var Kd;(function(n){n.StrictSign="StrictSign",n.StrictNoSign="StrictNoSign"})(Kd||(Kd={}));var Ls;(function(n){n[n.Signing=0]="Signing",n[n.Anonymous=1]="Anonymous"})(Ls||(Ls={}));var nr;(function(n){n.Error="error",n.Ignore="ignore",n.Reject="reject",n.Blacklisted="blacklisted"})(nr||(nr={}));var wt;(function(n){n.InvalidSignature="invalid_signature",n.InvalidSeqno="invalid_seqno",n.InvalidPeerId="invalid_peerid",n.SignaturePresent="signature_present",n.SeqnoPresent="seqno_present",n.FromPresent="from_present",n.TransformFailed="transform_failed"})(wt||(wt={}));var Et;(function(n){n.duplicate="duplicate",n.invalid="invalid",n.valid="valid"})(Et||(Et={}));function Wd(n){switch(n){case Vt.Ignore:return nr.Ignore;case Vt.Reject:return nr.Reject;default:throw new Error("Unreachable")}}var Gd;(function(n){n.forward="forward",n.publish="publish"})(Gd||(Gd={}));var _t;(function(n){n.Fanout="fanout",n.Random="random",n.Subscribed="subscribed",n.Outbound="outbound",n.NotEnough="not_enough",n.Opportunistic="opportunistic"})(_t||(_t={}));var yr;(function(n){n.Dc="disconnected",n.BadScore="bad_score",n.Prune="prune",n.Excess="excess"})(yr||(yr={}));var xi;(function(n){n.GraftBackoff="graft_backoff",n.BrokenPromise="broken_promise",n.MessageDeficit="message_deficit",n.IPColocation="IP_colocation"})(xi||(xi={}));var ki;(function(n){n.LowScore="low_score",n.MaxIhave="max_ihave",n.MaxIasked="max_iasked"})(ki||(ki={}));var ws;(function(n){n.graylist="graylist",n.publish="publish",n.gossip="gossip",n.mesh="mesh"})(ws||(ws={}));function f9(n,e,t){return{protocolsEnabled:n.gauge({name:"gossipsub_protocol",help:"Status of enabled protocols",labelNames:["protocol"]}),topicSubscriptionStatus:n.gauge({name:"gossipsub_topic_subscription_status",help:"Status of our subscription to this topic",labelNames:["topicStr"]}),topicPeersCount:n.gauge({name:"gossipsub_topic_peer_count",help:"Number of peers subscribed to each topic",labelNames:["topicStr"]}),meshPeerCounts:n.gauge({name:"gossipsub_mesh_peer_count",help:"Number of peers in our mesh",labelNames:["topicStr"]}),meshPeerInclusionEventsFanout:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_fanout_total",help:"Number of times we include peers in a topic mesh for fanout reasons",labelNames:["topic"]}),meshPeerInclusionEventsRandom:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_random_total",help:"Number of times we include peers in a topic mesh for random reasons",labelNames:["topic"]}),meshPeerInclusionEventsSubscribed:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_subscribed_total",help:"Number of times we include peers in a topic mesh for subscribed reasons",labelNames:["topic"]}),meshPeerInclusionEventsOutbound:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_outbound_total",help:"Number of times we include peers in a topic mesh for outbound reasons",labelNames:["topic"]}),meshPeerInclusionEventsNotEnough:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_not_enough_total",help:"Number of times we include peers in a topic mesh for not_enough reasons",labelNames:["topic"]}),meshPeerInclusionEventsOpportunistic:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_opportunistic_total",help:"Number of times we include peers in a topic mesh for opportunistic reasons",labelNames:["topic"]}),meshPeerInclusionEventsUnknown:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_unknown_total",help:"Number of times we include peers in a topic mesh for unknown reasons",labelNames:["topic"]}),meshPeerChurnEventsDisconnected:n.gauge({name:"gossipsub_peer_churn_events_disconnected_total",help:"Number of times we remove peers in a topic mesh for disconnected reasons",labelNames:["topic"]}),meshPeerChurnEventsBadScore:n.gauge({name:"gossipsub_peer_churn_events_bad_score_total",help:"Number of times we remove peers in a topic mesh for bad_score reasons",labelNames:["topic"]}),meshPeerChurnEventsPrune:n.gauge({name:"gossipsub_peer_churn_events_prune_total",help:"Number of times we remove peers in a topic mesh for prune reasons",labelNames:["topic"]}),meshPeerChurnEventsExcess:n.gauge({name:"gossipsub_peer_churn_events_excess_total",help:"Number of times we remove peers in a topic mesh for excess reasons",labelNames:["topic"]}),meshPeerChurnEventsUnknown:n.gauge({name:"gossipsub_peer_churn_events_unknown_total",help:"Number of times we remove peers in a topic mesh for unknown reasons",labelNames:["topic"]}),peersPerProtocol:n.gauge({name:"gossipsub_peers_per_protocol_count",help:"Peers connected for each topic",labelNames:["protocol"]}),heartbeatDuration:n.histogram({name:"gossipsub_heartbeat_duration_seconds",help:"The time it takes to complete one iteration of the heartbeat",buckets:[.01,.1,1]}),heartbeatSkipped:n.gauge({name:"gossipsub_heartbeat_skipped",help:"Heartbeat run took longer than heartbeat interval so next is skipped"}),acceptedMessagesTotal:n.gauge({name:"gossipsub_accepted_messages_total",help:"Total accepted messages for each topic",labelNames:["topic"]}),ignoredMessagesTotal:n.gauge({name:"gossipsub_ignored_messages_total",help:"Total ignored messages for each topic",labelNames:["topic"]}),rejectedMessagesTotal:n.gauge({name:"gossipsub_rejected_messages_total",help:"Total rejected messages for each topic",labelNames:["topic"]}),unknownValidationResultsTotal:n.gauge({name:"gossipsub_unknown_validation_results_total",help:"Total unknown validation results for each topic",labelNames:["topic"]}),asyncValidationMcacheHit:n.gauge({name:"gossipsub_async_validation_mcache_hit_total",help:"Async validation result reported by the user layer",labelNames:["hit"]}),asyncValidationDelayFromFirstSeenSec:n.histogram({name:"gossipsub_async_validation_delay_from_first_seen",help:"Async validation report delay from first seen in second",buckets:[.01,.03,.1,.3,1,3,10]}),asyncValidationUnknownFirstSeen:n.gauge({name:"gossipsub_async_validation_unknown_first_seen_count_total",help:"Async validation report unknown first seen value for message"}),peerReadStreamError:n.gauge({name:"gossipsub_peer_read_stream_err_count_total",help:"Peer read stream error"}),rpcRecvBytes:n.gauge({name:"gossipsub_rpc_recv_bytes_total",help:"RPC recv"}),rpcRecvCount:n.gauge({name:"gossipsub_rpc_recv_count_total",help:"RPC recv"}),rpcRecvSubscription:n.gauge({name:"gossipsub_rpc_recv_subscription_total",help:"RPC recv"}),rpcRecvMessage:n.gauge({name:"gossipsub_rpc_recv_message_total",help:"RPC recv"}),rpcRecvControl:n.gauge({name:"gossipsub_rpc_recv_control_total",help:"RPC recv"}),rpcRecvIHave:n.gauge({name:"gossipsub_rpc_recv_ihave_total",help:"RPC recv"}),rpcRecvIWant:n.gauge({name:"gossipsub_rpc_recv_iwant_total",help:"RPC recv"}),rpcRecvGraft:n.gauge({name:"gossipsub_rpc_recv_graft_total",help:"RPC recv"}),rpcRecvPrune:n.gauge({name:"gossipsub_rpc_recv_prune_total",help:"RPC recv"}),rpcDataError:n.gauge({name:"gossipsub_rpc_data_err_count_total",help:"RPC data error"}),rpcRecvError:n.gauge({name:"gossipsub_rpc_recv_err_count_total",help:"RPC recv error"}),rpcRecvNotAccepted:n.gauge({name:"gossipsub_rpc_rcv_not_accepted_total",help:"Total count of RPC dropped because acceptFrom() == false"}),rpcSentBytes:n.gauge({name:"gossipsub_rpc_sent_bytes_total",help:"RPC sent"}),rpcSentCount:n.gauge({name:"gossipsub_rpc_sent_count_total",help:"RPC sent"}),rpcSentSubscription:n.gauge({name:"gossipsub_rpc_sent_subscription_total",help:"RPC sent"}),rpcSentMessage:n.gauge({name:"gossipsub_rpc_sent_message_total",help:"RPC sent"}),rpcSentControl:n.gauge({name:"gossipsub_rpc_sent_control_total",help:"RPC sent"}),rpcSentIHave:n.gauge({name:"gossipsub_rpc_sent_ihave_total",help:"RPC sent"}),rpcSentIWant:n.gauge({name:"gossipsub_rpc_sent_iwant_total",help:"RPC sent"}),rpcSentGraft:n.gauge({name:"gossipsub_rpc_sent_graft_total",help:"RPC sent"}),rpcSentPrune:n.gauge({name:"gossipsub_rpc_sent_prune_total",help:"RPC sent"}),rpcSentIDontWant:n.gauge({name:"gossipsub_rpc_sent_idontwant_total",help:"RPC sent"}),msgPublishCount:n.gauge({name:"gossipsub_msg_publish_count_total",help:"Total count of msg published by topic",labelNames:["topic"]}),msgPublishPeersByTopic:n.gauge({name:"gossipsub_msg_publish_peers_total",help:"Total count of peers that we publish a msg to",labelNames:["topic"]}),directPeersPublishedTotal:n.gauge({name:"gossipsub_direct_peers_published_total",help:"Total direct peers that we publish a msg to",labelNames:["topic"]}),floodsubPeersPublishedTotal:n.gauge({name:"gossipsub_floodsub_peers_published_total",help:"Total floodsub peers that we publish a msg to",labelNames:["topic"]}),meshPeersPublishedTotal:n.gauge({name:"gossipsub_mesh_peers_published_total",help:"Total mesh peers that we publish a msg to",labelNames:["topic"]}),fanoutPeersPublishedTotal:n.gauge({name:"gossipsub_fanout_peers_published_total",help:"Total fanout peers that we publish a msg to",labelNames:["topic"]}),msgPublishBytes:n.gauge({name:"gossipsub_msg_publish_bytes_total",help:"Total count of msg publish data.length bytes",labelNames:["topic"]}),msgPublishTime:n.histogram({name:"gossipsub_msg_publish_seconds",help:"Total time in seconds to publish a message",buckets:[.001,.002,.005,.01,.1,.5,1],labelNames:["topic"]}),msgForwardCount:n.gauge({name:"gossipsub_msg_forward_count_total",help:"Total count of msg forwarded by topic",labelNames:["topic"]}),msgForwardPeers:n.gauge({name:"gossipsub_msg_forward_peers_total",help:"Total count of peers that we forward a msg to",labelNames:["topic"]}),msgReceivedPreValidation:n.gauge({name:"gossipsub_msg_received_prevalidation_total",help:"Total count of recv msgs before any validation",labelNames:["topic"]}),msgReceivedError:n.gauge({name:"gossipsub_msg_received_error_total",help:"Total count of recv msgs error",labelNames:["topic"]}),prevalidationInvalidTotal:n.gauge({name:"gossipsub_pre_validation_invalid_total",help:"Total count of invalid messages received",labelNames:["topic"]}),prevalidationValidTotal:n.gauge({name:"gossipsub_pre_validation_valid_total",help:"Total count of valid messages received",labelNames:["topic"]}),prevalidationDuplicateTotal:n.gauge({name:"gossipsub_pre_validation_duplicate_total",help:"Total count of duplicate messages received",labelNames:["topic"]}),prevalidationUnknownTotal:n.gauge({name:"gossipsub_pre_validation_unknown_status_total",help:"Total count of unknown_status messages received",labelNames:["topic"]}),msgReceivedInvalid:n.gauge({name:"gossipsub_msg_received_invalid_total",help:"Tracks specific reason of invalid",labelNames:["error"]}),msgReceivedInvalidByTopic:n.gauge({name:"gossipsub_msg_received_invalid_by_topic_total",help:"Tracks specific invalid message by topic",labelNames:["topic"]}),duplicateMsgDeliveryDelay:n.histogram({name:"gossisub_duplicate_msg_delivery_delay_seconds",help:"Time since the 1st duplicated message validated",labelNames:["topic"],buckets:[.25*t.maxMeshMessageDeliveriesWindowSec,.5*t.maxMeshMessageDeliveriesWindowSec,Number(t.maxMeshMessageDeliveriesWindowSec),2*t.maxMeshMessageDeliveriesWindowSec,4*t.maxMeshMessageDeliveriesWindowSec]}),duplicateMsgLateDelivery:n.gauge({name:"gossisub_duplicate_msg_late_delivery_total",help:"Total count of late duplicate message delivery by topic, which triggers P3 penalty",labelNames:["topic"]}),duplicateMsgIgnored:n.gauge({name:"gossisub_ignored_published_duplicate_msgs_total",help:"Total count of published duplicate message ignored by topic",labelNames:["topic"]}),scoreFnCalls:n.gauge({name:"gossipsub_score_fn_calls_total",help:"Total times score() is called"}),scoreFnRuns:n.gauge({name:"gossipsub_score_fn_runs_total",help:"Total times score() call actually computed computeScore(), no cache"}),scoreCachedDelta:n.histogram({name:"gossipsub_score_cache_delta",help:"Delta of score between cached values that expired",buckets:[10,100,1e3]}),peersByScoreThreshold:n.gauge({name:"gossipsub_peers_by_score_threshold_count",help:"Current count of peers by score threshold",labelNames:["threshold"]}),score:n.avgMinMax({name:"gossipsub_score",help:"Avg min max of gossip scores"}),scoreWeights:n.avgMinMax({name:"gossipsub_score_weights",help:"Separate score weights",labelNames:["topic","p"]}),scorePerMesh:n.avgMinMax({name:"gossipsub_score_per_mesh",help:"Histogram of the scores for each mesh topic",labelNames:["topic"]}),scoringPenalties:n.gauge({name:"gossipsub_scoring_penalties_total",help:"A counter of the kind of penalties being applied to peers",labelNames:["penalty"]}),behaviourPenalty:n.histogram({name:"gossipsub_peer_stat_behaviour_penalty",help:"Current peer stat behaviour_penalty at each scrape",buckets:[.25*t.behaviourPenaltyThreshold,.5*t.behaviourPenaltyThreshold,Number(t.behaviourPenaltyThreshold),2*t.behaviourPenaltyThreshold,4*t.behaviourPenaltyThreshold]}),ihaveRcvIgnored:n.gauge({name:"gossipsub_ihave_rcv_ignored_total",help:"Total received IHAVE messages that we ignore for some reason",labelNames:["reason"]}),ihaveRcvMsgids:n.gauge({name:"gossipsub_ihave_rcv_msgids_total",help:"Total received IHAVE messages by topic",labelNames:["topic"]}),ihaveRcvNotSeenMsgids:n.gauge({name:"gossipsub_ihave_rcv_not_seen_msgids_total",help:"Total messages per topic we do not have, not actual requests",labelNames:["topic"]}),iwantRcvMsgids:n.gauge({name:"gossipsub_iwant_rcv_msgids_total",help:"Total received IWANT messages by topic",labelNames:["topic"]}),iwantRcvDonthaveMsgids:n.gauge({name:"gossipsub_iwant_rcv_dont_have_msgids_total",help:"Total requested messageIDs that we do not have"}),idontwantRcvMsgids:n.gauge({name:"gossipsub_idontwant_rcv_msgids_total",help:"Total received IDONTWANT messages"}),idontwantRcvDonthaveMsgids:n.gauge({name:"gossipsub_idontwant_rcv_dont_have_msgids_total",help:"Total received IDONTWANT messageIDs that we do not have in mcache"}),iwantPromiseStarted:n.gauge({name:"gossipsub_iwant_promise_sent_total",help:"Total count of started IWANT promises"}),iwantPromiseResolved:n.gauge({name:"gossipsub_iwant_promise_resolved_total",help:"Total count of resolved IWANT promises"}),iwantPromiseResolvedFromDuplicate:n.gauge({name:"gossipsub_iwant_promise_resolved_from_duplicate_total",help:"Total count of resolved IWANT promises from duplicate messages"}),iwantPromiseResolvedPeers:n.gauge({name:"gossipsub_iwant_promise_resolved_peers",help:"Total count of peers we have asked IWANT promises that are resolved"}),iwantPromiseBroken:n.gauge({name:"gossipsub_iwant_promise_broken",help:"Total count of broken IWANT promises"}),iwantMessagePruned:n.gauge({name:"gossipsub_iwant_message_pruned",help:"Total count of pruned IWANT messages"}),iwantPromiseDeliveryTime:n.histogram({name:"gossipsub_iwant_promise_delivery_seconds",help:"Histogram of delivery time of resolved IWANT promises",buckets:[.5*t.gossipPromiseExpireSec,Number(t.gossipPromiseExpireSec),2*t.gossipPromiseExpireSec,4*t.gossipPromiseExpireSec]}),iwantPromiseUntracked:n.gauge({name:"gossip_iwant_promise_untracked",help:"Total count of untracked IWANT promise"}),connectedPeersBackoffSec:n.histogram({name:"gossipsub_connected_peers_backoff_seconds",help:"Backoff time in seconds",buckets:[1,2,4,10,20,60,120]}),cacheSize:n.gauge({name:"gossipsub_cache_size",help:"Unbounded cache sizes",labelNames:["cache"]}),mcacheSize:n.gauge({name:"gossipsub_mcache_size",help:"Current mcache msg count"}),mcacheNotValidatedCount:n.gauge({name:"gossipsub_mcache_not_validated_count",help:"Current mcache msg count not validated"}),fastMsgIdCacheCollision:n.gauge({name:"gossipsub_fastmsgid_cache_collision_total",help:"Total count of key collisions on fastmsgid cache put"}),newConnectionCount:n.gauge({name:"gossipsub_new_connection_total",help:"Total new connection by status",labelNames:["status"]}),topicStrToLabel:e,toTopic(r){return this.topicStrToLabel.get(r)??r},onJoin(r){this.topicSubscriptionStatus.set({topicStr:r},1),this.meshPeerCounts.set({topicStr:r},0)},onLeave(r){this.topicSubscriptionStatus.set({topicStr:r},0),this.meshPeerCounts.set({topicStr:r},0)},onAddToMesh(r,s,i){const o=this.toTopic(r);switch(s){case _t.Fanout:this.meshPeerInclusionEventsFanout.inc({topic:o},i);break;case _t.Random:this.meshPeerInclusionEventsRandom.inc({topic:o},i);break;case _t.Subscribed:this.meshPeerInclusionEventsSubscribed.inc({topic:o},i);break;case _t.Outbound:this.meshPeerInclusionEventsOutbound.inc({topic:o},i);break;case _t.NotEnough:this.meshPeerInclusionEventsNotEnough.inc({topic:o},i);break;case _t.Opportunistic:this.meshPeerInclusionEventsOpportunistic.inc({topic:o},i);break;default:this.meshPeerInclusionEventsUnknown.inc({topic:o},i);break}},onRemoveFromMesh(r,s,i){const o=this.toTopic(r);switch(s){case yr.Dc:this.meshPeerChurnEventsDisconnected.inc({topic:o},i);break;case yr.BadScore:this.meshPeerChurnEventsBadScore.inc({topic:o},i);break;case yr.Prune:this.meshPeerChurnEventsPrune.inc({topic:o},i);break;case yr.Excess:this.meshPeerChurnEventsExcess.inc({topic:o},i);break;default:this.meshPeerChurnEventsUnknown.inc({topic:o},i);break}},onReportValidation(r,s,i){if(this.asyncValidationMcacheHit.inc({hit:r!=null?"hit":"miss"}),r!=null){const o=this.toTopic(r.message.topic);switch(s){case Vt.Accept:this.acceptedMessagesTotal.inc({topic:o});break;case Vt.Ignore:this.ignoredMessagesTotal.inc({topic:o});break;case Vt.Reject:this.rejectedMessagesTotal.inc({topic:o});break;default:this.unknownValidationResultsTotal.inc({topic:o});break}}i!=null?this.asyncValidationDelayFromFirstSeenSec.observe((Date.now()-i)/1e3):this.asyncValidationUnknownFirstSeen.inc()},onScorePenalty(r){this.scoringPenalties.inc({penalty:r},1)},onIhaveRcv(r,s,i){const o=this.toTopic(r);this.ihaveRcvMsgids.inc({topic:o},s),this.ihaveRcvNotSeenMsgids.inc({topic:o},i)},onIwantRcv(r,s){for(const[i,o]of r){const a=this.toTopic(i);this.iwantRcvMsgids.inc({topic:a},o)}this.iwantRcvDonthaveMsgids.inc(s)},onIdontwantRcv(r,s){this.idontwantRcvMsgids.inc(r),this.idontwantRcvDonthaveMsgids.inc(s)},onForwardMsg(r,s){const i=this.toTopic(r);this.msgForwardCount.inc({topic:i},1),this.msgForwardPeers.inc({topic:i},s)},onPublishMsg(r,s,i,o,a){const c=this.toTopic(r);this.msgPublishCount.inc({topic:c},1),this.msgPublishBytes.inc({topic:c},i*o),this.msgPublishPeersByTopic.inc({topic:c},i),this.directPeersPublishedTotal.inc({topic:c},s.direct),this.floodsubPeersPublishedTotal.inc({topic:c},s.floodsub),this.meshPeersPublishedTotal.inc({topic:c},s.mesh),this.fanoutPeersPublishedTotal.inc({topic:c},s.fanout),this.msgPublishTime.observe({topic:c},a/1e3)},onMsgRecvPreValidation(r){const s=this.toTopic(r);this.msgReceivedPreValidation.inc({topic:s},1)},onMsgRecvError(r){const s=this.toTopic(r);this.msgReceivedError.inc({topic:s},1)},onPrevalidationResult(r,s){const i=this.toTopic(r);switch(s){case Et.duplicate:this.prevalidationDuplicateTotal.inc({topic:i});break;case Et.invalid:this.prevalidationInvalidTotal.inc({topic:i});break;case Et.valid:this.prevalidationValidTotal.inc({topic:i});break;default:this.prevalidationUnknownTotal.inc({topic:i});break}},onMsgRecvInvalid(r,s){const i=this.toTopic(r),o=s.reason===nr.Error?s.error:s.reason;this.msgReceivedInvalid.inc({error:o},1),this.msgReceivedInvalidByTopic.inc({topic:i},1)},onDuplicateMsgDelivery(r,s,i){const o=this.toTopic(r);this.duplicateMsgDeliveryDelay.observe({topic:o},s/1e3),i&&this.duplicateMsgLateDelivery.inc({topic:o},1)},onPublishDuplicateMsg(r){const s=this.toTopic(r);this.duplicateMsgIgnored.inc({topic:s},1)},onPeerReadStreamError(){this.peerReadStreamError.inc(1)},onRpcRecvError(){this.rpcRecvError.inc(1)},onRpcDataError(){this.rpcDataError.inc(1)},onRpcRecv(r,s){this.rpcRecvBytes.inc(s),this.rpcRecvCount.inc(1),r.subscriptions!=null&&this.rpcRecvSubscription.inc(r.subscriptions.length),r.messages!=null&&this.rpcRecvMessage.inc(r.messages.length),r.control!=null&&(this.rpcRecvControl.inc(1),r.control.ihave!=null&&this.rpcRecvIHave.inc(r.control.ihave.length),r.control.iwant!=null&&this.rpcRecvIWant.inc(r.control.iwant.length),r.control.graft!=null&&this.rpcRecvGraft.inc(r.control.graft.length),r.control.prune!=null&&this.rpcRecvPrune.inc(r.control.prune.length))},onRpcSent(r,s){if(this.rpcSentBytes.inc(s),this.rpcSentCount.inc(1),r.subscriptions!=null&&this.rpcSentSubscription.inc(r.subscriptions.length),r.messages!=null&&this.rpcSentMessage.inc(r.messages.length),r.control!=null){const i=r.control.ihave?.length??0,o=r.control.iwant?.length??0,a=r.control.graft?.length??0,c=r.control.prune?.length??0,l=r.control.idontwant?.length??0;i>0&&this.rpcSentIHave.inc(i),o>0&&this.rpcSentIWant.inc(o),a>0&&this.rpcSentGraft.inc(a),c>0&&this.rpcSentPrune.inc(c),l>0&&this.rpcSentIDontWant.inc(l),(i>0||o>0||a>0||c>0||l>0)&&this.rpcSentControl.inc(1)}},registerScores(r,s){let i=0,o=0,a=0,c=0;for(const l of r)l>=s.graylistThreshold&&i++,l>=s.publishThreshold&&o++,l>=s.gossipThreshold&&a++,l>=0&&c++;this.peersByScoreThreshold.set({threshold:ws.graylist},i),this.peersByScoreThreshold.set({threshold:ws.publish},o),this.peersByScoreThreshold.set({threshold:ws.gossip},a),this.peersByScoreThreshold.set({threshold:ws.mesh},c),this.score.set(r)},registerScoreWeights(r){for(const[s,i]of r.byTopic)this.scoreWeights.set({topic:s,p:"p1"},i.p1w),this.scoreWeights.set({topic:s,p:"p2"},i.p2w),this.scoreWeights.set({topic:s,p:"p3"},i.p3w),this.scoreWeights.set({topic:s,p:"p3b"},i.p3bw),this.scoreWeights.set({topic:s,p:"p4"},i.p4w);this.scoreWeights.set({p:"p5"},r.p5w),this.scoreWeights.set({p:"p6"},r.p6w),this.scoreWeights.set({p:"p7"},r.p7w)},registerScorePerMesh(r,s){const i=new Map;r.forEach((o,a)=>{const c=this.topicStrToLabel.get(a)??"unknown";let l=i.get(c);l==null&&(l=new Set,i.set(c,l)),o.forEach(u=>l?.add(u))});for(const[o,a]of i){const c=[];a.forEach(l=>{c.push(s.get(l)??0)}),this.scorePerMesh.set({topic:o},c)}}}}class ve extends Error{static name="InvalidPeerScoreParamsError";constructor(e="Invalid peer score params"){super(e),this.name="InvalidPeerScoreParamsError"}}const p9={topics:{},topicScoreCap:10,appSpecificScore:()=>0,appSpecificWeight:10,IPColocationFactorWeight:-5,IPColocationFactorThreshold:10,IPColocationFactorWhitelist:new Set,behaviourPenaltyWeight:-10,behaviourPenaltyThreshold:0,behaviourPenaltyDecay:.2,decayInterval:1e3,decayToZero:.1,retainScore:3600*1e3},g9={topicWeight:.5,timeInMeshWeight:1,timeInMeshQuantum:1,timeInMeshCap:3600,firstMessageDeliveriesWeight:1,firstMessageDeliveriesDecay:.5,firstMessageDeliveriesCap:2e3,meshMessageDeliveriesWeight:-1,meshMessageDeliveriesDecay:.5,meshMessageDeliveriesCap:100,meshMessageDeliveriesThreshold:20,meshMessageDeliveriesWindow:10,meshMessageDeliveriesActivation:5e3,meshFailurePenaltyWeight:-1,meshFailurePenaltyDecay:.5,invalidMessageDeliveriesWeight:-1,invalidMessageDeliveriesDecay:.3};function m9(n={}){return{...p9,...n,topics:n.topics!=null?Object.entries(n.topics).reduce((e,[t,r])=>(e[t]=y9(r),e),{}):{}}}function y9(n={}){return{...g9,...n}}function w9(n){for(const[e,t]of Object.entries(n.topics))try{b9(t)}catch(r){throw new ve(`invalid score parameters for topic ${e}: ${r.message}`)}if(n.topicScoreCap<0)throw new ve("invalid topic score cap; must be positive (or 0 for no cap)");if(n.appSpecificScore===null||n.appSpecificScore===void 0)throw new ve("missing application specific score function");if(n.IPColocationFactorWeight>0)throw new ve("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");if(n.IPColocationFactorWeight!==0&&n.IPColocationFactorThreshold<1)throw new ve("invalid IPColocationFactorThreshold; must be at least 1");if(n.behaviourPenaltyWeight>0)throw new ve("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");if(n.behaviourPenaltyWeight!==0&&(n.behaviourPenaltyDecay<=0||n.behaviourPenaltyDecay>=1))throw new ve("invalid BehaviourPenaltyDecay; must be between 0 and 1");if(n.decayInterval<1e3)throw new ve("invalid DecayInterval; must be at least 1s");if(n.decayToZero<=0||n.decayToZero>=1)throw new ve("invalid DecayToZero; must be between 0 and 1")}function b9(n){if(n.topicWeight<0)throw new ve("invalid topic weight; must be >= 0");if(n.timeInMeshQuantum===0)throw new ve("invalid TimeInMeshQuantum; must be non zero");if(n.timeInMeshWeight<0)throw new ve("invalid TimeInMeshWeight; must be positive (or 0 to disable)");if(n.timeInMeshWeight!==0&&n.timeInMeshQuantum<=0)throw new ve("invalid TimeInMeshQuantum; must be positive");if(n.timeInMeshWeight!==0&&n.timeInMeshCap<=0)throw new ve("invalid TimeInMeshCap; must be positive");if(n.firstMessageDeliveriesWeight<0)throw new ve("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");if(n.firstMessageDeliveriesWeight!==0&&(n.firstMessageDeliveriesDecay<=0||n.firstMessageDeliveriesDecay>=1))throw new ve("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");if(n.firstMessageDeliveriesWeight!==0&&n.firstMessageDeliveriesCap<=0)throw new ve("invalid FirstMessageDeliveriesCap; must be positive");if(n.meshMessageDeliveriesWeight>0)throw new ve("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");if(n.meshMessageDeliveriesWeight!==0&&(n.meshMessageDeliveriesDecay<=0||n.meshMessageDeliveriesDecay>=1))throw new ve("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesCap<=0)throw new ve("invalid MeshMessageDeliveriesCap; must be positive");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesThreshold<=0)throw new ve("invalid MeshMessageDeliveriesThreshold; must be positive");if(n.meshMessageDeliveriesWindow<0)throw new ve("invalid MeshMessageDeliveriesWindow; must be non-negative");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesActivation<1e3)throw new ve("invalid MeshMessageDeliveriesActivation; must be at least 1s");if(n.meshFailurePenaltyWeight>0)throw new ve("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");if(n.meshFailurePenaltyWeight!==0&&(n.meshFailurePenaltyDecay<=0||n.meshFailurePenaltyDecay>=1))throw new ve("invalid MeshFailurePenaltyDecay; must be between 0 and 1");if(n.invalidMessageDeliveriesWeight>0)throw new ve("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");if(n.invalidMessageDeliveriesDecay<=0||n.invalidMessageDeliveriesDecay>=1)throw new ve("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1")}const v9={gossipThreshold:-10,publishThreshold:-50,graylistThreshold:-80,acceptPXThreshold:10,opportunisticGraftThreshold:20};function E9(n={}){return{...v9,...n}}function jl(n,e,t=()=>!0){const r=new Set;if(e<=0)return r;for(const s of n){if(r.size>=e)break;t(s)&&(r.add(s),n.delete(s))}return r}function S9(n,e){return jl(n,e,()=>!0)}class _9 extends Map{getDefault;constructor(e){super(),this.getDefault=e}getOrDefault(e){let t=super.get(e);return t===void 0&&(t=this.getDefault(),this.set(e,t)),t}}function x9(n,e,t,r){let s=0;Object.entries(e.topics).forEach(([o,a])=>{const c=t.topics[o];if(c===void 0)return;let l=0;if(a.inMesh){let f=a.meshTime/c.timeInMeshQuantum;f>c.timeInMeshCap&&(f=c.timeInMeshCap),l+=f*c.timeInMeshWeight}let u=a.firstMessageDeliveries;if(u>c.firstMessageDeliveriesCap&&(u=c.firstMessageDeliveriesCap),l+=u*c.firstMessageDeliveriesWeight,a.meshMessageDeliveriesActive&&a.meshMessageDeliveries<c.meshMessageDeliveriesThreshold){const f=c.meshMessageDeliveriesThreshold-a.meshMessageDeliveries,p=f*f;l+=p*c.meshMessageDeliveriesWeight}const h=a.meshFailurePenalty;l+=h*c.meshFailurePenaltyWeight;const d=a.invalidMessageDeliveries*a.invalidMessageDeliveries;l+=d*c.invalidMessageDeliveriesWeight,s+=l*c.topicWeight}),t.topicScoreCap>0&&s>t.topicScoreCap&&(s=t.topicScoreCap);const i=t.appSpecificScore(n);if(s+=i*t.appSpecificWeight,e.knownIPs.forEach(o=>{if(t.IPColocationFactorWhitelist.has(o))return;const a=r.get(o),c=a!=null?a.size:0;if(c>t.IPColocationFactorThreshold){const l=c-t.IPColocationFactorThreshold,u=l*l;s+=u*t.IPColocationFactorWeight}}),e.behaviourPenalty>t.behaviourPenaltyThreshold){const o=e.behaviourPenalty-t.behaviourPenaltyThreshold,a=o*o;s+=a*t.behaviourPenaltyWeight}return s}function rs(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Kc,Qd;function k9(){if(Qd)return Kc;Qd=1;function n(e,r){var r=r||{};this._capacity=r.capacity,this._head=0,this._tail=0,Array.isArray(e)?this._fromArray(e):(this._capacityMask=3,this._list=new Array(4))}return n.prototype.peekAt=function(t){var r=t;if(r===(r|0)){var s=this.size();if(!(r>=s||r<-s))return r<0&&(r+=s),r=this._head+r&this._capacityMask,this._list[r]}},n.prototype.get=function(t){return this.peekAt(t)},n.prototype.peek=function(){if(this._head!==this._tail)return this._list[this._head]},n.prototype.peekFront=function(){return this.peek()},n.prototype.peekBack=function(){return this.peekAt(-1)},Object.defineProperty(n.prototype,"length",{get:function(){return this.size()}}),n.prototype.size=function(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.unshift=function(t){if(arguments.length===0)return this.size();var r=this._list.length;return this._head=this._head-1+r&this._capacityMask,this._list[this._head]=t,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.shift=function(){var t=this._head;if(t!==this._tail){var r=this._list[t];return this._list[t]=void 0,this._head=t+1&this._capacityMask,t<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),r}},n.prototype.push=function(t){if(arguments.length===0)return this.size();var r=this._tail;return this._list[r]=t,this._tail=r+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.pop=function(){var t=this._tail;if(t!==this._head){var r=this._list.length;this._tail=t-1+r&this._capacityMask;var s=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&t>1e4&&t<=r>>>2&&this._shrinkArray(),s}},n.prototype.removeOne=function(t){var r=t;if(r===(r|0)&&this._head!==this._tail){var s=this.size(),i=this._list.length;if(!(r>=s||r<-s)){r<0&&(r+=s),r=this._head+r&this._capacityMask;var o=this._list[r],a;if(t<s/2){for(a=t;a>0;a--)this._list[r]=this._list[r=r-1+i&this._capacityMask];this._list[r]=void 0,this._head=this._head+1+i&this._capacityMask}else{for(a=s-1-t;a>0;a--)this._list[r]=this._list[r=r+1+i&this._capacityMask];this._list[r]=void 0,this._tail=this._tail-1+i&this._capacityMask}return o}}},n.prototype.remove=function(t,r){var s=t,i,o=r;if(s===(s|0)&&this._head!==this._tail){var a=this.size(),c=this._list.length;if(!(s>=a||s<-a||r<1)){if(s<0&&(s+=a),r===1||!r)return i=new Array(1),i[0]=this.removeOne(s),i;if(s===0&&s+r>=a)return i=this.toArray(),this.clear(),i;s+r>a&&(r=a-s);var l;for(i=new Array(r),l=0;l<r;l++)i[l]=this._list[this._head+s+l&this._capacityMask];if(s=this._head+s&this._capacityMask,t+r===a){for(this._tail=this._tail-r+c&this._capacityMask,l=r;l>0;l--)this._list[s=s+1+c&this._capacityMask]=void 0;return i}if(t===0){for(this._head=this._head+r+c&this._capacityMask,l=r-1;l>0;l--)this._list[s=s+1+c&this._capacityMask]=void 0;return i}if(s<a/2){for(this._head=this._head+t+r+c&this._capacityMask,l=t;l>0;l--)this.unshift(this._list[s=s-1+c&this._capacityMask]);for(s=this._head-1+c&this._capacityMask;o>0;)this._list[s=s-1+c&this._capacityMask]=void 0,o--;t<0&&(this._tail=s)}else{for(this._tail=s,s=s+r+c&this._capacityMask,l=a-(r+t);l>0;l--)this.push(this._list[s++]);for(s=this._tail;o>0;)this._list[s=s+1+c&this._capacityMask]=void 0,o--}return this._head<2&&this._tail>1e4&&this._tail<=c>>>2&&this._shrinkArray(),i}}},n.prototype.splice=function(t,r){var s=t;if(s===(s|0)){var i=this.size();if(s<0&&(s+=i),!(s>i))if(arguments.length>2){var o,a,c,l=arguments.length,u=this._list.length,h=2;if(!i||s<i/2){for(a=new Array(s),o=0;o<s;o++)a[o]=this._list[this._head+o&this._capacityMask];for(r===0?(c=[],s>0&&(this._head=this._head+s+u&this._capacityMask)):(c=this.remove(s,r),this._head=this._head+s+u&this._capacityMask);l>h;)this.unshift(arguments[--l]);for(o=s;o>0;o--)this.unshift(a[o-1])}else{a=new Array(i-(s+r));var d=a.length;for(o=0;o<d;o++)a[o]=this._list[this._head+s+r+o&this._capacityMask];for(r===0?(c=[],s!=i&&(this._tail=this._head+s+u&this._capacityMask)):(c=this.remove(s,r),this._tail=this._tail-d+u&this._capacityMask);h<l;)this.push(arguments[h++]);for(o=0;o<d;o++)this.push(a[o])}return c}else return this.remove(s,r)}},n.prototype.clear=function(){this._list=new Array(this._list.length),this._head=0,this._tail=0},n.prototype.isEmpty=function(){return this._head===this._tail},n.prototype.toArray=function(){return this._copyArray(!1)},n.prototype._fromArray=function(t){var r=t.length,s=this._nextPowerOf2(r);this._list=new Array(s),this._capacityMask=s-1,this._tail=r;for(var i=0;i<r;i++)this._list[i]=t[i]},n.prototype._copyArray=function(t,r){var s=this._list,i=s.length,o=this.length;if(r=r|o,r==o&&this._head<this._tail)return this._list.slice(this._head,this._tail);var a=new Array(r),c=0,l;if(t||this._head>this._tail){for(l=this._head;l<i;l++)a[c++]=s[l];for(l=0;l<this._tail;l++)a[c++]=s[l]}else for(l=this._head;l<this._tail;l++)a[c++]=s[l];return a},n.prototype._growArray=function(){if(this._head!=0){var t=this._copyArray(!0,this._list.length<<1);this._tail=this._list.length,this._head=0,this._list=t}else this._tail=this._list.length,this._list.length<<=1;this._capacityMask=this._capacityMask<<1|1},n.prototype._shrinkArray=function(){this._list.length>>>=1,this._capacityMask>>>=1},n.prototype._nextPowerOf2=function(t){var r=Math.log(t)/Math.log(2),s=1<<r+1;return Math.max(s,4)},Kc=n,Kc}var I9=k9();const A9=rs(I9);var bt;(function(n){n[n.unknown=0]="unknown",n[n.valid=1]="valid",n[n.invalid=2]="invalid",n[n.ignored=3]="ignored"})(bt||(bt={}));class T9{records;queue;constructor(){this.records=new Map,this.queue=new A9}getRecord(e){return this.records.get(e)}ensureRecord(e){let t=this.records.get(e);if(t!=null)return t;t={status:bt.unknown,firstSeenTsMs:Date.now(),validated:0,peers:new Set},this.records.set(e,t);const r={msgId:e,expire:Date.now()+t9};return this.queue.push(r),t}gc(){const e=Date.now();let t=this.queue.peekFront();for(;t!=null&&t.expire<e;)this.records.delete(t.msgId),this.queue.shift(),t=this.queue.peekFront()}clear(){this.records.clear(),this.queue.clear()}}class P9{params;metrics;peerStats=new Map;peerIPs=new _9(()=>new Set);scoreCache=new Map;deliveryRecords=new T9;_backgroundInterval;scoreCacheValidityMs;computeScore;log;constructor(e,t,r,s){this.params=e,this.metrics=t,w9(e),this.scoreCacheValidityMs=s.scoreCacheValidityMs,this.computeScore=s.computeScore??x9,this.log=r.forComponent("libp2p:gossipsub:score")}get size(){return this.peerStats.size}start(){if(this._backgroundInterval!=null){this.log("Peer score already running");return}this._backgroundInterval=setInterval(()=>{this.background()},this.params.decayInterval),this.log("started")}stop(){if(this._backgroundInterval==null){this.log("Peer score already stopped");return}clearInterval(this._backgroundInterval),delete this._backgroundInterval,this.peerIPs.clear(),this.peerStats.clear(),this.deliveryRecords.clear(),this.log("stopped")}background(){this.refreshScores(),this.deliveryRecords.gc()}dumpPeerScoreStats(){return Object.fromEntries(Array.from(this.peerStats.entries()).map(([e,t])=>[e,t]))}messageFirstSeenTimestampMs(e){const t=this.deliveryRecords.getRecord(e);return t!=null?t.firstSeenTsMs:null}refreshScores(){const e=Date.now(),t=this.params.decayToZero;this.peerStats.forEach((r,s)=>{if(!r.connected){e>r.expire&&(this.removeIPsForPeer(s,r.knownIPs),this.peerStats.delete(s),this.scoreCache.delete(s));return}Object.entries(r.topics).forEach(([i,o])=>{const a=this.params.topics[i];a!==void 0&&(o.firstMessageDeliveries*=a.firstMessageDeliveriesDecay,o.firstMessageDeliveries<t&&(o.firstMessageDeliveries=0),o.meshMessageDeliveries*=a.meshMessageDeliveriesDecay,o.meshMessageDeliveries<t&&(o.meshMessageDeliveries=0),o.meshFailurePenalty*=a.meshFailurePenaltyDecay,o.meshFailurePenalty<t&&(o.meshFailurePenalty=0),o.invalidMessageDeliveries*=a.invalidMessageDeliveriesDecay,o.invalidMessageDeliveries<t&&(o.invalidMessageDeliveries=0),o.inMesh&&(o.meshTime=e-o.graftTime,o.meshTime>a.meshMessageDeliveriesActivation&&(o.meshMessageDeliveriesActive=!0)))}),r.behaviourPenalty*=this.params.behaviourPenaltyDecay,r.behaviourPenalty<t&&(r.behaviourPenalty=0)})}score(e){this.metrics?.scoreFnCalls.inc();const t=this.peerStats.get(e);if(t==null)return 0;const r=Date.now(),s=this.scoreCache.get(e);if(s!=null&&s.cacheUntil>r)return s.score;this.metrics?.scoreFnRuns.inc();const i=this.computeScore(e,t,this.params,this.peerIPs),o=r+this.scoreCacheValidityMs;return s!=null?(this.metrics?.scoreCachedDelta.observe(Math.abs(i-s.score)),s.score=i,s.cacheUntil=o):this.scoreCache.set(e,{score:i,cacheUntil:o}),i}addPenalty(e,t,r){const s=this.peerStats.get(e);s!=null&&(s.behaviourPenalty+=t,this.metrics?.onScorePenalty(r))}addPeer(e){const t={connected:!0,expire:0,topics:{},knownIPs:new Set,behaviourPenalty:0};this.peerStats.set(e,t)}addIP(e,t){const r=this.peerStats.get(e);r?.knownIPs.add(t),this.peerIPs.getOrDefault(t).add(e)}removeIP(e,t){const r=this.peerStats.get(e);r?.knownIPs.delete(t);const s=this.peerIPs.get(t);s!=null&&(s.delete(e),s.size===0&&this.peerIPs.delete(t))}removePeer(e){const t=this.peerStats.get(e);if(t!=null){if(this.score(e)>0){this.removeIPsForPeer(e,t.knownIPs),this.peerStats.delete(e);return}Object.entries(t.topics).forEach(([r,s])=>{s.firstMessageDeliveries=0;const i=this.params.topics[r].meshMessageDeliveriesThreshold;if(s.inMesh&&s.meshMessageDeliveriesActive&&s.meshMessageDeliveries<i){const o=i-s.meshMessageDeliveries;s.meshFailurePenalty+=o*o}s.inMesh=!1,s.meshMessageDeliveriesActive=!1}),t.connected=!1,t.expire=Date.now()+this.params.retainScore}}graft(e,t){const r=this.peerStats.get(e);if(r!=null){const s=this.getPtopicStats(r,t);s!=null&&(s.inMesh=!0,s.graftTime=Date.now(),s.meshTime=0,s.meshMessageDeliveriesActive=!1)}}prune(e,t){const r=this.peerStats.get(e);if(r!=null){const s=this.getPtopicStats(r,t);if(s!=null){const i=this.params.topics[t].meshMessageDeliveriesThreshold;if(s.meshMessageDeliveriesActive&&s.meshMessageDeliveries<i){const o=i-s.meshMessageDeliveries;s.meshFailurePenalty+=o*o}s.meshMessageDeliveriesActive=!1,s.inMesh=!1}}}validateMessage(e){this.deliveryRecords.ensureRecord(e)}deliverMessage(e,t,r){this.markFirstMessageDelivery(e,r);const s=this.deliveryRecords.ensureRecord(t),i=Date.now();if(s.status!==bt.unknown){this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s",e,i-s.firstSeenTsMs,bt[s.status]);return}s.status=bt.valid,s.validated=i,s.peers.forEach(o=>{o!==e.toString()&&this.markDuplicateMessageDelivery(o,r)})}rejectInvalidMessage(e,t){this.markInvalidMessageDelivery(e,t)}rejectMessage(e,t,r,s){switch(s){case nr.Error:this.markInvalidMessageDelivery(e,r);return;case nr.Blacklisted:return}const i=this.deliveryRecords.ensureRecord(t);if(i.status!==bt.unknown){this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d",e,Date.now()-i.firstSeenTsMs,bt[i.status]);return}if(s===nr.Ignore){i.status=bt.ignored,i.peers.clear();return}i.status=bt.invalid,this.markInvalidMessageDelivery(e,r),i.peers.forEach(o=>{this.markInvalidMessageDelivery(o,r)}),i.peers.clear()}duplicateMessage(e,t,r){const s=this.deliveryRecords.ensureRecord(t);if(!s.peers.has(e))switch(s.status){case bt.unknown:s.peers.add(e);break;case bt.valid:s.peers.add(e),this.markDuplicateMessageDelivery(e,r,s.validated);break;case bt.invalid:this.markInvalidMessageDelivery(e,r);break;case bt.ignored:break}}markInvalidMessageDelivery(e,t){const r=this.peerStats.get(e);if(r!=null){const s=this.getPtopicStats(r,t);s!=null&&(s.invalidMessageDeliveries+=1)}}markFirstMessageDelivery(e,t){const r=this.peerStats.get(e);if(r!=null){const s=this.getPtopicStats(r,t);if(s!=null){let i=this.params.topics[t].firstMessageDeliveriesCap;s.firstMessageDeliveries=Math.min(i,s.firstMessageDeliveries+1),s.inMesh&&(i=this.params.topics[t].meshMessageDeliveriesCap,s.meshMessageDeliveries=Math.min(i,s.meshMessageDeliveries+1))}}}markDuplicateMessageDelivery(e,t,r){const s=this.peerStats.get(e);if(s!=null){const i=r!==void 0?Date.now():0,o=this.getPtopicStats(s,t);if(o!=null&&o.inMesh){const a=this.params.topics[t];if(r!==void 0){const l=i-r,u=l>a.meshMessageDeliveriesWindow;if(this.metrics?.onDuplicateMsgDelivery(t,l,u),u)return}const c=a.meshMessageDeliveriesCap;o.meshMessageDeliveries=Math.min(c,o.meshMessageDeliveries+1)}}}removeIPsForPeer(e,t){for(const r of t){const s=this.peerIPs.get(r);s!=null&&(s.delete(e),s.size===0&&this.peerIPs.delete(r))}}getPtopicStats(e,t){let r=e.topics[t];return r!==void 0?r:this.params.topics[t]!==void 0?(r={inMesh:!1,graftTime:0,meshTime:0,firstMessageDeliveries:0,meshMessageDeliveries:0,meshMessageDeliveriesActive:!1,meshFailurePenalty:0,invalidMessageDeliveries:0},e.topics[t]=r,r):null}}function C9(n,e,t,r,s){let i=0;const o=new Map;if(Object.entries(e.topics).forEach(([d,f])=>{const p=s.get(d)??"unknown",m=t.topics[d];if(m===void 0)return;let g=o.get(p);g==null&&(g={p1w:0,p2w:0,p3w:0,p3bw:0,p4w:0},o.set(p,g));let y=0,b=0,w=0,k=0,_=0;if(f.inMesh){const v=Math.max(f.meshTime/m.timeInMeshQuantum,m.timeInMeshCap);y+=v*m.timeInMeshWeight}let A=f.firstMessageDeliveries;if(A>m.firstMessageDeliveriesCap&&(A=m.firstMessageDeliveriesCap),b+=A*m.firstMessageDeliveriesWeight,f.meshMessageDeliveriesActive&&f.meshMessageDeliveries<m.meshMessageDeliveriesThreshold){const v=m.meshMessageDeliveriesThreshold-f.meshMessageDeliveries,M=v*v;w+=M*m.meshMessageDeliveriesWeight}const I=f.meshFailurePenalty;k+=I*m.meshFailurePenaltyWeight;const D=f.invalidMessageDeliveries*f.invalidMessageDeliveries;_+=D*m.invalidMessageDeliveriesWeight,i+=(y+b+w+k+_)*m.topicWeight,g.p1w+=y,g.p2w+=b,g.p3w+=w,g.p3bw+=k,g.p4w+=_}),t.topicScoreCap>0&&i>t.topicScoreCap){i=t.topicScoreCap;const d=t.topicScoreCap/i;for(const f of o.values())f.p1w*=d,f.p2w*=d,f.p3w*=d,f.p3bw*=d,f.p4w*=d}let a=0,c=0,l=0;const u=t.appSpecificScore(n);a+=u*t.appSpecificWeight,e.knownIPs.forEach(d=>{if(t.IPColocationFactorWhitelist.has(d))return;const f=r.get(d),p=f!=null?f.size:0;if(p>t.IPColocationFactorThreshold){const m=p-t.IPColocationFactorThreshold,g=m*m;c+=g*t.IPColocationFactorWeight}});const h=e.behaviourPenalty*e.behaviourPenalty;return l+=h*t.behaviourPenaltyWeight,i+=a+c+l,{byTopic:o,p5w:a,p6w:c,p7w:l,score:i}}function D9(n,e,t,r,s){const i={byTopic:new Map,p5w:[],p6w:[],p7w:[],score:[]};for(const o of n){const a=e.get(o);if(a!=null){const c=C9(o,a,t,r,s);for(const[l,u]of c.byTopic){let h=i.byTopic.get(l);h==null&&(h={p1w:[],p2w:[],p3w:[],p3bw:[],p4w:[]},i.byTopic.set(l,h)),h.p1w.push(u.p1w),h.p2w.push(u.p2w),h.p3w.push(u.p3w),h.p3bw.push(u.p3bw),h.p4w.push(u.p4w)}i.p5w.push(c.p5w),i.p6w.push(c.p6w),i.p7w.push(c.p7w),i.score.push(c.score)}else i.p5w.push(0),i.p6w.push(0),i.p7w.push(0),i.score.push(0)}return i}class R9{rawStream;pushable;closeController;maxBufferSize;constructor(e,t,r){this.rawStream=e,this.pushable=_r(),this.closeController=new AbortController,this.maxBufferSize=r.maxBufferSize??1/0,this.closeController.signal.addEventListener("abort",()=>{e.close().catch(s=>{e.abort(s)})}),Bt(this.pushable,this.rawStream).catch(t)}get protocol(){return this.rawStream.protocol}push(e){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(lc.single(e))}pushPrefixed(e){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(e)}async close(){this.closeController.abort(),await this.pushable.return()}}class M9{source;rawStream;closeController;constructor(e,t={}){this.rawStream=e,this.closeController=new AbortController,this.closeController.signal.addEventListener("abort",()=>{e.close().catch(r=>{e.abort(r)})}),this.source=Bt(this.rawStream,r=>Fi(r,t))}async close(){this.closeController.abort()}}class L9{gossipsubIWantFollowupMs;msgIdToStrFn;metrics;promises=new Map;requestMsByMsg=new Map;requestMsByMsgExpire;constructor(e,t,r){this.gossipsubIWantFollowupMs=e,this.msgIdToStrFn=t,this.metrics=r,this.requestMsByMsgExpire=10*e}get size(){return this.promises.size}get requestMsByMsgSize(){return this.requestMsByMsg.size}addPromise(e,t){const r=Math.floor(Math.random()*t.length),s=t[r],i=this.msgIdToStrFn(s);let o=this.promises.get(i);o==null&&(o=new Map,this.promises.set(i,o));const a=Date.now();o.has(e)||(o.set(e,a+this.gossipsubIWantFollowupMs),this.metrics!=null&&(this.metrics.iwantPromiseStarted.inc(1),this.requestMsByMsg.has(i)||this.requestMsByMsg.set(i,a)))}getBrokenPromises(){const e=Date.now(),t=new Map;let r=0;return this.promises.forEach((s,i)=>{s.forEach((o,a)=>{o<e&&(t.set(a,(t.get(a)??0)+1),s.delete(a),r++)}),s.size===0&&this.promises.delete(i)}),this.metrics?.iwantPromiseBroken.inc(r),t}deliverMessage(e,t=!1){this.trackMessage(e);const r=this.promises.get(e);r!=null&&(this.promises.delete(e),this.metrics!=null&&(this.metrics.iwantPromiseResolved.inc(1),t&&this.metrics.iwantPromiseResolvedFromDuplicate.inc(1),this.metrics.iwantPromiseResolvedPeers.inc(r.size)))}rejectMessage(e,t){switch(this.trackMessage(e),t){case nr.Error:return}this.promises.delete(e)}clear(){this.promises.clear()}prune(){const e=Date.now()-this.requestMsByMsgExpire;let t=0;for(const[r,s]of this.requestMsByMsg.entries())if(s<e)this.requestMsByMsg.delete(r),t++;else break;this.metrics?.iwantMessagePruned.inc(t)}trackMessage(e){if(this.metrics!=null){const t=this.requestMsByMsg.get(e);t!==void 0&&(this.metrics.iwantPromiseDeliveryTime.observe((Date.now()-t)/1e3),this.requestMsByMsg.delete(e))}}}function G3(n,e,t,r){ja(n);const s=u5({dkLen:32,asyncTick:10},r),{c:i,dkLen:o,asyncTick:a}=s;if(_s(i),_s(o),_s(a),i<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const c=Vn(e),l=Vn(t),u=new Uint8Array(o),h=to.create(n,c),d=h._cloneInto().update(l);return{c:i,dkLen:o,asyncTick:a,DK:u,PRF:h,PRFSalt:d}}function Q3(n,e,t,r,s){return n.destroy(),e.destroy(),r&&r.destroy(),s.fill(0),t}function N9(n,e,t,r){const{c:s,dkLen:i,DK:o,PRF:a,PRFSalt:c}=G3(n,e,t,r);let l;const u=new Uint8Array(4),h=Si(u),d=new Uint8Array(a.outputLen);for(let f=1,p=0;p<i;f++,p+=a.outputLen){const m=o.subarray(p,p+a.outputLen);h.setInt32(0,f,!1),(l=c._cloneInto(l)).update(u).digestInto(d),m.set(d.subarray(0,m.length));for(let g=1;g<s;g++){a._cloneInto(l).update(d).digestInto(d);for(let y=0;y<m.length;y++)m[y]^=d[y]}}return Q3(a,c,o,l,d)}async function Y3(n,e,t,r){const{c:s,dkLen:i,asyncTick:o,DK:a,PRF:c,PRFSalt:l}=G3(n,e,t,r);let u;const h=new Uint8Array(4),d=Si(h),f=new Uint8Array(c.outputLen);for(let p=1,m=0;m<i;p++,m+=c.outputLen){const g=a.subarray(m,m+c.outputLen);d.setInt32(0,p,!1),(u=l._cloneInto(u)).update(h).digestInto(f),g.set(f.subarray(0,g.length)),await a5(s-1,o,()=>{c._cloneInto(u).update(f).digestInto(f);for(let y=0;y<g.length;y++)g[y]^=f[y]})}return Q3(c,l,a,u,f)}const di=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),zr=new Uint32Array(80);class B9 extends Ku{constructor(){super(64,20,8,!1),this.A=di[0]|0,this.B=di[1]|0,this.C=di[2]|0,this.D=di[3]|0,this.E=di[4]|0}get(){const{A:e,B:t,C:r,D:s,E:i}=this;return[e,t,r,s,i]}set(e,t,r,s,i){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=i|0}process(e,t){for(let c=0;c<16;c++,t+=4)zr[c]=e.getUint32(t,!1);for(let c=16;c<80;c++)zr[c]=Cc(zr[c-3]^zr[c-8]^zr[c-14]^zr[c-16],1);let{A:r,B:s,C:i,D:o,E:a}=this;for(let c=0;c<80;c++){let l,u;c<20?(l=D0(s,i,o),u=1518500249):c<40?(l=s^i^o,u=1859775393):c<60?(l=R0(s,i,o),u=2400959708):(l=s^i^o,u=3395469782);const h=Cc(r,5)+l+a+u+zr[c]|0;a=o,o=i,i=Cc(s,30),s=r,r=h}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,this.set(r,s,i,o,a)}roundClean(){zr.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}}const O9=qu(()=>new B9),Yd={sha1:O9,"sha2-256":rn,"sha2-512":ec};function Xd(n,e,t,r,s){if(s!=="sha1"&&s!=="sha2-256"&&s!=="sha2-512"){const a=Object.keys(Yd).join(" / ");throw new B(`Hash '${s}' is unknown or not supported. Must be ${a}`)}const i=Yd[s],o=N9(i,n,e,{c:t,dkLen:r});return qt.encode(o).substring(1)}const X3=V("libp2p-pubsub:");async function F9(n,e,t,r){switch(n.type){case Ls.Signing:{const s={from:n.author.toMultihash().bytes,data:r,seqno:un(8),topic:e,signature:void 0,key:void 0},i=We([X3,Bn.Message.encode(s)]);s.signature=await n.privateKey.sign(i),s.key=n.key;const o={type:"signed",from:n.author,data:t,sequenceNumber:BigInt(`0x${K(s.seqno??new Uint8Array(0),"base16")}`),topic:e,signature:s.signature,key:Tt(s.key)};return{raw:s,msg:o}}case Ls.Anonymous:return{raw:{from:void 0,data:r,seqno:void 0,topic:e,signature:void 0,key:void 0},msg:{type:"unsigned",data:t,topic:e}};default:throw new Error("Unreachable")}}async function U9(n,e){switch(n){case Fu:return e.signature!=null?{valid:!1,error:wt.SignaturePresent}:e.seqno!=null?{valid:!1,error:wt.SeqnoPresent}:e.key!=null?{valid:!1,error:wt.FromPresent}:{valid:!0,message:{type:"unsigned",topic:e.topic,data:e.data??new Uint8Array(0)}};case Yo:{if(e.seqno==null)return{valid:!1,error:wt.InvalidSeqno};if(e.seqno.length!==8)return{valid:!1,error:wt.InvalidSeqno};if(e.signature==null)return{valid:!1,error:wt.InvalidSignature};if(e.from==null)return{valid:!1,error:wt.InvalidPeerId};let t;try{t=Ft(je(e.from))}catch{return{valid:!1,error:wt.InvalidPeerId}}let r;if(e.key!=null){if(r=Tt(e.key),t.publicKey!==void 0&&!r.equals(t.publicKey))return{valid:!1,error:wt.InvalidPeerId}}else{if(t.publicKey==null)return{valid:!1,error:wt.InvalidPeerId};r=t.publicKey}const s={from:e.from,data:e.data,seqno:e.seqno,topic:e.topic,signature:void 0,key:void 0},i=We([X3,Bn.Message.encode(s)]);return await r.verify(i,e.signature)?{valid:!0,message:{type:"signed",from:t,data:e.data??new Uint8Array(0),sequenceNumber:BigInt(`0x${K(e.seqno,"base16")}`),topic:e.topic,signature:e.signature,key:e.key!=null?Tt(e.key):r}}:{valid:!1,error:wt.InvalidSignature}}default:throw new Error("Unreachable")}}function dr(n=[],e){return{subscriptions:[],messages:n,control:e!==void 0?{graft:e.graft??[],prune:e.prune??[],ihave:e.ihave??[],iwant:e.iwant??[],idontwant:e.idontwant??[]}:void 0}}function Zd(n){return n.control===void 0&&(n.control={graft:[],prune:[],ihave:[],iwant:[],idontwant:[]}),n}function Ar(n){if(n.length<=1)return n;const e=()=>Math.floor(Math.random()*Math.floor(n.length));for(let t=0;t<n.length;t++){const r=e(),s=n[t];n[t]=n[r],n[r]=s}return n}function $9(n){return K(n,"base64")}function V9(n,e,t){switch(n){case Yo:return{type:Ls.Signing,author:e,key:rr(t.publicKey),privateKey:t};case Fu:return{type:Ls.Anonymous};default:throw new Error(`Unknown signature policy "${n}"`)}}const H9=(n,e)=>{const t=V(e.toString(16).padStart(16,"0"),"base16"),r=rr(n),s=new Uint8Array(r.byteLength+t.length);return s.set(r,0),s.set(t,r.byteLength),s};function z9(n){if(n.type!=="signed")throw new Error("expected signed message type");if(n.sequenceNumber==null)throw Error("missing seqno field");return H9(n.from.publicKey??n.key,n.sequenceNumber)}async function q9(n){return Nt.encode(n.data)}class K9{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return r===void 0&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return r()})}readNumber(e,t,r,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const d=Number.parseInt(h,e);if(!Number.isNaN(d))return d});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!r&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;e[t]=r}return e})}readIPv6Addr(){const e=t=>{for(let r=0;r<t.length/2;r++){const s=r*2;if(r<t.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,s]=e(t);if(r===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(r+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Z3=45,W9=15,Ns=new K9;function j3(n){if(!(n.length>W9))return Ns.new(n).parseWith(()=>Ns.readIPv4Addr())}function J3(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>Z3))return Ns.new(n).parseWith(()=>Ns.readIPv6Addr())}function aa(n,e=!1){if(n.includes("%")&&(n=n.split("%")[0]),n.length>Z3)return;const t=Ns.new(n).parseWith(()=>Ns.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function G9(n,e,t){let r=0;for(const s of n)if(!(r<e)){if(r>t)break;if(s!==255)return!1;r++}return!0}function Q9(n,e,t,r){let s=0;for(const i of n)if(!(s<t)){if(s>r)break;if(i!==e[s])return!1;s++}return!0}function Y9(n){switch(n.length){case Ui:return n.join(".");case $i:{const e=[];for(let t=0;t<n.length;t++)t%2===0&&e.push(n[t].toString(16).padStart(2,"0")+n[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function X9(n){let e=0;for(let[t,r]of n.entries()){if(r===255){e+=8;continue}for(;r&128;)e++,r=r<<1;if(r&128)return-1;for(let s=t+1;s<n.length;s++)if(n[s]!=0)return-1;break}return e}function Z9(n){let e="0x";for(const t of n)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Ui=4,$i=16,j9=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function ep(n,e){e.length===$i&&n.length===Ui&&G9(e,0,11)&&(e=e.slice(12)),e.length===Ui&&n.length===$i&&Q9(n,j9,0,11)&&(n=n.slice(12));const t=n.length;if(t!=e.length)throw new Error("Failed to mask ip");const r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=n[s]&e[s];return r}function J9(n,e){if(typeof e=="string"&&(e=aa(e)),e==null)throw new Error("Invalid ip");if(e.length!==n.network.length)return!1;for(let t=0;t<e.length;t++)if((n.network[t]&n.mask[t])!==(e[t]&n.mask[t]))return!1;return!0}function ey(n){const[e,t]=n.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+n);let r=Ui,s=j3(e);if(s==null&&(r=$i,s=J3(e),s==null))throw new Error("Failed to parse given CIDR: "+n);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>r*8)throw new Error("Failed to parse given CIDR: "+n);const o=tp(i,8*r);return{network:ep(s,o),mask:o}}function tp(n,e){if(e!==8*Ui&&e!==8*$i)throw new Error("Invalid CIDR mask");if(n<0||n>e)throw new Error("Invalid CIDR mask");const t=e/8,r=new Uint8Array(t);for(let s=0;s<t;s++){if(n>=8){r[s]=255,n-=8;continue}r[s]=255-(255>>n),n=0}return r}class rp{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=ey(e));else{const r=aa(e);if(r==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>r.length*8){const i=aa(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=tp(s,8*r.length);this.network=ep(r,this.mask)}}contains(e){return J9({network:this.network,mask:this.mask},e)}toString(){const e=X9(this.mask),t=e!==-1?String(e):Z9(this.mask);return Y9(this.network)+"/"+t}}function ty(n,e){return new rp(n).contains(e)}function Bs(n){return!!j3(n)}function gh(n){return!!J3(n)}function np(n){return!!aa(n)}const jd=Bs,ry=gh,sp=function(n){let e=0;if(n=n.toString().trim(),jd(n)){const t=new Uint8Array(e+4);return n.split(/\./g).forEach(r=>{t[e++]=parseInt(r,10)&255}),t}if(ry(n)){const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const i=jd(t[r]);let o;i&&(o=sp(t[r]),t[r]=K(o.slice(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,K(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const i=[r,1];for(r=9-t.length;r>0;r--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(r=0;r<t.length;r++){const i=parseInt(t[r],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},ny=function(n,e=0,t){e=~~e,t=t??n.length-e;const r=new DataView(n.buffer);if(t===4){const s=[];for(let i=0;i<t;i++)s.push(n[e+i]);return s.join(".")}if(t===16){const s=[];for(let i=0;i<t;i+=2)s.push(r.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},Ct=-1,Vi={},Jl={},sy=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ct,"ip6zone"],[43,8,"ipcidr"],[53,Ct,"dns",!0],[54,Ct,"dns4",!0],[55,Ct,"dns6",!0],[56,Ct,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ct,"unix",!1,!0],[421,Ct,"ipfs"],[421,Ct,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ct,"garlic64"],[448,0,"tls"],[449,Ct,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ct,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ct,"http-path"],[777,Ct,"memory"]];sy.forEach(n=>{const e=iy(...n);Jl[e.code]=e,Vi[e.name]=e});function iy(n,e,t,r,s){return{code:n,size:e,name:t,resolvable:!!r,path:!!s}}function ne(n){if(typeof n=="number"){if(Jl[n]!=null)return Jl[n];throw new Error(`no protocol with code: ${n}`)}else if(typeof n=="string"){if(Vi[n]!=null)return Vi[n];throw new Error(`no protocol with name: ${n}`)}throw new Error(`invalid protocol id type: ${typeof n}`)}const oy=ne("ip4"),ay=ne("ip6"),cy=ne("ipcidr");function mh(n,e){switch(ne(n).code){case 4:case 41:return hy(e);case 42:return Qc(e);case 43:return K(e,"base10");case 6:case 273:case 33:case 132:return ip(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Qc(e);case 421:return gy(e);case 444:return t1(e);case 445:return t1(e);case 466:return py(e);case 481:return globalThis.encodeURIComponent(Qc(e));default:return K(e,"base16")}}function Jd(n,e){switch(ne(n).code){case 4:return e1(e);case 41:return e1(e);case 42:return Gc(e);case 43:return V(e,"base10");case 6:case 273:case 33:case 132:return yh(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Gc(e);case 421:return dy(e);case 444:return my(e);case 445:return yy(e);case 466:return fy(e);case 481:return Gc(globalThis.decodeURIComponent(e));default:return V(e,"base16")}}function ly(n){let e,t;if(n.stringTuples().forEach(([r,s])=>{(r===oy.code||r===ay.code)&&(t=s),r===cy.code&&(e=s)}),e==null||t==null)throw new Error("Invalid multiaddr");return new rp(t,e)}const Wc=Object.values(na).map(n=>n.decoder),uy=function(){let n=Wc[0].or(Wc[1]);return Wc.slice(2).forEach(e=>n=n.or(e)),n}();function e1(n){if(!np(n))throw new Error("invalid ip address");return sp(n)}function hy(n){const e=ny(n,0,n.length);if(e==null)throw new Error("ipBuff is required");if(!np(e))throw new Error("invalid ip address");return e}function yh(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,n),new Uint8Array(e)}function ip(n){return new DataView(n.buffer).getUint16(n.byteOffset)}function Gc(n){const e=V(n),t=Uint8Array.from(Ze(e.length));return We([t,e],t.length+e.length)}function Qc(n){const e=ar(n);if(n=n.slice(ye(e)),n.length!==e)throw new Error("inconsistent lengths");return K(n)}function dy(n){let e;n[0]==="Q"||n[0]==="1"?e=je(ze.decode(`z${n}`)).bytes:e=Y.parse(n).multihash.bytes;const t=Uint8Array.from(Ze(e.length));return We([t,e],t.length+e.length)}function fy(n){const e=uy.decode(n),t=Uint8Array.from(Ze(e.length));return We([t,e],t.length+e.length)}function py(n){const e=ar(n),t=n.slice(ye(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+K(t,"base64url")}function gy(n){const e=ar(n),t=n.slice(ye(e));if(t.length!==e)throw new Error("inconsistent lengths");return K(t,"base58btc")}function my(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=xt.decode("b"+e[0]),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=yh(r);return We([t,s],t.length+s.length)}function yy(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=xt.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=yh(r);return We([t,s],t.length+s.length)}function t1(n){const e=n.slice(0,n.length-2),t=n.slice(n.length-2),r=K(e,"base32"),s=ip(t);return`${r}:${s}`}var ca;(function(n){n[n.ip4=4]="ip4",n[n.ip6=41]="ip6"})(ca||(ca={}));function wy(n){for(const e of n.tuples())switch(e[0]){case ca.ip4:case ca.ip6:return mh(e[0],e[1])}return null}class Yc{entries=new Map;validityMs;constructor(e){this.validityMs=e.validityMs}get size(){return this.entries.size}put(e,t){return this.entries.has(e)?!0:(this.entries.set(e,{value:t,validUntilMs:Date.now()+this.validityMs}),!1)}prune(){const e=Date.now();for(const[t,r]of this.entries.entries())if(r.validUntilMs<e)this.entries.delete(t);else break}has(e){return this.entries.has(e)}get(e){const t=this.entries.get(e);return t!=null&&t.validUntilMs>=Date.now()?t.value:void 0}clear(){this.entries.clear()}}var Dt;(function(n){n[n.started=0]="started",n[n.stopped=1]="stopped"})(Dt||(Dt={}));class by extends Ke{globalSignaturePolicy;multicodecs=[qc,Cm,zd];publishConfig;dataTransform;peers=new Set;streamsInbound=new Map;streamsOutbound=new Map;outboundInflightQueue=_r({objectMode:!0});direct=new Set;floodsubPeers=new Set;seenCache;acceptFromWhitelist=new Map;topics=new Map;subscriptions=new Set;mesh=new Map;fanout=new Map;fanoutLastpub=new Map;gossip=new Map;control=new Map;peerhave=new Map;iasked=new Map;backoff=new Map;outbound=new Map;msgIdFn;fastMsgIdFn;msgIdToStrFn;fastMsgIdCache;publishedMessageIds;mcache;score;topicValidators=new Map;log;heartbeatTicks=0;gossipTracer;idontwantCounts=new Map;idontwants=new Map;components;directPeerInitial=null;static multicodec=qc;opts;decodeRpcLimits;metrics;status={code:Dt.stopped};maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;allowedTopics;heartbeatTimer=null;constructor(e,t={}){super();const r={fallbackToFloodsub:!0,floodPublish:!0,batchPublish:!1,tagMeshPeers:!0,doPX:!1,directPeers:[],D:Dm,Dlo:Rm,Dhi:Mm,Dscore:Lm,Dout:Nm,Dlazy:Fm,heartbeatInterval:Vm,fanoutTTL:Hm,mcacheLength:Bm,mcacheGossip:Om,seenTTL:e9,gossipsubIWantFollowupMs:Jm,prunePeers:zm,pruneBackoff:qm,unsubcribeBackoff:Km,graftFloodThreshold:Zm,opportunisticGraftPeers:Xm,opportunisticGraftTicks:Ym,directConnectTicks:Gm,gossipFactor:Um,idontwantMinDataSize:l9,idontwantMaxMessages:u9,...t,scoreParams:m9(t.scoreParams),scoreThresholds:E9(t.scoreThresholds)};if(this.components=e,this.decodeRpcLimits=r.decodeRpcLimits??h9,this.globalSignaturePolicy=r.globalSignaturePolicy??Yo,r.fallbackToFloodsub&&this.multicodecs.push(Hd),this.log=e.logger.forComponent(r.debugName??"libp2p:gossipsub"),this.opts=r,this.direct=new Set(r.directPeers.map(s=>s.id.toString())),this.seenCache=new Yc({validityMs:r.seenTTL}),this.publishedMessageIds=new Yc({validityMs:r.seenTTL}),t.msgIdFn!=null)this.msgIdFn=t.msgIdFn;else switch(this.globalSignaturePolicy){case Yo:this.msgIdFn=z9;break;case Fu:this.msgIdFn=q9;break;default:throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)}if(t.fastMsgIdFn!=null&&(this.fastMsgIdFn=t.fastMsgIdFn,this.fastMsgIdCache=new Yc({validityMs:r.seenTTL})),this.msgIdToStrFn=t.msgIdToStrFn??$9,this.mcache=t.messageCache??new d9(r.mcacheGossip,r.mcacheLength,this.msgIdToStrFn),t.dataTransform!=null&&(this.dataTransform=t.dataTransform),t.metricsRegister!=null){if(t.metricsTopicStrToLabel==null)throw Error("Must set metricsTopicStrToLabel with metrics");const s=Math.max(...Object.values(r.scoreParams.topics).map(o=>o.meshMessageDeliveriesWindow),a9),i=f9(t.metricsRegister,t.metricsTopicStrToLabel,{gossipPromiseExpireSec:this.opts.gossipsubIWantFollowupMs/1e3,behaviourPenaltyThreshold:r.scoreParams.behaviourPenaltyThreshold,maxMeshMessageDeliveriesWindowSec:s/1e3});i.mcacheSize.addCollect(()=>{this.onScrapeMetrics(i)});for(const o of this.multicodecs)i.protocolsEnabled.set({protocol:o},1);this.metrics=i}else this.metrics=null;this.gossipTracer=new L9(this.opts.gossipsubIWantFollowupMs,this.msgIdToStrFn,this.metrics),this.score=new P9(this.opts.scoreParams,this.metrics,this.components.logger,{scoreCacheValidityMs:r.heartbeatInterval}),this.maxInboundStreams=t.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams,this.runOnLimitedConnection=t.runOnLimitedConnection,this.allowedTopics=r.allowedTopics!=null?new Set(r.allowedTopics):null}[Symbol.toStringTag]="@chainsafe/libp2p-gossipsub";[rt]=["@libp2p/pubsub"];[cn]=["@libp2p/identify"];getPeers(){return[...this.peers.keys()].map(e=>Ue(e))}isStarted(){return this.status.code===Dt.started}async start(){if(this.isStarted())return;this.log("starting"),this.publishConfig=V9(this.globalSignaturePolicy,this.components.peerId,this.components.privateKey),this.outboundInflightQueue=_r({objectMode:!0}),Bt(this.outboundInflightQueue,async i=>{for await(const{peerId:o,connection:a}of i)await this.createOutboundStream(o,a)}).catch(i=>{this.log.error("outbound inflight queue error",i)}),await Promise.all(this.opts.directPeers.map(async i=>{await this.components.peerStore.merge(i.id,{multiaddrs:i.addrs})}));const e=this.components.registrar;await Promise.all(this.multicodecs.map(async i=>e.handle(i,this.onIncomingStream.bind(this),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection})));const t={onConnect:this.onPeerConnected.bind(this),onDisconnect:this.onPeerDisconnected.bind(this),notifyOnLimitedConnection:this.runOnLimitedConnection},r=await Promise.all(this.multicodecs.map(async i=>e.register(i,t))),s=setTimeout(this.runHeartbeat,qd);this.status={code:Dt.started,registrarTopologyIds:r,heartbeatTimeout:s,hearbeatStartMs:Date.now()+qd},this.score.start(),this.directPeerInitial=setTimeout(()=>{Promise.resolve().then(async()=>{await Promise.all(Array.from(this.direct).map(async i=>this.connect(i)))}).catch(i=>{this.log(i)})},Qm),this.opts.tagMeshPeers&&(this.addEventListener("gossipsub:graft",this.tagMeshPeer),this.addEventListener("gossipsub:prune",this.untagMeshPeer)),this.log("started")}async stop(){if(this.log("stopping"),this.status.code!==Dt.started)return;const{registrarTopologyIds:e}=this.status;this.status={code:Dt.stopped},this.opts.tagMeshPeers&&(this.removeEventListener("gossipsub:graft",this.tagMeshPeer),this.removeEventListener("gossipsub:prune",this.untagMeshPeer));const t=this.components.registrar;await Promise.all(this.multicodecs.map(async s=>t.unhandle(s))),e.forEach(s=>{t.unregister(s)}),this.outboundInflightQueue.end();const r=[];for(const s of this.streamsOutbound.values())r.push(s.close());this.streamsOutbound.clear();for(const s of this.streamsInbound.values())r.push(s.close());this.streamsInbound.clear(),await Promise.all(r),this.peers.clear(),this.subscriptions.clear(),this.heartbeatTimer!=null&&(this.heartbeatTimer.cancel(),this.heartbeatTimer=null),this.score.stop(),this.mesh.clear(),this.fanout.clear(),this.fanoutLastpub.clear(),this.gossip.clear(),this.control.clear(),this.peerhave.clear(),this.iasked.clear(),this.backoff.clear(),this.outbound.clear(),this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache!=null&&this.fastMsgIdCache.clear(),this.directPeerInitial!=null&&clearTimeout(this.directPeerInitial),this.idontwantCounts.clear(),this.idontwants.clear(),this.log("stopped")}dumpPeerScoreStats(){return this.score.dumpPeerScoreStats()}onIncomingStream({stream:e,connection:t}){if(!this.isStarted())return;const r=t.remotePeer;this.addPeer(r,t.direction,t.remoteAddr),this.createInboundStream(r,e),this.outboundInflightQueue.push({peerId:r,connection:t})}onPeerConnected(e,t){this.metrics?.newConnectionCount.inc({status:t.status}),!(!this.isStarted()||t.status!=="open")&&(this.addPeer(e,t.direction,t.remoteAddr),this.outboundInflightQueue.push({peerId:e,connection:t}))}onPeerDisconnected(e){this.log("connection ended %p",e),this.removePeer(e)}async createOutboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(this.peers.has(r)&&!this.streamsOutbound.has(r))try{const s=new R9(await t.newStream(this.multicodecs,{runOnLimitedConnection:this.runOnLimitedConnection}),o=>{this.log.error("outbound pipe error",o)},{maxBufferSize:this.opts.maxOutboundBufferSize});this.log("create outbound stream %p",e),this.streamsOutbound.set(r,s);const i=s.protocol;i===Hd&&this.floodsubPeers.add(r),this.metrics?.peersPerProtocol.inc({protocol:i},1),this.subscriptions.size>0&&(this.log("send subscriptions to",r),this.sendSubscriptions(r,Array.from(this.subscriptions),!0))}catch(s){this.log.error("createOutboundStream error",s)}}createInboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(!this.peers.has(r))return;const s=this.streamsInbound.get(r);s!==void 0&&(this.log("replacing existing inbound steam %s",r),s.close().catch(o=>{this.log.error(o)})),this.log("create inbound stream %s",r);const i=new M9(t,{maxDataLength:this.opts.maxInboundDataLength});this.streamsInbound.set(r,i),this.pipePeerReadStream(e,i.source).catch(o=>{this.log(o)})}addPeer(e,t,r){const s=e.toString();if(!this.peers.has(s)){this.log("new peer %p",e),this.peers.add(s),this.score.addPeer(s);const i=wy(r);i!==null?this.score.addIP(s,i):this.log("Added peer has no IP in current address %s %s",s,r.toString()),this.outbound.has(s)||this.outbound.set(s,t==="outbound")}}removePeer(e){const t=e.toString();if(!this.peers.has(t))return;this.log("delete peer %p",e),this.peers.delete(t);const r=this.streamsOutbound.get(t),s=this.streamsInbound.get(t);r!=null&&this.metrics?.peersPerProtocol.inc({protocol:r.protocol},-1),r?.close().catch(i=>{this.log.error(i)}),s?.close().catch(i=>{this.log.error(i)}),this.streamsOutbound.delete(t),this.streamsInbound.delete(t);for(const i of this.topics.values())i.delete(t);for(const[i,o]of this.mesh)o.delete(t)&&this.metrics?.onRemoveFromMesh(i,yr.Dc,1);for(const i of this.fanout.values())i.delete(t);this.floodsubPeers.delete(t),this.gossip.delete(t),this.control.delete(t),this.outbound.delete(t),this.idontwantCounts.delete(t),this.idontwants.delete(t),this.score.removePeer(t),this.acceptFromWhitelist.delete(t)}get started(){return this.status.code===Dt.started}getMeshPeers(e){const t=this.mesh.get(e);return t!=null?Array.from(t):[]}getSubscribers(e){const t=this.topics.get(e);return(t!=null?Array.from(t):[]).map(r=>Ue(r))}getTopics(){return Array.from(this.subscriptions)}async pipePeerReadStream(e,t){try{await Bt(t,async r=>{for await(const s of r)try{const i=s.subarray(),o=Bn.decode(i,{limits:{subscriptions:this.decodeRpcLimits.maxSubscriptions,messages:this.decodeRpcLimits.maxMessages,control$:{ihave:this.decodeRpcLimits.maxIhaveMessageIDs,iwant:this.decodeRpcLimits.maxIwantMessageIDs,graft:this.decodeRpcLimits.maxControlMessages,prune:this.decodeRpcLimits.maxControlMessages,prune$:{peers:this.decodeRpcLimits.maxPeerInfos},idontwant:this.decodeRpcLimits.maxControlMessages,idontwant$:{messageIDs:this.decodeRpcLimits.maxIdontwantMessageIDs}}}});if(this.metrics?.onRpcRecv(o,i.length),this.opts.awaitRpcHandler)try{await this.handleReceivedRpc(e,o)}catch(a){this.metrics?.onRpcRecvError(),this.log(a)}else this.handleReceivedRpc(e,o).catch(a=>{this.metrics?.onRpcRecvError(),this.log(a)})}catch(i){this.metrics?.onRpcDataError(),this.log(i)}})}catch(r){this.metrics?.onPeerReadStreamError(),this.handlePeerReadStreamError(r,e)}}handlePeerReadStreamError(e,t){this.log.error(e),this.onPeerDisconnected(t)}async handleReceivedRpc(e,t){if(!this.acceptFrom(e.toString())){this.log("received message from unacceptable peer %p",e),this.metrics?.rpcRecvNotAccepted.inc();return}const r=t.subscriptions!=null?t.subscriptions.length:0,s=t.messages!=null?t.messages.length:0;let i=0,o=0,a=0,c=0;if(t.control!=null&&(t.control.ihave!=null&&(i=t.control.ihave.length),t.control.iwant!=null&&(o=t.control.iwant.length),t.control.graft!=null&&(a=t.control.graft.length),t.control.prune!=null&&(c=t.control.prune.length)),this.log(`rpc.from ${e.toString()} subscriptions ${r} messages ${s} ihave ${i} iwant ${o} graft ${a} prune ${c}`),t.subscriptions!=null&&t.subscriptions.length>0){const l=[];t.subscriptions.forEach(u=>{const h=u.topic,d=u.subscribe===!0;if(h!=null){if(this.allowedTopics!=null&&!this.allowedTopics.has(h))return;this.handleReceivedSubscription(e,h,d),l.push({topic:h,subscribe:d})}}),this.safeDispatchEvent("subscription-change",{detail:{peerId:e,subscriptions:l}})}for(const l of t.messages){if(this.allowedTopics!=null&&!this.allowedTopics.has(l.topic))continue;const u=this.handleReceivedMessage(e,l).catch(h=>{this.metrics?.onMsgRecvError(l.topic),this.log(h)});this.opts.awaitRpcMessageHandler&&await u}t.control!=null&&await this.handleControlMessage(e.toString(),t.control)}handleReceivedSubscription(e,t,r){this.log("subscription update from %p topic %s",e,t);let s=this.topics.get(t);s==null&&(s=new Set,this.topics.set(t,s)),r?s.add(e.toString()):s.delete(e.toString())}async handleReceivedMessage(e,t){this.metrics?.onMsgRecvPreValidation(t.topic);const r=await this.validateReceivedMessage(e,t);this.metrics?.onPrevalidationResult(t.topic,r.code);const s=r.code;switch(s){case Et.duplicate:this.score.duplicateMessage(e.toString(),r.msgIdStr,t.topic),this.gossipTracer.deliverMessage(r.msgIdStr,!0),this.mcache.observeDuplicate(r.msgIdStr,e.toString());return;case Et.invalid:if(r.msgIdStr!=null){const i=r.msgIdStr;this.score.rejectMessage(e.toString(),i,t.topic,r.reason),this.gossipTracer.rejectMessage(i,r.reason)}else this.score.rejectInvalidMessage(e.toString(),t.topic);this.metrics?.onMsgRecvInvalid(t.topic,r);return;case Et.valid:this.score.validateMessage(r.messageId.msgIdStr),this.gossipTracer.deliverMessage(r.messageId.msgIdStr),this.mcache.put(r.messageId,t,!this.opts.asyncValidation),this.subscriptions.has(t.topic)&&(!this.components.peerId.equals(e)||this.opts.emitSelf)&&(super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:e,msgId:r.messageId.msgIdStr,msg:r.msg}})),super.dispatchEvent(new CustomEvent("message",{detail:r.msg}))),this.opts.asyncValidation||this.forwardMessage(r.messageId.msgIdStr,t,e.toString());break;default:throw new Error(`Invalid validation result: ${s}`)}}async validateReceivedMessage(e,t){const r=this.fastMsgIdFn?.(t),s=r!==void 0?this.fastMsgIdCache?.get(r):void 0;if(s!=null)return{code:Et.duplicate,msgIdStr:s};const i=await U9(this.globalSignaturePolicy,t);if(!i.valid)return{code:Et.invalid,reason:nr.Error,error:i.error};const o=i.message;try{this.dataTransform!=null&&(o.data=this.dataTransform.inboundTransform(t.topic,o.data))}catch(h){return this.log("Invalid message, transform failed",h),{code:Et.invalid,reason:nr.Error,error:wt.TransformFailed}}const a=await this.msgIdFn(o),c=this.msgIdToStrFn(a),l={msgId:a,msgIdStr:c};if(r!==void 0&&this.fastMsgIdCache!=null&&this.fastMsgIdCache.put(r,c)&&this.metrics?.fastMsgIdCacheCollision.inc(),this.seenCache.has(c))return{code:Et.duplicate,msgIdStr:c};this.seenCache.put(c),(t.data?.length??0)>=this.opts.idontwantMinDataSize&&this.sendIDontWants(a,t.topic,e.toString());const u=this.topicValidators.get(t.topic);if(u!=null){let h;try{h=await u(e,o)}catch(d){const f=d.code;f===n9&&(h=Vt.Ignore),f===r9?h=Vt.Reject:h=Vt.Ignore}if(h!==Vt.Accept)return{code:Et.invalid,reason:Wd(h),msgIdStr:c}}return{code:Et.valid,messageId:l,msg:o}}getScore(e){return this.score.score(e)}sendSubscriptions(e,t,r){this.sendRpc(e,{subscriptions:t.map(s=>({topic:s,subscribe:r})),messages:[]})}async handleControlMessage(e,t){if(t===void 0)return;const r=t.ihave?.length>0?this.handleIHave(e,t.ihave):[],s=t.iwant?.length>0?this.handleIWant(e,t.iwant):[],i=t.graft?.length>0?await this.handleGraft(e,t.graft):[];if(t.prune?.length>0&&await this.handlePrune(e,t.prune),t.idontwant?.length>0&&this.handleIdontwant(e,t.idontwant),r.length===0&&s.length===0&&i.length===0)return;const o=this.sendRpc(e,dr(s,{iwant:r,prune:i})),a=r[0]?.messageIDs;a!=null&&(o?this.gossipTracer.addPromise(e,a):this.metrics?.iwantPromiseUntracked.inc(1))}acceptFrom(e){if(this.direct.has(e))return!0;const t=Date.now(),r=this.acceptFromWhitelist.get(e);if(r!=null&&r.messagesAccepted<i9&&r.acceptUntil>=t)return r.messagesAccepted+=1,!0;const s=this.score.score(e);return s>=s9?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:t+o9}):this.acceptFromWhitelist.delete(e),s>=this.opts.scoreThresholds.graylistThreshold}handleIHave(e,t){if(t.length===0)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,r),this.metrics?.ihaveRcvIgnored.inc({reason:ki.LowScore}),[];const s=(this.peerhave.get(e)??0)+1;if(this.peerhave.set(e,s),s>jm)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,s),this.metrics?.ihaveRcvIgnored.inc({reason:ki.MaxIhave}),[];const i=this.iasked.get(e)??0;if(i>=us)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,i),this.metrics?.ihaveRcvIgnored.inc({reason:ki.MaxIasked}),[];const o=new Map;if(t.forEach(({topicID:l,messageIDs:u})=>{if(l==null||u==null||!this.mesh.has(l))return;let h=0;u.forEach(d=>{const f=this.msgIdToStrFn(d);this.seenCache.has(f)||(o.set(f,d),h++)}),this.metrics?.onIhaveRcv(l,u.length,h)}),o.size===0)return[];let a=o.size;a+i>us&&(a=us-i),this.log("IHAVE: Asking for %d out of %d messages from %s",a,o.size,e);let c=Array.from(o.values());return Ar(c),c=c.slice(0,a),this.iasked.set(e,i+a),[{messageIDs:c}]}handleIWant(e,t){if(t.length===0)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,r),[];const s=new Map,i=new Map;let o=0;return t.forEach(({messageIDs:a})=>{a?.forEach(c=>{const l=this.msgIdToStrFn(c),u=this.mcache.getWithIWantCount(l,e);if(u==null){o++;return}if(i.set(u.msg.topic,1+(i.get(u.msg.topic)??0)),u.count>$m){this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,c);return}s.set(l,u.msg)})}),this.metrics?.onIwantRcv(i,o),s.size===0?(this.log("IWANT: Could not provide any wanted messages to %s",e),[]):(this.log("IWANT: Sending %d messages to %s",s.size,e),Array.from(s.values()))}async handleGraft(e,t){const r=[],s=this.score.score(e),i=Date.now();let o=this.opts.doPX;if(t.forEach(({topicID:c})=>{if(c==null)return;const l=this.mesh.get(c);if(l==null){o=!1;return}if(l.has(e))return;const u=this.backoff.get(c)?.get(e);if(this.direct.has(e))this.log("GRAFT: ignoring request from direct peer %s",e),r.push(c),o=!1;else if(typeof u=="number"&&i<u){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1,xi.GraftBackoff),o=!1;const h=u+this.opts.graftFloodThreshold-this.opts.pruneBackoff;i<h&&this.score.addPenalty(e,1,xi.GraftBackoff),this.addBackoff(e,c),r.push(c)}else s<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,s,c),r.push(c),o=!1,this.addBackoff(e,c)):l.size>=this.opts.Dhi&&!(this.outbound.get(e)??!1)?(r.push(c),this.addBackoff(e,c)):(this.log("GRAFT: Add mesh link from %s in %s",e,c),this.score.graft(e,c),l.add(e),this.metrics?.onAddToMesh(c,_t.Subscribed,1));this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:c,direction:"inbound"}})}),r.length===0)return[];const a=!1;return Promise.all(r.map(async c=>this.makePrune(e,c,o,a)))}async handlePrune(e,t){const r=this.score.score(e);for(const{topicID:s,backoff:i,peers:o}of t){if(s==null)continue;const a=this.mesh.get(s);if(a==null)return;this.log("PRUNE: Remove mesh link to %s in %s",e,s),this.score.prune(e,s),a.has(e)&&(a.delete(e),this.metrics?.onRemoveFromMesh(s,yr.Prune,1)),typeof i=="number"&&i>0?this.doAddBackoff(e,s,i*1e3):this.addBackoff(e,s),o!=null&&o.length>0&&(r<this.opts.scoreThresholds.acceptPXThreshold?this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,r,s):await this.pxConnect(o)),this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:s,direction:"inbound"}})}}handleIdontwant(e,t){let r=this.idontwantCounts.get(e)??0;if(r>=this.opts.idontwantMaxMessages)return;const s=r;let i=this.idontwants.get(e);i==null&&(i=new Map,this.idontwants.set(e,i));let o=0;e:for(const{messageIDs:c}of t)for(const l of c){if(r>=this.opts.idontwantMaxMessages)break e;r++;const u=this.msgIdToStrFn(l);i.set(u,this.heartbeatTicks),this.mcache.msgs.has(u)||o++}this.idontwantCounts.set(e,r);const a=r-s;this.metrics?.onIdontwantRcv(a,o)}addBackoff(e,t){this.doAddBackoff(e,t,this.opts.pruneBackoff)}doAddBackoff(e,t,r){let s=this.backoff.get(t);s==null&&(s=new Map,this.backoff.set(t,s));const i=Date.now()+r;(s.get(e)??0)<i&&s.set(e,i)}applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach((e,t)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",t,e),this.score.addPenalty(t,e,xi.BrokenPromise)})}clearBackoff(){if(this.heartbeatTicks%Wm!==0)return;const e=Date.now();this.backoff.forEach((t,r)=>{t.forEach((s,i)=>{s+c9*this.opts.heartbeatInterval<e&&t.delete(i)}),t.size===0&&this.backoff.delete(r)})}async directConnect(){const e=[];this.direct.forEach(t=>{this.streamsOutbound.has(t)||e.push(t)}),await Promise.all(e.map(async t=>this.connect(t)))}async pxConnect(e){e.length>this.opts.prunePeers&&(Ar(e),e=e.slice(0,this.opts.prunePeers));const t=[];await Promise.all(e.map(async r=>{if(r.peerID==null)return;const s=Ft(je(r.peerID)),i=s.toString();if(!this.peers.has(i)){if(r.signedPeerRecord==null){t.push(i);return}try{if(!await this.components.peerStore.consumePeerRecord(r.signedPeerRecord,s)){this.log("bogus peer record obtained through px: could not add peer record to address book");return}t.push(i)}catch{this.log("bogus peer record obtained through px: invalid signature or not a peer record")}}})),t.length!==0&&await Promise.all(t.map(async r=>this.connect(r)))}async connect(e){this.log("Initiating connection with %s",e);const t=Ue(e),r=await this.components.connectionManager.openConnection(t);for(const s of this.multicodecs)for(const i of this.components.registrar.getTopologies(s))i.onConnect?.(t,r)}subscribe(e){if(this.status.code!==Dt.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(e)){this.subscriptions.add(e);for(const t of this.peers.keys())this.sendSubscriptions(t,[e],!0)}this.join(e)}unsubscribe(e){if(this.status.code!==Dt.started)throw new Error("Pubsub is not started");const t=this.subscriptions.delete(e);if(this.log("unsubscribe from %s - am subscribed %s",e,t),t)for(const r of this.peers.keys())this.sendSubscriptions(r,[e],!1);this.leave(e)}join(e){if(this.status.code!==Dt.started)throw new Error("Gossipsub has not started");if(this.mesh.has(e))return;this.log("JOIN %s",e),this.metrics?.onJoin(e);const t=new Set,r=this.backoff.get(e),s=this.fanout.get(e);if(s!=null&&(this.fanout.delete(e),this.fanoutLastpub.delete(e),s.forEach(i=>{!this.direct.has(i)&&this.score.score(i)>=0&&r?.has(i)!==!0&&t.add(i)}),this.metrics?.onAddToMesh(e,_t.Fanout,t.size)),t.size<this.opts.D){const i=t.size;this.getRandomGossipPeers(e,this.opts.D,a=>!t.has(a)&&!this.direct.has(a)&&this.score.score(a)>=0&&r?.has(a)!==!0).forEach(a=>{t.add(a)}),this.metrics?.onAddToMesh(e,_t.Random,t.size-i)}this.mesh.set(e,t),t.forEach(i=>{this.log("JOIN: Add mesh link to %s in %s",i,e),this.sendGraft(i,e)})}leave(e){if(this.status.code!==Dt.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e),this.metrics?.onLeave(e);const t=this.mesh.get(e);t!=null&&(Promise.all(Array.from(t).map(async r=>{this.log("LEAVE: Remove mesh link to %s in %s",r,e),await this.sendPrune(r,e)})).catch(r=>{this.log("Error sending prunes to mesh peers",r)}),this.mesh.delete(e))}selectPeersToForward(e,t,r){const s=new Set,i=this.topics.get(e);i!=null&&(this.direct.forEach(a=>{i.has(a)&&t!==a&&!(r?.has(a)??!1)&&s.add(a)}),this.floodsubPeers.forEach(a=>{i.has(a)&&t!==a&&!(r?.has(a)??!1)&&this.score.score(a)>=this.opts.scoreThresholds.publishThreshold&&s.add(a)}));const o=this.mesh.get(e);return o!=null&&o.size>0&&o.forEach(a=>{t!==a&&!(r?.has(a)??!1)&&s.add(a)}),s}selectPeersToPublish(e){const t=new Set,r={direct:0,floodsub:0,mesh:0,fanout:0},s=this.topics.get(e);if(s!=null)if(this.opts.floodPublish)s.forEach(i=>{this.direct.has(i)?(t.add(i),r.direct++):this.score.score(i)>=this.opts.scoreThresholds.publishThreshold&&(t.add(i),r.floodsub++)});else{this.direct.forEach(o=>{s.has(o)&&(t.add(o),r.direct++)}),this.floodsubPeers.forEach(o=>{s.has(o)&&this.score.score(o)>=this.opts.scoreThresholds.publishThreshold&&(t.add(o),r.floodsub++)});const i=this.mesh.get(e);if(i!=null&&i.size>0)i.forEach(o=>{t.add(o),r.mesh++}),i.size<this.opts.D&&this.getRandomGossipPeers(e,this.opts.D-i.size,a=>!i.has(a)&&!this.direct.has(a)&&!this.floodsubPeers.has(a)&&this.score.score(a)>=this.opts.scoreThresholds.publishThreshold).forEach(a=>{t.add(a),r.mesh++});else{const o=this.fanout.get(e);if(o!=null&&o.size>0)o.forEach(a=>{t.add(a),r.fanout++});else{const a=this.getRandomGossipPeers(e,this.opts.D,c=>this.score.score(c)>=this.opts.scoreThresholds.publishThreshold);a.size>0&&(this.fanout.set(e,a),a.forEach(c=>{t.add(c),r.fanout++}))}this.fanoutLastpub.set(e,Date.now())}}return{tosend:t,tosendCount:r}}forwardMessage(e,t,r,s){r!=null&&this.score.deliverMessage(r,e,t.topic);const i=this.selectPeersToForward(t.topic,r,s);i.forEach(o=>{this.sendRpc(o,dr([t]))}),this.metrics?.onForwardMsg(t.topic,i.size)}async publish(e,t,r){const s=Date.now(),i=this.dataTransform!=null?this.dataTransform.outboundTransform(e,t):t;if(this.publishConfig==null)throw Error("PublishError.Uninitialized");const{raw:o,msg:a}=await F9(this.publishConfig,e,t,i),c=await this.msgIdFn(a),l=this.msgIdToStrFn(c),u=r?.ignoreDuplicatePublishError??this.opts.ignoreDuplicatePublishError;if(this.seenCache.has(l)){if(u)return this.metrics?.onPublishDuplicateMsg(e),{recipients:[]};throw Error("PublishError.Duplicate")}const{tosend:h,tosendCount:d}=this.selectPeersToPublish(e),f=this.opts.emitSelf&&this.subscriptions.has(e),p=r?.allowPublishToZeroTopicPeers??this.opts.allowPublishToZeroTopicPeers;if(h.size===0&&!p&&!f)throw Error("PublishError.NoPeersSubscribedToTopic");this.seenCache.put(l),this.mcache.put({msgId:c,msgIdStr:l},o,!0),this.publishedMessageIds.put(l);const m=r?.batchPublish??this.opts.batchPublish,g=dr([o]);if(m)this.sendRpcInBatch(h,g);else for(const b of h)this.sendRpc(b,g)||h.delete(b);const y=Date.now()-s;return this.metrics?.onPublishMsg(e,d,h.size,o.data!=null?o.data.length:0,y),f&&(h.add(this.components.peerId.toString()),super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:this.components.peerId,msgId:l,msg:a}})),super.dispatchEvent(new CustomEvent("message",{detail:a}))),{recipients:Array.from(h.values()).map(b=>Ue(b))}}sendRpcInBatch(e,t){const r=Bn.encode(t),s=lc.single(r);for(const i of e){const o=this.streamsOutbound.get(i);if(o==null){this.log(`Cannot send RPC to ${i} as there is no open stream to it available`),e.delete(i);continue}try{o.pushPrefixed(s)}catch(a){e.delete(i),this.log.error(`Cannot send rpc to ${i}`,a)}this.metrics?.onRpcSent(t,r.length)}}reportMessageValidationResult(e,t,r){let s;if(r===Vt.Accept){if(s=this.mcache.validate(e),s!=null){const{message:o,originatingPeers:a}=s;this.score.deliverMessage(t,e,o.topic),this.forwardMessage(e,s.message,t,a)}}else if(s=this.mcache.remove(e),s!=null){const o=Wd(r),{message:a,originatingPeers:c}=s;this.score.rejectMessage(t,e,a.topic,o);for(const l of c)this.score.rejectMessage(l,e,a.topic,o)}const i=this.score.messageFirstSeenTimestampMs(e);this.metrics?.onReportValidation(s,r,i)}sendGraft(e,t){const s=dr([],{graft:[{topicID:t}]});this.sendRpc(e,s)}async sendPrune(e,t){const s=[await this.makePrune(e,t,this.opts.doPX,!0)],i=dr([],{prune:s});this.sendRpc(e,i)}sendIDontWants(e,t,r){const s=this.mesh.get(t);if(s==null)return;const i=new Set(s);i.delete(r);for(const a of i)this.streamsOutbound.get(a)?.protocol!==qc&&i.delete(a);const o=dr([],{idontwant:[{messageIDs:[e]}]});this.sendRpcInBatch(i,o)}sendRpc(e,t){const r=this.streamsOutbound.get(e);if(r==null)return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`),!1;const s=this.control.get(e);s!=null&&(this.piggybackControl(e,t,s),this.control.delete(e));const i=this.gossip.get(e);i!=null&&(this.piggybackGossip(e,t,i),this.gossip.delete(e));const o=Bn.encode(t);try{r.push(o)}catch(a){return this.log.error(`Cannot send rpc to ${e}`,a),s!=null&&this.control.set(e,s),i!=null&&this.gossip.set(e,i),!1}if(this.metrics?.onRpcSent(t,o.length),t.control?.graft!=null)for(const a of t.control?.graft)a.topicID!=null&&this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:a.topicID,direction:"outbound"}});if(t.control?.prune!=null)for(const a of t.control?.prune)a.topicID!=null&&this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:a.topicID,direction:"outbound"}});return!0}piggybackControl(e,t,r){const s=Zd(t);for(const i of r.graft)i.topicID!=null&&(this.mesh.get(i.topicID)?.has(e)??!1)&&s.control.graft.push(i);for(const i of r.prune)i.topicID!=null&&!(this.mesh.get(i.topicID)?.has(e)??!1)&&s.control.prune.push(i)}piggybackGossip(e,t,r){const s=Zd(t);s.control.ihave=r}async sendGraftPrune(e,t,r){const s=this.opts.doPX,i=!1;for(const[o,a]of e){const c=a.map(h=>({topicID:h}));let l=[];const u=t.get(o);u!=null&&(l=await Promise.all(u.map(async h=>this.makePrune(o,h,s&&!(r.get(o)??!1),i))),t.delete(o)),this.sendRpc(o,dr([],{graft:c,prune:l}))}for(const[o,a]of t){const c=await Promise.all(a.map(async l=>this.makePrune(o,l,s&&!(r.get(o)??!1),i)));this.sendRpc(o,dr([],{prune:c}))}}emitGossip(e){const t=this.mcache.getGossipIDs(new Set(e.keys()));for(const[r,s]of e)this.doEmitGossip(r,s,t.get(r)??[])}doEmitGossip(e,t,r){if(r.length===0||(Ar(r),r.length>us&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",r.length),t.size===0))return;let s=this.opts.Dlazy;const o=this.opts.gossipFactor*t.size;let a=t;o>s&&(s=o),s>a.size?s=a.size:a=Ar(Array.from(a)).slice(0,s),a.forEach(c=>{let l=r;r.length>us&&(l=Ar(l.slice()).slice(0,us)),this.pushGossip(c,{topicID:e,messageIDs:l})})}flush(){for(const[e,t]of this.gossip.entries())this.gossip.delete(e),this.sendRpc(e,dr([],{ihave:t}));for(const[e,t]of this.control.entries()){this.control.delete(e);const r=dr([],{graft:t.graft,prune:t.prune});this.sendRpc(e,r)}}pushGossip(e,t){this.log("Add gossip to %s",e);const r=this.gossip.get(e)??[];this.gossip.set(e,r.concat(t))}async makePrune(e,t,r,s){if(this.score.prune(e,t),this.streamsOutbound.get(e)?.protocol===zd)return{topicID:t,peers:[]};const i=s?this.opts.unsubcribeBackoff:this.opts.pruneBackoff,o=i/1e3;if(this.doAddBackoff(e,t,i),!r)return{topicID:t,peers:[],backoff:o};const a=this.getRandomGossipPeers(t,this.opts.prunePeers,l=>l!==e&&this.score.score(l)>=0),c=await Promise.all(Array.from(a).map(async l=>{const u=Ue(l);let h;try{h=await this.components.peerStore.get(u)}catch(d){if(d.name!=="NotFoundError")throw d}return{peerID:u.toMultihash().bytes,signedPeerRecord:h?.peerRecordEnvelope}}));return{topicID:t,peers:c,backoff:o}}runHeartbeat=()=>{const e=this.metrics?.heartbeatDuration.startTimer();this.heartbeat().catch(t=>{this.log("Error running heartbeat",t)}).finally(()=>{if(e?.(),this.status.code===Dt.started){clearTimeout(this.status.heartbeatTimeout);let t=this.opts.heartbeatInterval-(Date.now()-this.status.hearbeatStartMs)%this.opts.heartbeatInterval;t<this.opts.heartbeatInterval*.25&&(t+=this.opts.heartbeatInterval,this.metrics?.heartbeatSkipped.inc()),this.status.heartbeatTimeout=setTimeout(this.runHeartbeat,t)}})};async heartbeat(){const{D:e,Dlo:t,Dhi:r,Dscore:s,Dout:i,fanoutTTL:o}=this.opts;this.heartbeatTicks++;const a=new Map,c=p=>{let m=a.get(p);return m===void 0&&(m=this.score.score(p),a.set(p,m)),m},l=new Map,u=new Map,h=new Map;this.clearBackoff(),this.peerhave.clear(),this.metrics?.cacheSize.set({cache:"iasked"},this.iasked.size),this.iasked.clear(),this.applyIwantPenalties(),this.idontwantCounts.clear();for(const p of this.idontwants.values())for(const[m,g]of p)this.heartbeatTicks-g>=this.opts.mcacheLength&&p.delete(m);this.heartbeatTicks%this.opts.directConnectTicks===0&&await this.directConnect(),this.fastMsgIdCache?.prune(),this.seenCache.prune(),this.gossipTracer.prune(),this.publishedMessageIds.prune();const d=new Map;this.mesh.forEach((p,m)=>{const g=this.topics.get(m),y=new Set,b=new Set;if(d.set(m,b),g!=null){const _=Ar(Array.from(g)),A=this.backoff.get(m);for(const I of _){const D=this.streamsOutbound.get(I);if(D!=null&&this.multicodecs.includes(D.protocol)&&!p.has(I)&&!this.direct.has(I)){const v=c(I);A?.has(I)!==!0&&v>=0&&y.add(I),v>=this.opts.scoreThresholds.gossipThreshold&&b.add(I)}}}const w=(_,A)=>{this.log("HEARTBEAT: Remove mesh link to %s in %s",_,m),this.addBackoff(_,m),p.delete(_),c(_)>=this.opts.scoreThresholds.gossipThreshold&&b.add(_),this.metrics?.onRemoveFromMesh(m,A,1);const I=u.get(_);I==null?u.set(_,[m]):I.push(m)},k=(_,A)=>{this.log("HEARTBEAT: Add mesh link to %s in %s",_,m),this.score.graft(_,m),p.add(_),b.delete(_),this.metrics?.onAddToMesh(m,A,1);const I=l.get(_);I==null?l.set(_,[m]):I.push(m)};if(p.forEach(_=>{const A=c(_);A<0&&(this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s",_,A,m),w(_,yr.BadScore),h.set(_,!0))}),p.size<t){const _=e-p.size;S9(y,_).forEach(I=>{k(I,_t.NotEnough)})}if(p.size>r){let _=Array.from(p);_.sort((I,D)=>c(D)-c(I)),_=_.slice(0,s).concat(Ar(_.slice(s)));let A=0;if(_.slice(0,e).forEach(I=>{(this.outbound.get(I)??!1)&&A++}),A<i){const I=v=>{const M=_[v];for(let L=v;L>0;L--)_[L]=_[L-1];_[0]=M};if(A>0){let v=A;for(let M=1;M<e&&v>0;M++)(this.outbound.get(_[M])??!1)&&(I(M),v--)}let D=e-A;for(let v=e;v<_.length&&D>0;v++)(this.outbound.get(_[v])??!1)&&(I(v),D--)}_.slice(e).forEach(I=>{w(I,yr.Excess)})}if(p.size>=t){let _=0;if(p.forEach(A=>{(this.outbound.get(A)??!1)&&_++}),_<i){const A=i-_;jl(y,A,D=>this.outbound.get(D)===!0).forEach(D=>{k(D,_t.Outbound)})}}if(this.heartbeatTicks%this.opts.opportunisticGraftTicks===0&&p.size>1){const _=Array.from(p).sort((D,v)=>c(D)-c(v)),A=Math.floor(p.size/2),I=c(_[A]);if(I<this.opts.scoreThresholds.opportunisticGraftThreshold){const D=this.opts.opportunisticGraftPeers,v=jl(y,D,M=>c(M)>I);for(const M of v)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s",M,m),k(M,_t.Opportunistic)}}});const f=Date.now();this.fanoutLastpub.forEach((p,m)=>{p+o<f&&(this.fanout.delete(m),this.fanoutLastpub.delete(m))}),this.fanout.forEach((p,m)=>{const g=this.topics.get(m);p.forEach(k=>{(!(g?.has(k)??!1)||c(k)<this.opts.scoreThresholds.publishThreshold)&&p.delete(k)});const y=this.topics.get(m),b=[],w=new Set;if(d.set(m,w),y!=null){const k=Ar(Array.from(y));for(const _ of k){const A=this.streamsOutbound.get(_);if(A!=null&&this.multicodecs.includes(A.protocol)&&!p.has(_)&&!this.direct.has(_)){const I=c(_);I>=this.opts.scoreThresholds.publishThreshold&&b.push(_),I>=this.opts.scoreThresholds.gossipThreshold&&w.add(_)}}}if(p.size<e){const k=e-p.size;b.slice(0,k).forEach(_=>{p.add(_),w?.delete(_)})}}),this.emitGossip(d),await this.sendGraftPrune(l,u,h),this.flush(),this.mcache.shift(),this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"))}getRandomGossipPeers(e,t,r=()=>!0){const s=this.topics.get(e);if(s==null)return new Set;let i=[];return s.forEach(o=>{const a=this.streamsOutbound.get(o);a!=null&&this.multicodecs.includes(a.protocol)&&r(o)&&i.push(o)}),i=Ar(i),t>0&&i.length>t&&(i=i.slice(0,t)),new Set(i)}onScrapeMetrics(e){e.mcacheSize.set(this.mcache.size),e.mcacheNotValidatedCount.set(this.mcache.notValidatedCount),e.cacheSize.set({cache:"direct"},this.direct.size),e.cacheSize.set({cache:"seenCache"},this.seenCache.size),e.cacheSize.set({cache:"fastMsgIdCache"},this.fastMsgIdCache?.size??0),e.cacheSize.set({cache:"publishedMessageIds"},this.publishedMessageIds.size),e.cacheSize.set({cache:"mcache"},this.mcache.size),e.cacheSize.set({cache:"score"},this.score.size),e.cacheSize.set({cache:"gossipTracer.promises"},this.gossipTracer.size),e.cacheSize.set({cache:"gossipTracer.requests"},this.gossipTracer.requestMsByMsgSize),e.cacheSize.set({cache:"topics"},this.topics.size),e.cacheSize.set({cache:"subscriptions"},this.subscriptions.size),e.cacheSize.set({cache:"mesh"},this.mesh.size),e.cacheSize.set({cache:"fanout"},this.fanout.size),e.cacheSize.set({cache:"peers"},this.peers.size),e.cacheSize.set({cache:"streamsOutbound"},this.streamsOutbound.size),e.cacheSize.set({cache:"streamsInbound"},this.streamsInbound.size),e.cacheSize.set({cache:"acceptFromWhitelist"},this.acceptFromWhitelist.size),e.cacheSize.set({cache:"gossip"},this.gossip.size),e.cacheSize.set({cache:"control"},this.control.size),e.cacheSize.set({cache:"peerhave"},this.peerhave.size),e.cacheSize.set({cache:"outbound"},this.outbound.size);let t=0;const r=Date.now();e.connectedPeersBackoffSec.reset();for(const c of this.backoff.values()){t+=c.size;for(const[l,u]of c.entries())this.peers.has(l)&&e.connectedPeersBackoffSec.observe(Math.max(0,u-r)/1e3)}e.cacheSize.set({cache:"backoff"},t);let s=0;for(const c of this.idontwants.values())s+=c.size;e.cacheSize.set({cache:"idontwants"},s);for(const[c,l]of this.topics)e.topicPeersCount.set({topicStr:c},l.size);for(const[c,l]of this.mesh)e.meshPeerCounts.set({topicStr:c},l.size);const i=[],o=new Map;e.behaviourPenalty.reset();for(const c of this.peers.keys()){const l=this.score.score(c);i.push(l),o.set(c,l),e.behaviourPenalty.observe(this.score.peerStats.get(c)?.behaviourPenalty??0)}e.registerScores(i,this.opts.scoreThresholds),e.registerScorePerMesh(this.mesh,o);const a=D9(this.peers.keys(),this.score.peerStats,this.score.params,this.score.peerIPs,e.topicStrToLabel);e.registerScoreWeights(a)}tagMeshPeer=e=>{const{peerId:t,topic:r}=e.detail;this.components.peerStore.merge(Ue(t),{tags:{[r]:{value:100}}}).catch(s=>{this.log.error("Error tagging peer %s with topic %s",t,r,s)})};untagMeshPeer=e=>{const{peerId:t,topic:r}=e.detail;this.components.peerStore.merge(Ue(t),{tags:{[r]:void 0}}).catch(s=>{this.log.error("Error untagging peer %s with topic %s",t,r,s)})}}function vy(n={}){return e=>new by(e,n)}let r1=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function Ht(n,e,t){if(e==null)return n;if(e.aborted)return Promise.reject(new r1(t?.errorMessage,t?.errorCode,t?.errorName));let r;const s=new r1(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}class Ey{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=ae(),this.haveNext=ae()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=ae(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return await this._push(void 0),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=ae(),await Ht(this.readNext.promise,t?.signal,t)}}function Sy(){return new Ey}let _y=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};class xy extends Error{code;constructor(e,t){super(e),this.code=t}}let ky=class extends xy{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function la(n,e){const t=Sy();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new ge;return{read:async(o,a)=>{a?.signal?.throwIfAborted();let c;const l=new Promise((u,h)=>{c=()=>{h(new ky("Read aborted"))},a?.signal?.addEventListener("abort",c)});try{if(o==null){const{done:h,value:d}=await Promise.race([r.next(),l]);return h===!0?new ge:d}for(;s.byteLength<o;){const{value:h,done:d}=await Promise.race([r.next(),l]);if(d===!0)throw new _y("unexpected end of input");s.append(h)}const u=s.sublist(0,o);return s.consume(o),u}finally{c!=null&&a?.signal?.removeEventListener("abort",c)}},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return n}}}let Iy=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Ay=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Ty=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function Os(n,e={}){const t=la(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=ye(e.maxDataLength));const r=e?.lengthDecoder??ar,s=e?.lengthEncoder??Ze;return{read:async o=>{let a=-1;const c=new ge;for(;;){c.append(await t.read(1,o));try{a=r(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new Iy("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Ty("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new Ay("message length too long");return t.read(a,o)},write:async(o,a)=>{await t.write(new ge(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new ge(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function n1(){const n=ae();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,n.resolve(t)},source:async function*(){yield*await n.promise}()}}function Py(){const n=n1(),e=n1();return[{source:n.source,sink:e.sink},{source:e.source,sink:n.sink}]}const Hi=65535,s1=Hi-16,no=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function Xc(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function i1(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function op(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function wr(n,...e){if(!op(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${n.length}`)}function o1(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Cy(n,e){wr(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const on=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),Dy=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),Ry=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ry)throw new Error("Non little-endian hardware is not supported");function My(n){if(typeof n!="string")throw new Error(`string expected, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function eu(n){if(typeof n=="string")n=My(n);else if(op(n))n=tu(n);else throw new Error(`Uint8Array expected, got ${typeof n}`);return n}function Ly(n,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(n,e)}function Ny(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const By=(n,e)=>(Object.assign(e,n),e);function a1(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;n.setUint32(e+c,o,r),n.setUint32(e+l,a,r)}function tu(n){return Uint8Array.from(n)}function Fs(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}const ap=n=>Uint8Array.from(n.split("").map(e=>e.charCodeAt(0))),Oy=ap("expand 16-byte k"),Fy=ap("expand 32-byte k"),Uy=on(Oy),cp=on(Fy);cp.slice();function he(n,e){return n<<e|n>>>32-e}function ru(n){return n.byteOffset%4===0}const vo=64,$y=16,lp=2**32-1,c1=new Uint32Array;function Vy(n,e,t,r,s,i,o,a){const c=s.length,l=new Uint8Array(vo),u=on(l),h=ru(s)&&ru(i),d=h?on(s):c1,f=h?on(i):c1;for(let p=0;p<c;o++){if(n(e,t,r,u,o,a),o>=lp)throw new Error("arx: counter overflow");const m=Math.min(vo,c-p);if(h&&m===vo){const g=p/4;if(p%4!==0)throw new Error("arx: invalid block position");for(let y=0,b;y<$y;y++)b=g+y,f[b]=d[b]^u[y];p+=vo;continue}for(let g=0,y;g<m;g++)y=p+g,i[y]=s[y]^l[g];p+=m}}function Hy(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:s,counterRight:i,rounds:o}=Ly({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return Xc(s),Xc(o),i1(i),i1(t),(a,c,l,u,h=0)=>{wr(a),wr(c),wr(l);const d=l.length;if(u===void 0&&(u=new Uint8Array(d)),wr(u),Xc(h),h<0||h>=lp)throw new Error("arx: counter overflow");if(u.length<d)throw new Error(`arx: output (${u.length}) is shorter than data (${d})`);const f=[];let p=a.length,m,g;if(p===32)f.push(m=tu(a)),g=cp;else if(p===16&&t)m=new Uint8Array(32),m.set(a),m.set(a,16),g=Uy,f.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${p}`);ru(c)||f.push(c=tu(c));const y=on(m);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(g,y,on(c.subarray(0,16)),y),c=c.subarray(16)}const b=16-s;if(b!==c.length)throw new Error(`arx: nonce must be ${b} or 16 bytes`);if(b!==12){const k=new Uint8Array(12);k.set(c,i?0:12-c.length),c=k,f.push(c)}const w=on(c);return Vy(n,g,y,w,l,u,h,o),Fs(...f),u}}const Je=(n,e)=>n[e++]&255|(n[e++]&255)<<8;class zy{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=eu(e),wr(e,32);const t=Je(e,0),r=Je(e,2),s=Je(e,4),i=Je(e,6),o=Je(e,8),a=Je(e,10),c=Je(e,12),l=Je(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Je(e,16+2*u)}process(e,t,r=!1){const s=r?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],h=o[4],d=o[5],f=o[6],p=o[7],m=o[8],g=o[9],y=Je(e,t+0),b=Je(e,t+2),w=Je(e,t+4),k=Je(e,t+6),_=Je(e,t+8),A=Je(e,t+10),I=Je(e,t+12),D=Je(e,t+14);let v=i[0]+(y&8191),M=i[1]+((y>>>13|b<<3)&8191),L=i[2]+((b>>>10|w<<6)&8191),N=i[3]+((w>>>7|k<<9)&8191),O=i[4]+((k>>>4|_<<12)&8191),P=i[5]+(_>>>1&8191),R=i[6]+((_>>>14|A<<2)&8191),x=i[7]+((A>>>11|I<<5)&8191),E=i[8]+((I>>>8|D<<8)&8191),C=i[9]+(D>>>5|s),T=0,U=T+v*a+M*(5*g)+L*(5*m)+N*(5*p)+O*(5*f);T=U>>>13,U&=8191,U+=P*(5*d)+R*(5*h)+x*(5*u)+E*(5*l)+C*(5*c),T+=U>>>13,U&=8191;let H=T+v*c+M*a+L*(5*g)+N*(5*m)+O*(5*p);T=H>>>13,H&=8191,H+=P*(5*f)+R*(5*d)+x*(5*h)+E*(5*u)+C*(5*l),T+=H>>>13,H&=8191;let W=T+v*l+M*c+L*a+N*(5*g)+O*(5*m);T=W>>>13,W&=8191,W+=P*(5*p)+R*(5*f)+x*(5*d)+E*(5*h)+C*(5*u),T+=W>>>13,W&=8191;let j=T+v*u+M*l+L*c+N*a+O*(5*g);T=j>>>13,j&=8191,j+=P*(5*m)+R*(5*p)+x*(5*f)+E*(5*d)+C*(5*h),T+=j>>>13,j&=8191;let Z=T+v*h+M*u+L*l+N*c+O*a;T=Z>>>13,Z&=8191,Z+=P*(5*g)+R*(5*m)+x*(5*p)+E*(5*f)+C*(5*d),T+=Z>>>13,Z&=8191;let ie=T+v*d+M*h+L*u+N*l+O*c;T=ie>>>13,ie&=8191,ie+=P*a+R*(5*g)+x*(5*m)+E*(5*p)+C*(5*f),T+=ie>>>13,ie&=8191;let ue=T+v*f+M*d+L*h+N*u+O*l;T=ue>>>13,ue&=8191,ue+=P*c+R*a+x*(5*g)+E*(5*m)+C*(5*p),T+=ue>>>13,ue&=8191;let Ie=T+v*p+M*f+L*d+N*h+O*u;T=Ie>>>13,Ie&=8191,Ie+=P*l+R*c+x*a+E*(5*g)+C*(5*m),T+=Ie>>>13,Ie&=8191;let Ae=T+v*m+M*p+L*f+N*d+O*h;T=Ae>>>13,Ae&=8191,Ae+=P*u+R*l+x*c+E*a+C*(5*g),T+=Ae>>>13,Ae&=8191;let De=T+v*g+M*m+L*p+N*f+O*d;T=De>>>13,De&=8191,De+=P*h+R*u+x*l+E*c+C*a,T+=De>>>13,De&=8191,T=(T<<2)+T|0,T=T+U|0,U=T&8191,T=T>>>13,H+=T,i[0]=U,i[1]=H,i[2]=W,i[3]=j,i[4]=Z,i[5]=ie,i[6]=ue,i[7]=Ie,i[8]=Ae,i[9]=De}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,r[0]=e[0]+5,s=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=e[a]+s,s=r[a]>>>13,r[a]&=8191;r[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)r[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|r[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;Fs(r)}update(e){o1(this);const{buffer:t,blockLen:r}=this;e=eu(e);const s=e.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){for(;r<=s-i;i+=r)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Fs(this.h,this.r,this.buffer,this.pad)}digestInto(e){o1(this),Cy(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=r[o]>>>0,e[i++]=r[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function qy(n){const e=(r,s)=>n(s).update(eu(r)).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const Ky=qy(n=>new zy(n));function Wy(n,e,t,r,s,i=20){let o=n[0],a=n[1],c=n[2],l=n[3],u=e[0],h=e[1],d=e[2],f=e[3],p=e[4],m=e[5],g=e[6],y=e[7],b=s,w=t[0],k=t[1],_=t[2],A=o,I=a,D=c,v=l,M=u,L=h,N=d,O=f,P=p,R=m,x=g,E=y,C=b,T=w,U=k,H=_;for(let j=0;j<i;j+=2)A=A+M|0,C=he(C^A,16),P=P+C|0,M=he(M^P,12),A=A+M|0,C=he(C^A,8),P=P+C|0,M=he(M^P,7),I=I+L|0,T=he(T^I,16),R=R+T|0,L=he(L^R,12),I=I+L|0,T=he(T^I,8),R=R+T|0,L=he(L^R,7),D=D+N|0,U=he(U^D,16),x=x+U|0,N=he(N^x,12),D=D+N|0,U=he(U^D,8),x=x+U|0,N=he(N^x,7),v=v+O|0,H=he(H^v,16),E=E+H|0,O=he(O^E,12),v=v+O|0,H=he(H^v,8),E=E+H|0,O=he(O^E,7),A=A+L|0,H=he(H^A,16),x=x+H|0,L=he(L^x,12),A=A+L|0,H=he(H^A,8),x=x+H|0,L=he(L^x,7),I=I+N|0,C=he(C^I,16),E=E+C|0,N=he(N^E,12),I=I+N|0,C=he(C^I,8),E=E+C|0,N=he(N^E,7),D=D+O|0,T=he(T^D,16),P=P+T|0,O=he(O^P,12),D=D+O|0,T=he(T^D,8),P=P+T|0,O=he(O^P,7),v=v+M|0,U=he(U^v,16),R=R+U|0,M=he(M^R,12),v=v+M|0,U=he(U^v,8),R=R+U|0,M=he(M^R,7);let W=0;r[W++]=o+A|0,r[W++]=a+I|0,r[W++]=c+D|0,r[W++]=l+v|0,r[W++]=u+M|0,r[W++]=h+L|0,r[W++]=d+N|0,r[W++]=f+O|0,r[W++]=p+P|0,r[W++]=m+R|0,r[W++]=g+x|0,r[W++]=y+E|0,r[W++]=b+C|0,r[W++]=w+T|0,r[W++]=k+U|0,r[W++]=_+H|0}const Gy=Hy(Wy,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Qy=new Uint8Array(16),l1=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(Qy.subarray(t))},Yy=new Uint8Array(32);function u1(n,e,t,r,s){const i=n(e,t,Yy),o=Ky.create(i);s&&l1(o,s),l1(o,r);const a=new Uint8Array(16),c=Dy(a);a1(c,0,BigInt(s?s.length:0),!0),a1(c,8,BigInt(r.length),!0),o.update(a);const l=o.digest();return Fs(i,a),l}const Xy=n=>(e,t,r)=>(wr(e,32),wr(t),{encrypt(i,o){const a=i.length,c=a+16;o?wr(o,c):o=new Uint8Array(c),n(e,t,i,o,1);const l=u1(n,e,t,o.subarray(0,-16),r);return o.set(l,a),Fs(l),o},decrypt(i,o){const a=i.length,c=a-16;if(a<16)throw new Error("encrypted data must be at least 16 bytes");o?wr(o,c):o=new Uint8Array(c);const l=i.subarray(0,-16),u=i.subarray(-16),h=u1(n,e,t,l,r);if(!Ny(u,h))throw new Error("invalid tag");return n(e,t,l,o,1),Fs(h),o}}),h1=By({blockSize:64,nonceLength:12,tagLength:16},Xy(Gy));function Zy(n,e,t){return ja(n),t===void 0&&(t=new Uint8Array(n.outputLen)),to(n,Vn(t),Vn(e))}const Zc=new Uint8Array([0]),d1=new Uint8Array;function jy(n,e,t,r=32){if(ja(n),_s(r),r>255*n.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(r/n.outputLen);t===void 0&&(t=d1);const i=new Uint8Array(s*n.outputLen),o=to.create(n,e),a=o._cloneInto(),c=new Uint8Array(o.outputLen);for(let l=0;l<s;l++)Zc[0]=l+1,a.update(l===0?d1:c).update(t).update(Zc).digestInto(c),i.set(c,n.outputLen*l),o._cloneInto(a);return o.destroy(),a.destroy(),c.fill(0),Zc.fill(0),i.slice(0,r)}const Jy={hashSHA256(n){return rn(n.subarray())},getHKDF(n,e){const t=Zy(rn,e,n),s=jy(rn,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const n=yo.utils.randomPrivateKey();return{publicKey:yo.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:yo.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,e){return yo.getSharedSecret(n.subarray(),e.subarray())},chaCha20Poly1305Encrypt(n,e,t,r){return h1(r,e,t).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,e,t,r,s){return h1(r,e,t).decrypt(n.subarray(),s)}},ew=Jy;function tw(n){return{generateKeypair:n.generateX25519KeyPair,dh:(e,t)=>n.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const ua=n=>{const e=ct(2);return e[0]=n>>8,e[1]=n,e};ua.bytes=2;const zo=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let e=0;return e+=n[0]<<8,e+=n[1],e}return n.getUint16(0)};zo.bytes=2;function rw(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function up(n,e){!e.enabled||!no||(n?(e(`LOCAL_STATIC_PUBLIC_KEY ${K(n.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${K(n.privateKey,"hex")}`)):e("Missing local static keys."))}function hp(n,e){!e.enabled||!no||(n?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${K(n.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${K(n.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function nw(n,e){!e.enabled||!no||e(n?`REMOTE_STATIC_PUBLIC_KEY ${K(n.subarray(),"hex")}`:"Missing remote static public key.")}function dp(n,e){!e.enabled||!no||e(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${K(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function fp(n,e,t){!t.enabled||!no||(t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&K(n.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&K(e.k,"hex")}`))}function hn(n,e){if(n.length!==e.length)throw new Error("Inputs should have the same length");const t=ct(n.length);for(let r=0;r<n.length;r++)t[r]=n[r]^e[r];return t}class Ii extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Ii.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const sw=0,iw=4294967295,ow="Cipherstate has reached maximum n, a new handshake must be performed";class aw{n;bytes;view;constructor(e=sw){this.n=e,this.bytes=oe(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>iw)throw new Error(ow)}}const xs=oe(0);class Eo{k;n;crypto;constructor(e,t=void 0,r=0){this.crypto=e,this.k=t,this.n=new aw(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),s}}class cw{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const r=V(t,"utf-8");this.h=uw(e,r),this.ck=this.h,this.cs=new Eo(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Eo(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new ge(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,xs);return[new Eo(this.crypto,e),new Eo(this.crypto,t)]}}class lw{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new cw(t,r),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const s=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(s),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class pp extends lw{writeMessageA(e){return new ge(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new ge(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new ge(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Ii(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Ii(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Ii(`handshake stage 2 validation fail: ${t.message}`)}}}function uw(n,e){if(e.length<=32){const t=oe(32);return t.set(e),t}else return n.hash(e)}var ha;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)r.uint32(10),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={webtransportCerthashes:[]},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:{s.webtransportCerthashes.push(t.bytes());break}default:{t.skipType(o&7);break}}}return s})),e),n.encode=t=>ee(t,n.codec()),n.decode=t=>J(t,n.codec())})(ha||(ha={}));var da;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(r.uint32(10),r.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(r.uint32(18),r.bytes(t.identitySig)),t.extensions!=null&&(r.uint32(34),ha.codec().encode(t.extensions,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={identityKey:oe(0),identitySig:oe(0)},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=ha.codec().decode(t,t.uint32());break}default:{t.skipType(o&7);break}}}return s})),e),n.encode=t=>ee(t,n.codec()),n.decode=t=>J(t,n.codec())})(da||(da={}));async function gp(n,e,t){const r=await n.sign(yp(e));return da.encode({identityKey:rr(n.publicKey),identitySig:r,extensions:t})}async function mp(n,e,t){try{const r=da.decode(n),s=Tt(r.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=yp(e);if(!await s.verify(i,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new n6(r.message)}}function yp(n){const e=V("noise-libp2p-static-key:");return n instanceof Uint8Array?We([e,n],e.length+n.length):(n.prepend(e),n)}async function hw(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,u=await gp(i,a.publicKey,l),h=new pp({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});up(h.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await r.write(h.writeMessageA(xs),e),t.trace("Stage 0 - Initiator finished sending first message."),hp(h.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=h.readMessageB(await r.read(e));t.trace("Stage 1 - Initiator received the message."),dp(h.re,t),nw(h.rs,t),t.trace("Initiator going to check remote's signature...");const f=await mp(d,h.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await r.write(h.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[p,m]=h.ss.split();return fp(p,m,t),{payload:f,encrypt:g=>p.encryptWithAd(xs,g),decrypt:(g,y)=>m.decryptWithAd(xs,g,y)}}async function dw(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,u=await gp(i,a.publicKey,l),h=new pp({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});up(h.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await r.read(e)),t.trace("Stage 0 - Responder received first message."),dp(h.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(h.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),hp(h.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const d=h.readMessageC(await r.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const f=await mp(d,h.rs,c),[p,m]=h.ss.split();return fp(p,m,t),{payload:f,encrypt:g=>m.encryptWithAd(xs,g),decrypt:(g,y)=>p.decryptWithAd(xs,g,y)}}const f1=16;function fw(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=s1){let i=s+s1;i>r.length&&(i=r.length);let o;r instanceof Uint8Array?o=n.encrypt(r.subarray(s,i)):o=n.encrypt(r.sublist(s,i)),e?.encryptedPackets.increment(),yield new ge(ua(o.byteLength),o)}}}function pw(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=Hi){let i=s+Hi;if(i>r.length&&(i=r.length),i-f1<s)throw new Error("Invalid chunk");const o=r.sublist(s,i),a=r.subarray(s,i-f1);try{const c=n.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class gw{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:r,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??ew;this.crypto=tw(c),this.extensions=s,this.metrics=a?rw(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??oe(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[rt]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=Os(e,{lengthEncoder:ua,lengthDecoder:zo,maxDataLength:Hi}),s=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=Tt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Ms(o)}}async secureInbound(e,t){const r=Os(e,{lengthEncoder:ua,lengthDecoder:zo,maxDataLength:Hi}),s=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=Tt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Ms(o)}}async performHandshakeInitiator(e,t,r,s){let i;try{i=await hw({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(o){throw this.metrics?.xxHandshakeErrors.increment(),o}return i}async performHandshakeResponder(e,t,r,s){let i;try{i=await dw({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(o){throw this.metrics?.xxHandshakeErrors.increment(),o}return i}async createSecureConnection(e,t){const[r,s]=Py(),i=e.unwrap();return await Bt(r,fw(t,this.metrics),i,o=>Fi(o,{lengthDecoder:zo}),pw(t,this.metrics),r),s}}function wh(n={}){return e=>new gw(e,n)}function wp(n){if(n!=null){if(typeof n[Symbol.iterator]=="function")return n[Symbol.iterator]();if(typeof n[Symbol.asyncIterator]=="function")return n[Symbol.asyncIterator]();if(typeof n.next=="function")return n}throw new Error("argument is not an iterator or iterable")}class bs extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class bp extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class vp extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class mw extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class yw extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class ww extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class bw extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class Ep extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const vw=new Set([bs.name,bp.name,vp.name,yw.name,ww.name,bw.name,Ep.name]),bh=256*1024,Ew=16*1024*1024,Sw={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:bh,maxStreamWindowSize:Ew,maxMessageSize:64*1024};function _w(n){if(n.keepAliveInterval<=0)throw new B("keep-alive interval must be positive");if(n.maxInboundStreams<0)throw new B("max inbound streams must be larger or equal 0");if(n.maxOutboundStreams<0)throw new B("max outbound streams must be larger or equal 0");if(n.initialStreamWindowSize<bh)throw new B("InitialStreamWindowSize must be larger or equal 256 kB");if(n.maxStreamWindowSize<n.initialStreamWindowSize)throw new B("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(n.maxStreamWindowSize>2**32-1)throw new B("MaxStreamWindowSize must be less than equal MAX_UINT32");if(n.maxMessageSize<1024)throw new B("MaxMessageSize must be greater than a kilobyte")}var qe;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(qe||(qe={}));var Ne;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(Ne||(Ne={}));Object.values(Ne).filter(n=>typeof n!="string");const xw=0;var gr;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(gr||(gr={}));const Ai=12,p1=2**24;function kw(n){if(n[0]!==xw)throw new bs("Invalid frame version");return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*p1+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*p1+(n[9]<<16)+(n[10]<<8)+n[11]}}let Iw=class{source;buffer;frameInProgress;constructor(e){this.source=Aw(e),this.buffer=new ge,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:r,length:s}=t;r===qe.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new mw("decoding frame already in progress");if(this.buffer.length<Ai)return;const e=kw(this.buffer.subarray(0,Ai));return this.buffer.consume(Ai),e}async readBytes(e){if(this.buffer.length<e){for await(const r of this.source)if(this.buffer.append(r),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}};function Aw(n){if(n[Symbol.iterator]!==void 0){const e=n[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(n[Symbol.asyncIterator]!==void 0){const e=n[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function g1(n){const e=new Uint8Array(Ai);return e[1]=n.type,e[2]=n.flag>>>8,e[3]=n.flag,e[4]=n.streamID>>>24,e[5]=n.streamID>>>16,e[6]=n.streamID>>>8,e[7]=n.streamID,e[8]=n.length>>>24,e[9]=n.length>>>16,e[10]=n.length>>>8,e[11]=n.length,e}function Tw(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function Sp(n,e){const t=wp(n).return?.();Tw(t)&&t.catch(r=>{e.error("could not cause iterator to return",r)})}const Pw=5e3;function jc(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class vh{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=ae(),this.closed=ae(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??Pw,this.onEnd=e.onEnd,this.onCloseRead=e?.onCloseRead,this.onCloseWrite=e?.onCloseWrite,this.onReset=e?.onReset,this.onAbort=e?.onAbort,this.source=this.streamSource=_r({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Nl(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);jc(s)&&await s}const r=()=>{Sp(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new ge(s):s;const i=this.sendData(s,t);jc(i)&&(this.sendingData=ae(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await Ht(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await Ht(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await Ht(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Ht(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();jc(t)&&t.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new i6("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function Eh(n){const[e,t]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>e.next(),push:s=>{r.push(s)},next:()=>r.length>0?{done:!1,value:r.shift()}:e.next(),[t](){return this}}}function Cw(n){return n[Symbol.asyncIterator]!=null}function m1(n){return n?.then!=null}function fa(n,e){let t=0;if(Cw(n))return async function*(){for await(const c of n){const l=e(c,t++);m1(l)&&await l,yield c}}();const r=Eh(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(const c of r){const l=e(c,t++);m1(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of r)a(c,t++),yield c}()}var Jt;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished"})(Jt||(Jt={}));class Dw extends vh{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=Jt.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=bh,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=fa(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-Ai,e.length),s=this.getSendFlags();this.sendFrame({type:qe.Data,flag:s,streamID:this._id,length:r},e.sublist(0,r)),this.sendWindowCapacity-=r,e.consume(r)}}async sendReset(){this.sendFrame({type:qe.WindowUpdate,flag:Ne.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|Ne.FIN;this.sendFrame({type:qe.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,r;const s=()=>{this.status==="open"||this.status==="closing"?r(new Un("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new Ep("Receive window exceeded");const r=await t();this.recvWindowCapacity-=e.length,this.sourcePush(r)}processFlags(e){(e&Ne.ACK)===Ne.ACK&&this.state===Jt.SYNSent&&(this.state=Jt.Established),(e&Ne.FIN)===Ne.FIN&&this.remoteCloseWrite(),(e&Ne.RST)===Ne.RST&&this.reset()}getSendFlags(){switch(this.state){case Jt.Init:return this.state=Jt.SYNSent,Ne.SYN;case Jt.SYNReceived:return this.state=Jt.Established,Ne.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),r=this.getRTT();if(e===0&&r>-1&&t-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:qe.WindowUpdate,flag:e,streamID:this._id,length:s})}}const _p="/yamux/1.0.0",Rw=500;class Mw{protocol=_p;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[rt]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new Lw(this._components,{...this._init,...e})}}class Lw{protocol=_p;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...Sw,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),_w(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=_r({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{const s=()=>{const a=wp(r);if(a.return!=null){const c=a.return();Nw(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let i,o;try{const a=new Iw(r);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=gr.NormalTermination}catch(a){vw.has(a.name)?(this.log?.error("protocol error in sink",a),i=gr.ProtocolError):(this.log?.error("internal error in sink",a),i=gr.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new ms("Muxer closed remotely");if(this.localGoAway!==void 0)throw new ms("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Vu("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const r=this._newStream(t,e,Jt.Init,"outbound");return this._streams.set(t,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new ms("Muxer closed remotely");if(this.localGoAway!==void 0)throw new ms("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new ms("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??gr.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const r=AbortSignal.timeout(Rw);e={...e,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(r){this.abort(r)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??gr.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const r of this._streams.values())r.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,r,s){if(this._streams.get(e)!=null)throw new B("Stream already exists with that id");const i=new Dw({id:e.toString(),name:t,state:r,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,r)=>{this.closeController.signal.addEventListener("abort",r,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(r=>{t=setTimeout(r,this.config.keepAliveInterval)})]),this.ping().catch(r=>this.log?.error("ping error: %s",r))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:r,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),r===0)switch(s){case qe.Ping:{this.handlePing(e);return}case qe.GoAway:{this.handleGoAway(i);return}default:throw new bs("Invalid frame type")}else switch(e.type){case qe.Data:case qe.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new bs("Invalid frame type")}}handlePing(e){if(e.flag===Ne.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,Ne.ACK);else if(e.flag===Ne.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new bs("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new bp("ping not requested");if(this.activePing.id!==e)throw new vp("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",gr[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:r,flag:s,type:i}=e;(s&Ne.SYN)===Ne.SYN&&this.incomingStream(r);const o=this._streams.get(r);if(o===void 0){if(i===qe.Data){if(this.log?.("discarding data for stream id=%s",r),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",r);return}switch(i){case qe.WindowUpdate:{o.handleWindowUpdate(e);return}case qe.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new B("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:qe.WindowUpdate,flag:Ne.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:qe.WindowUpdate,flag:Ne.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,Jt.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===qe.Data){if(t===void 0)throw new bs("Invalid frame");this.source.push(new ge(g1(e),t))}else this.source.push(g1(e))}sendPing(e,t=Ne.SYN){t===Ne.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:qe.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=gr.NormalTermination){this.log?.("sending GoAway reason=%s",gr[e]),this.localGoAway=e,this.sendFrame({type:qe.GoAway,flag:0,streamID:0,length:e})}}function Nw(n){return n!=null&&typeof n.then=="function"}function xp(n={}){return e=>new Mw(e,n)}var pa;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(r.uint32(26),r.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:oe(0),payloadType:oe(0),payload:oe(0),signature:oe(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(pa||(pa={}));class Bw extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class br{static createFromProtobuf=async e=>{const t=pa.decode(e),r=Tt(t.publicKey);return new br({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const r=e.domain,s=e.codec,i=e.marshal(),o=y1(r,s,i),a=await t.sign(o.subarray());return new br({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{const r=await br.createFromProtobuf(e);if(!await r.validate(t))throw new Bw("Envelope signature is not valid for the given domain");return r};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=r,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=pa.encode({publicKey:rr(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return pe(this.marshal(),e.marshal())}async validate(e){const t=y1(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const y1=(n,e,t)=>{const r=V(n),s=Ze(r.byteLength),i=Ze(e.length),o=Ze(t.length);return new ge(s,r,i,e,o,t)};function Ow(n,e){const t=(r,s)=>r.toString().localeCompare(s.toString());return n.length!==e.length?!1:(e.sort(t),n.sort(t).every((r,s)=>e[s].equals(r)))}function Fw(n){n=nu(n);const e=[],t=[];let r=null;const s=n.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=ne(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw new Ap("invalid address: "+n);if(a.path===!0){r=nu(s.slice(i).join("/")),e.push([a.code,Jd(a.code,r)]),t.push([a.code,r]);break}const c=Jd(a.code,s[i]);e.push([a.code,c]),t.push([a.code,mh(a.code,c)])}return{string:kp(t),bytes:Ip(e),tuples:e,stringTuples:t,path:r}}function w1(n){const e=[],t=[];let r=null,s=0;for(;s<n.length;){const i=ar(n,s),o=ye(i),a=ne(i),c=Uw(a,n.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}const l=n.slice(s+o,s+o+c);if(s+=c+o,s>n.length)throw new Ap("Invalid address Uint8Array: "+K(n,"base16"));e.push([i,l]);const u=mh(i,l);if(t.push([i,u]),a.path===!0){r=u;break}}return{bytes:Uint8Array.from(n),string:kp(t),tuples:e,stringTuples:t,path:r}}function kp(n){const e=[];return n.map(t=>{const r=ne(t[0]);return e.push(r.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),nu(e.join("/"))}function Ip(n){return We(n.map(e=>{const t=ne(e[0]);let r=Uint8Array.from(Ze(t.code));return e.length>1&&e[1]!=null&&(r=We([r,e[1]])),r}))}function Uw(n,e){if(n.size>0)return n.size/8;if(n.size===0)return 0;{const t=ar(e instanceof Uint8Array?e:Uint8Array.from(e));return t+ye(t)}}function nu(n){return"/"+n.trim().split("/").filter(e=>e).join("/")}class Ap extends Error{static name="ParseError";name="ParseError";constructor(e){super(`Error parsing address: ${e}`)}}const $w=Symbol.for("nodejs.util.inspect.custom"),Tp=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Vw=[ne("dns").code,ne("dns4").code,ne("dns6").code,ne("dnsaddr").code];class Hw extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class vs{bytes;#e;#t;#r;#s;[Tp]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=w1(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=Fw(e)}else if(uc(e))t=w1(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#s=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,r,s,i="";const o=ne("tcp"),a=ne("udp"),c=ne("ip4"),l=ne("ip6"),u=ne("dns6"),h=ne("ip6zone");for(const[f,p]of this.stringTuples())f===h.code&&(i=`%${p??""}`),Vw.includes(f)&&(t=o.name==="tcp"?"tcp":"udp",s=443,r=`${p??""}${i}`,e=f===u.code?6:4),(f===o.code||f===a.code)&&(t=ne(f).name==="tcp"?"tcp":"udp",s=parseInt(p??"")),(f===c.code||f===l.code)&&(t=ne(f).name==="tcp"?"tcp":"udp",r=`${p??""}${i}`,e=f===l.code?6:4);if(e==null||t==null||r==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},ne(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>ne(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new vs(e),new vs(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),r=this.toString(),s=r.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new vs(r.slice(0,s))}decapsulateCode(e){const t=this.tuples();for(let r=t.length-1;r>=0;r--)if(t[r][0]===e)return new vs(Ip(t.slice(0,r)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([r,s])=>{r===Vi.p2p.code&&e.push([r,s]),r===Vi["p2p-circuit"].code&&(e=[])});const t=e.pop();if(t?.[1]!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?K(ze.decode(`z${r}`),"base58btc"):K(Y.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#s}equals(e){return pe(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const r=Sh.get(t.name);if(r==null)throw new Hw(`no available resolver for ${t.name}`);return(await r(this,e)).map(i=>re(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[$w](){return`Multiaddr(${this.#e})`}}const Sh=new Map;function uc(n){return!!n?.[Tp]}function re(n){return new vs(n)}const zw="libp2p-peer-record",qw=Uint8Array.from([3,1]);var ga;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:oe(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)})(n.AddressInfo||(n.AddressInfo={}));let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(r.uint32(16),r.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)r.uint32(26),n.AddressInfo.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={peerId:oe(0),seq:0n,addresses:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new _e('Decode error - map field "addresses" had too many elements');i.addresses.push(n.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(ga||(ga={}));class Lt{static createFromProtobuf=e=>{const t=ga.decode(e),r=Ft(je(t.peerId)),s=(t.addresses??[]).map(o=>re(o.multiaddr)),i=t.seq;return new Lt({peerId:r,multiaddrs:s,seqNumber:i})};static DOMAIN=zw;static CODEC=qw;peerId;multiaddrs;seqNumber;domain=Lt.DOMAIN;codec=Lt.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:s}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ga.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Lt)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!Ow(this.multiaddrs,e.multiaddrs))}}function pt(n,e){const t=Os(n,e),r={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>r.read(s,i),write:async(i,o)=>r.write(i,s,o),writeV:async(i,o)=>r.writeV(i,s,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}const Kw=290,Ww=1,Pp=2e3,Gw=100,So=`${Wa}-circuit-relay`;BigInt(1<<17);const ma="/libp2p/circuit/relay/0.2.0/hop",b1="/libp2p/circuit/relay/0.2.0/stop",v1=300,Qw=4096,Yw=.001;var Us;(function(n){(function(r){r.RESERVE="RESERVE",r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.RESERVE=0]="RESERVE",r[r.CONNECT=1]="CONNECT",r[r.STATUS=2]="STATUS"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),$s.codec().encode(r.peer,s)),r.reservation!=null&&(s.uint32(26),ya.codec().encode(r.reservation,s)),r.limit!=null&&(s.uint32(34),Vs.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(40),ht.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=$s.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=ya.codec().decode(r,r.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=Vs.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=ht.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(Us||(Us={}));var Cr;(function(n){(function(r){r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.CONNECT=0]="CONNECT",r[r.STATUS=1]="STATUS"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),$s.codec().encode(r.peer,s)),r.limit!=null&&(s.uint32(26),Vs.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(32),ht.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=$s.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=Vs.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=ht.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(Cr||(Cr={}));var $s;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.id!=null&&t.id.byteLength>0&&(r.uint32(10),r.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={id:oe(0),addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new _e('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})($s||($s={}));var ya;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.expire!=null&&t.expire!==0n&&(r.uint32(8),r.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);t.voucher!=null&&(r.uint32(26),ba.codec().encode(t.voucher,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={expire:0n,addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new _e('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=ba.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(ya||(ya={}));var Vs;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.duration!=null&&(r.uint32(8),r.uint32(t.duration)),t.data!=null&&(r.uint32(16),r.uint64(t.data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Vs||(Vs={}));var ht;(function(n){n.UNUSED="UNUSED",n.OK="OK",n.RESERVATION_REFUSED="RESERVATION_REFUSED",n.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",n.PERMISSION_DENIED="PERMISSION_DENIED",n.CONNECTION_FAILED="CONNECTION_FAILED",n.NO_RESERVATION="NO_RESERVATION",n.MALFORMED_MESSAGE="MALFORMED_MESSAGE",n.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(ht||(ht={}));var su;(function(n){n[n.UNUSED=0]="UNUSED",n[n.OK=100]="OK",n[n.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",n[n.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",n[n.PERMISSION_DENIED=202]="PERMISSION_DENIED",n[n.CONNECTION_FAILED=203]="CONNECTION_FAILED",n[n.NO_RESERVATION=204]="NO_RESERVATION",n[n.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",n[n.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(su||(su={}));(function(n){n.codec=()=>At(su)})(ht||(ht={}));var wa;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.relay!=null&&t.relay.byteLength>0&&(r.uint32(10),r.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(r.uint32(18),r.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(r.uint32(24),r.uint64(t.expiration)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={relay:oe(0),peer:oe(0),expiration:0n},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(wa||(wa={}));var ba;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&(r.uint32(26),wa.codec().encode(t.payload,r)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:oe(0),payloadType:oe(0),signature:oe(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=wa.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(ba||(ba={}));const Xw=n=>n.toString().split("/").slice(1),so=n=>({match:e=>e.length<1?!1:n(e[0])?e.slice(1):!1,pattern:"fn"}),ce=n=>({match:e=>so(t=>t===n).match(e),pattern:n}),ti=()=>({match:n=>so(e=>typeof e=="string").match(n),pattern:"{string}"}),hc=()=>({match:n=>so(e=>!isNaN(parseInt(e))).match(n),pattern:"{number}"}),Se=()=>({match:n=>{if(n.length<2||n[0]!=="p2p"&&n[0]!=="ipfs")return!1;if(n[1].startsWith("Q")||n[1].startsWith("1"))try{ze.decode(`z${n[1]}`)}catch{return!1}else return!1;return n.slice(2)},pattern:"/p2p/{peerid}"}),va=()=>({match:n=>{if(n.length<2||n[0]!=="certhash")return!1;try{th.decode(n[1])}catch{return!1}return n.slice(2)},pattern:"/certhash/{certhash}"}),we=n=>({match:e=>{const t=n.match(e);return t===!1?e:t},pattern:`optional(${n.pattern})`}),gt=(...n)=>({match:e=>{let t;for(const r of n){const s=r.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${n.map(e=>e.pattern).join(", ")})`}),le=(...n)=>({match:e=>{for(const t of n){const r=t.match(e);if(r===!1)return!1;e=r}return e},pattern:`and(${n.map(e=>e.pattern).join(", ")})`});function Ce(...n){function e(s){let i=Xw(s);for(const o of n){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function r(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:n,matches:t,exactMatch:r}}const dc=le(ce("dns4"),ti()),fc=le(ce("dns6"),ti()),pc=le(ce("dnsaddr"),ti()),_h=le(ce("dns"),ti());Ce(dc,we(Se()));Ce(fc,we(Se()));Ce(pc,we(Se()));const Cp=Ce(gt(_h,pc,dc,fc),we(Se())),Dp=le(ce("ip4"),so(Bs)),Rp=le(ce("ip6"),so(gh)),xh=gt(Dp,Rp),Lr=gt(xh,_h,dc,fc,pc),Zw=Ce(gt(xh,le(gt(_h,pc,dc,fc),we(Se()))));Ce(Dp);Ce(Rp);const jw=Ce(xh),kh=le(Lr,ce("tcp"),hc()),io=le(Lr,ce("udp"),hc()),Ea=Ce(le(kh,we(Se())));Ce(io);const Ih=le(io,ce("quic"),we(Se())),gc=le(io,ce("quic-v1"),we(Se())),Jw=gt(Ih,gc);Ce(Ih);const eb=Ce(gc),iu=gt(Lr,kh,io,Ih,gc),Mp=gt(le(iu,ce("ws"),we(Se()))),zi=Ce(Mp),Lp=gt(le(iu,ce("wss"),we(Se())),le(iu,ce("tls"),we(le(ce("sni"),ti())),ce("ws"),we(Se()))),Sa=Ce(Lp),Np=le(io,ce("webrtc-direct"),we(va()),we(va()),we(Se())),ou=Ce(Np),Bp=le(gc,ce("webtransport"),we(va()),we(va()),we(Se())),E1=Ce(Bp),_a=gt(Mp,Lp,le(kh,we(Se())),le(Jw,we(Se())),le(Lr,we(Se())),Np,Bp,Se()),Op=Ce(_a),tb=le(_a,ce("p2p-circuit"),Se()),dn=Ce(tb),rb=gt(le(_a,ce("p2p-circuit"),ce("webrtc"),we(Se())),le(_a,ce("webrtc"),we(Se())),le(ce("webrtc"),we(Se()))),au=Ce(rb),nb=gt(le(Lr,ce("tcp"),hc(),ce("http"),we(Se())),le(Lr,ce("http"),we(Se()))),sb=Ce(nb),ib=gt(le(Lr,ce("tcp"),gt(le(ce("443"),ce("http")),le(hc(),ce("https"))),we(Se())),le(Lr,ce("tls"),ce("http"),we(Se())),le(Lr,ce("https"),we(Se()))),ob=Ce(ib),ab=gt(le(ce("memory"),ti(),we(Se())));Ce(ab);function be(n){const e=new globalThis.AbortController;function t(){e.abort();for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of n){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function r(){for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=r,s}class S1 extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class cb extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class lb extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function _1(n){const e=n*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class x1{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const Fp=Ce(le(Op.matchers[0],ce("p2p-circuit"))),Up=Ce(ce("p2p-circuit"));function Ti(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),s=r.value;return r.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Jc(n){const e=je(ze.decode(`z${n}`));return Ft(e)}class bn{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Ti(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,r)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Ti(this.map.values(),e=>e.key)}values(){return Ti(this.map.values(),e=>e.value)}get size(){return this.map.size}}class sr{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Ti(this.set.entries(),e=>{const t=Jc(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=Jc(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return Ti(this.set.values(),e=>Jc(e))}intersection(e){const t=new sr;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new sr;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new sr;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}}function ub(){return new sr}const Ah={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},$p={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Vp=new globalThis.TextEncoder;function hb(n,e){const t=Ah[e];let r=$p[e];for(let s=0;s<n.length;s++)r^=BigInt(n[s]),r=BigInt.asUintN(e,r*t);return r}function db(n,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=Ah[e];let s=$p[e],i=n;for(;i.length>0;){const o=Vp.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*r)}return s}function fb(n,{size:e=32,utf8Buffer:t}={}){if(!Ah[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(t)return db(n,e,t);n=Vp.encode(n)}return hb(n,e)}const Th={hash:n=>Number(fb(n,{size:32})),hashV:(n,e)=>pb(Th.hash(n,e))};function pb(n){let e=n.toString(16);return e.length%2===1&&(e=`0${e}`),V(e,"base16")}const Hp=64;class Rn{fp;h;seed;constructor(e,t,r,s=2){if(s>Hp)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,r),o=oe(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?pe(this.fp,e.fp):!1}}function xa(n,e){return Math.floor(Math.random()*(e-n))+n}class _o{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Rn))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Rn))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Rn))throw new TypeError("Invalid Fingerprint");const t=xa(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Rn))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(r=>e.equals(r));return t>-1?(this.contents[t]=null,!0):!1}}const gb=500;class k1{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Th,this.seed=e.seed??xa(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=V(e));const t=new Rn(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=(r^t.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new _o(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new _o(this.bucketSize)),this.buckets[r].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[r,s];let o=i[xa(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new _o(this.bucketSize));for(let a=0;a<gb;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new _o(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=V(e));const t=new Rn(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.has(t)??!1;if(s)return s;const i=(r^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=V(e));const t=new Rn(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.remove(t)??!1;if(s)return this.count--,s;const i=(r^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const mb={1:.5,2:.84,4:.95,8:.98};function yb(n=.001){return n>.002?2:n>1e-5?4:8}function wb(n,e=.001){const t=yb(e),r=mb[t],s=Math.round(n/r),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Hp);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class bb{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Th,this.seed=e.seed??xa(0,Math.pow(2,10)),this.filterSeries=[new k1({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=V(e)),this.has(e))return!0;let t=this.filterSeries.find(r=>r.reliable);if(t==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new k1({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=V(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=V(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Wn(n,e=.001,t){return new bb({...wb(n,e)})}class vb{filter;constructor(e,t){this.filter=Wn(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function Eb(n,e=.001){return new vb(n,e)}class Sb extends bn{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function zp(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new Sb({name:e,metrics:t}):r=new bn,r}function I1(n){const{stream:e,remoteAddr:t,logger:r,onDataRead:s,onDataWrite:i}=n,o=r.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async p=>{await l(p),f(!0)};const u=e.abort.bind(e);e.abort=p=>{u(p),f(!0)};const h=e.sink.bind(e);e.sink=async p=>{try{await h(Bt(p,m=>fa(m,g=>i?.(g))))}catch(m){m.type!=="aborted"&&o.error("%s error in sink",t,m)}finally{c=!0,f()}};const d={log:o,sink:e.sink,source:async function*(){try{for await(const p of e.source)s?.(p),yield p}finally{a=!0,f()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function f(p){p===!0&&(a=!0,c=!0),a&&c&&d.timeline.close==null&&(d.timeline.close=Date.now())}return d}class Q extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let _b=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function zt(n,e,t,r){const s=new _b(r?.errorMessage,r?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",u),n.removeEventListener(e,c),r?.errorEvent!=null&&n.removeEventListener(r.errorEvent,l)}const c=h=>{try{if(r?.filter?.(h)===!1)return}catch(d){a(),o(d);return}a(),i(h)},l=h=>{a(),o(h.detail)},u=()=>{a(),o(s)};t?.addEventListener("abort",u),n.addEventListener(e,c),r?.errorEvent!=null&&n.addEventListener(r.errorEvent,l)})}class xb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class kb extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class Ib{deferred;signal;constructor(e){this.signal=e,this.deferred=ae(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Un)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function Ab(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Tb{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=Ab(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new Un),this.cleanup())}async join(e={}){const t=new Ib(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Ht(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class Gn extends Ke{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[]}tryToStartAnother(){if(this.size===0)return queueMicrotask(()=>{this.safeDispatchEvent("empty")}),this.running===0&&queueMicrotask(()=>{this.safeDispatchEvent("idle")}),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new kb;const r=new Tb(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Un)}),this.clear()}async onEmpty(e){this.size!==0&&await zt(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await zt(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await zt(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=_r({objectMode:!0}),r=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{r(c.detail)},o=()=>{r()},a=()=>{r(new Un("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),r()}}}class fn extends Gn{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class Pb extends Ke{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(ma,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[r=>r.protocols.includes(ma)],orders:[()=>Math.random()<.5?1:-1,(r,s)=>{const i=A1(r),o=A1(s);return i>o?-1:o>i?1:0}]});for(const r of e)this.log.trace("found relay peer %p in peer store",r.id),this.safeDispatchEvent("relay:discover",{detail:r.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new fn({concurrency:5});this.log("start random walk");for await(const r of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",r.id),t.has(r.id)){this.log.trace("random peer %p was already in queue",r.id);continue}if(this.connectionManager.getConnections(r.id)?.length>0){this.log.trace("random peer %p was already connected",r.id);continue}if(!await this.connectionManager.isDialable(r.multiaddrs)){this.log.trace("random peer %p was not dialable",r.id,r.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",r.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",r.id,t.size,t.running),t.add(async()=>{const s=be([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(r.id,{signal:s})}finally{s.clear()}},{peerId:r.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",r.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function A1(n){const e=n.metadata.get("last-dial-success");return e==null?0:new Date(K(e)).getTime()}class Cb extends Ke{peerId;connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??Pp,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(this.log("listen on %a",e),Up.exactMatch(e))this.reservationId=this.reservationStore.reserveRelay();else if(Fp.exactMatch(e)){const t=AbortSignal.timeout(this.listenTimeout),r=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(r,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Bl(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>re(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Db(n){return new Cb(n)}const Rb="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Mb=(n=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(n|=0));for(;n--;)e+=Rb[t[n]&63];return e};const Lb=60*1e3*10,Nb=60*1e3*5,Bb=30*1e3;class Ob extends Ke{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new bn,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??Gw,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??Pp,this.started=!1,this.relayFilter=Wn(100),this.reserveQueue=new fn({concurrency:t?.reservationConcurrency??Ww,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",r=>{[...this.reservations.values()].find(i=>i.connection===r.detail.id)!=null&&this.#t(r.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",r.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(So)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[So]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=Mb();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Bl("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new lb("The reservation queue is full");const r=this.reserveQueue.find(e);if(r!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),r.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Bl("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const p=this.connectionManager.getConnections(e);let m=!1;if(p.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),p.map(g=>g.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&_1(i.reservation.expire)>Lb)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new S1("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(dn.matches(a.remoteAddr))throw new cb("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=_1(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-Nb,Bb),Math.pow(2,31)-1),h=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async p=>{this.log.error("could not refresh reservation to relay %p - %e",e,p),await this.#t(e)}).catch(p=>{this.log.error("could not remove expired reservation to relay %p - %e",e,p)})},u);let d;if(t==="discovered"){const p=this.pendingReservations.pop();if(p==null)throw new S1("Made reservation on relay but did not need any more discovered relays");d={timeout:h,reservation:c,type:t,connection:a.id,id:p}}else d={timeout:h,reservation:c,type:t,connection:a.id};this.reservations.set(e,d),await this.peerStore.merge(e,{tags:{[So]:{value:1,ttl:l}}}),this.#r();const f={relay:e,details:d};return this.safeDispatchEvent("relay:created-reservation",{detail:f}),f}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,r)=>(r.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const r=await e.newStream(ma,t),i=pt(r).pb(Us);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:Us.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw r.abort(c),c}finally{r.status!=="closed"&&await r.close(t)}if(this.log.trace("read response %o",o),o.status===ht.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=re(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=re(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>re(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[So]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Wn(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const Fb=n=>{if(n.peer==null)return!1;try{n.peer.addrs.forEach(re)}catch{return!1}return!0},el={maxInboundStopStreams:v1,maxOutboundStopStreams:v1,stopTimeout:3e4};class Ub{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;stopTimeout;started;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??el.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??el.maxOutboundStopStreams,this.stopTimeout=t.stopTimeout??el.stopTimeout,this.discovery=new Pb(e,{filter:t.discoveryFilter??Eb(Qw,Yw)}),this.discovery.addEventListener("relay:discover",r=>{this.reservationStore.addRelay(r.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",r.detail,s)})}),this.reservationStore=new Ob(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[rt]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[cn](){return this.discovery!=null?["@libp2p/identify"]:[]}[Ga]=!0;isStarted(){return this.started}async start(){await this.registrar.handle(b1,e=>{this.onStop(e).catch(t=>{this.log.error("error while handling STOP protocol",t),e.stream.abort(t)})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Nr(this.discovery,this.reservationStore),this.started=!0}async stop(){await wn(this.discovery,this.reservationStore),await this.registrar.unhandle(b1),this.started=!1}async dial(e,t){if(e.protoCodes().filter(f=>f===Kw).length!==1){const f="Invalid circuit relay address";throw this.log.error(f,e),new Ei(f)}const r=e.toString().split("/p2p-circuit"),s=re(r[0]),i=re(r[r.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const f=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${f}`),new Ei(`C${f}`)}const c=Ue(o),l=Ue(a);let h=this.connectionManager.getConnections(c)[0];h==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new Q("circuit-relay:open-connection")),h=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new Q("circuit-relay:reuse-connection"));let d;try{t.onProgress?.(new Q("circuit-relay:open-hop-stream")),d=await h.newStream(ma,t);const f=pt(d),p=f.pb(Us);t.onProgress?.(new Q("circuit-relay:write-connect-message")),await p.write({type:Us.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[re(i).bytes]}},t),t.onProgress?.(new Q("circuit-relay:read-connect-response"));const m=await p.read(t);if(m.status!==ht.OK)throw new Pe(`failed to connect via relay with status ${m?.status?.toString()??"undefined"}`);const g=new x1(m.limit),y=I1({stream:f.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:g.onData,onDataWrite:g.onData});return this.log("new outbound relayed connection %a",y.remoteAddr),await this.upgrader.upgradeOutbound(y,{...t,limits:g.getLimits()})}catch(f){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,f),d?.abort(f),f}}createListener(e){return Db({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Fp.exactMatch(t)||Up.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>dn.exactMatch(t))}async onStop({connection:e,stream:t}){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const r=AbortSignal.timeout(this.stopTimeout),s=pt(t).pb(Cr),i=await s.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:Cr.Type.STATUS,status:ht.MALFORMED_MESSAGE},{signal:r}),await t.close();return}if(i.type!==Cr.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:Cr.Type.STATUS,status:ht.UNEXPECTED_MESSAGE},{signal:r}),await t.close();return}if(!Fb(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:Cr.Type.STATUS,status:ht.MALFORMED_MESSAGE},{signal:r}),await t.close();return}const o=Ft(je(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:Cr.Type.STATUS,status:ht.PERMISSION_DENIED},{signal:r}),await t.close();return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:Cr.Type.STATUS,status:ht.OK},{signal:r});const a=new x1(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=I1({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits()}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function qp(n={}){return e=>new Ub(e,n)}const T1=()=>{const n=new Error("Delay aborted");return n.name="AbortError",n},$b=new WeakMap;function Vb({clearTimeout:n,setTimeout:e}={}){return(t,{value:r,signal:s}={})=>{if(s?.aborted)return Promise.reject(T1());let i,o,a;const c=n??clearTimeout,l=()=>{c(i),a(T1())},u=()=>{s&&s.removeEventListener("abort",l)},h=new Promise((d,f)=>{o=()=>{u(),d(r)},a=f,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),$b.set(h,()=>{c(i),i=null,o()}),h}}const Kp=Vb();var mr;(function(n){(function(r){r.UNUSED="UNUSED",r.CONNECT="CONNECT",r.SYNC="SYNC"})(n.Type||(n.Type={}));let e;(function(r){r[r.UNUSED=0]="UNUSED",r[r.CONNECT=100]="CONNECT",r[r.SYNC=300]="SYNC"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{if(i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.observedAddresses!=null)for(const o of r.observedAddresses)s.uint32(18),s.bytes(o);i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={observedAddresses:[]},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{if(i.limits?.observedAddresses!=null&&o.observedAddresses.length===i.limits.observedAddresses)throw new _e('Decode error - map field "observedAddresses" had too many elements');o.observedAddresses.push(r.bytes());break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(mr||(mr={}));var hs={},P1;function Hb(){return P1||(P1=1,function(){var n,e,t,r,s,i,o,a;a=function(c){var l,u,h,d;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,h=(c&65280)>>>8,d=c&255,[l,u,h,d].join(".")},o=function(c){var l,u,h,d,f,p;for(l=[],h=d=0;d<=3&&c.length!==0;h=++d){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}p=e(c),f=p[0],u=p[1],c=c.substring(u),l.push(f)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},r=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,h,d,f;for(d=0,l=10,u="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,l=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,l=8,u="7")),f=h;h<c.length;){if("0"<=c[h]&&c[h]<=u)d=d*l+(t(c[h])-r)>>>0;else if(l===16)if("a"<=c[h]&&c[h]<="f")d=d*l+(10+t(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")d=d*l+(10+t(c[h])-s)>>>0;else break;else break;if(d>4294967295)throw new Error("too large");h++}if(h===f)throw new Error("empty octet");return[d,h]},n=function(){function c(l,u){var h,d,f;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(f=l.split("/",2),l=f[0],u=f[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(h=d=32;d>=0;h=--d)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,h,d;for(d=o(this.first),h=o(this.last),u=0;d<=h;)l(a(d),d,u),u++,d++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),hs.ip2long=o,hs.long2ip=a,hs.Netmask=n}.call(hs)),hs}var zb=Hb();const qb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],Kb=qb.map(n=>new zb.Netmask(n));function Ph(n){for(const e of Kb)if(e.contains(n))return!0;return!1}function Wb(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function Gb(n){const e=n.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0"),s=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Ph(s)}function Qb(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function Yb(n){const e=n.split(":"),t=e[e.length-1];return Ph(t)}function Xb(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function vn(n){return Bs(n)?Ph(n):Wb(n)?Gb(n):Qb(n)?Yb(n):gh(n)?Xb(n):void 0}function C1(n,e){return dn.matches(n)||e.dialTransportForMultiaddr(n)==null?!1:Cp.matches(n)?!0:jw.matches(n)?vn(n.toOptions().host)===!1:!1}const D1=1024*4,R1=100,xo={timeout:5e3,retries:3,maxInboundStreams:1,maxOutboundStreams:1};class Zb{started;timeout;retries;maxInboundStreams;maxOutboundStreams;peerStore;registrar;connectionManager;addressManager;transportManager;topologyId;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:dcutr"),this.started=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.timeout=t.timeout??xo.timeout,this.retries=t.retries??xo.retries,this.maxInboundStreams=t.maxInboundStreams??xo.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??xo.maxOutboundStreams}[Symbol.toStringTag]="@libp2p/dcutr";[cn]=["@libp2p/identify"];isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(ko,{notifyOnLimitedConnection:!0,onConnect:(e,t)=>{dn.exactMatch(t.remoteAddr)&&t.direction==="inbound"&&this.upgradeInbound(t).catch(r=>{this.log.error("error during outgoing DCUtR attempt",r)})}}),await this.registrar.handle(ko,e=>{this.handleIncomingUpgrade(e.stream,e.connection).catch(t=>{this.log.error("error during incoming DCUtR attempt",t),e.stream.abort(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(ko),this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(e){if(await this.attemptUnilateralConnectionUpgrade(e))return;let t;for(let r=0;r<this.retries;r++){const s={signal:AbortSignal.timeout(this.timeout)};try{t=await e.newStream([ko],{signal:s.signal,runOnLimitedConnection:!0});const i=pt(t,{maxDataLength:D1}).pb(mr);this.log("B sending connect to %p",e.remotePeer);const o=Date.now();await i.write({type:mr.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(h=>h.bytes)},s),this.log("B receiving connect from %p",e.remotePeer);const a=await i.read(s);if(a.type!==mr.Type.CONNECT)throw this.log("A sent wrong message type"),new Pe("DCUtR message type was incorrect");const c=this.getDialableMultiaddrs(a.observedAddresses);if(c.length===0)throw this.log("A did not have any dialable multiaddrs"),new Pe("DCUtR connect message had no multiaddrs");const l=Date.now()-o;this.log("A sending sync, rtt %dms",l),await i.write({type:mr.Type.SYNC,observedAddresses:[]},s),this.log("A waiting for half RTT"),await Kp(l/2),this.log("B dialing",c);const u=await this.connectionManager.openConnection(c,{signal:s.signal,priority:R1,force:!0,initiator:!1});this.log("DCUtR to %p succeeded to address %a, closing relayed connection",e.remotePeer,u.remoteAddr),await e.close(s);break}catch(i){if(this.log.error("error while attempting DCUtR on attempt %d of %d",r+1,this.retries,i),t?.abort(i),r===this.retries)throw i}finally{t!=null&&await t.close(s)}}}async attemptUnilateralConnectionUpgrade(e){const r=(await this.peerStore.get(e.remotePeer)).addresses.map(s=>{const i=s.multiaddr;return i.getPeerId()==null?i.encapsulate(`/p2p/${e.remotePeer}`):i}).filter(s=>C1(s,this.transportManager));if(r.length>0){const s=AbortSignal.timeout(this.timeout);try{this.log("attempting unilateral connection upgrade to %a",r);const i=await this.connectionManager.openConnection(r,{signal:s,force:!0});if(dn.exactMatch(i.remoteAddr))throw new Error("Could not open a new, non-limited, connection");return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",e.remotePeer,i.remoteAddr),await e.close({signal:s}),!0}catch(i){this.log.error("unilateral connection upgrade to %p on addresses %a failed",e.remotePeer,r,i)}}else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade",e.remotePeer);return!1}async handleIncomingUpgrade(e,t){const r={signal:AbortSignal.timeout(this.timeout)};try{const s=pt(e,{maxDataLength:D1}).pb(mr);this.log("A receiving connect");const i=await s.read(r);if(i.type!==mr.Type.CONNECT)throw this.log("B sent wrong message type"),new Pe("DCUtR message type was incorrect");if(i.observedAddresses.length===0)throw this.log("B sent no multiaddrs"),new Pe("DCUtR connect message had no multiaddrs");const o=this.getDialableMultiaddrs(i.observedAddresses);if(o.length===0)throw this.log("B had no dialable multiaddrs"),new Pe("DCUtR connect message had no dialable multiaddrs");if(this.log("A sending connect"),await s.write({type:mr.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(l=>l.bytes)}),this.log("A receiving sync"),(await s.read(r)).type!==mr.Type.SYNC)throw new Pe("DCUtR message type was incorrect");this.log("A dialing",o);const c=await this.connectionManager.openConnection(o,{signal:r.signal,priority:R1,force:!0});this.log("DCUtR to %p succeeded via %a, closing relayed connection",t.remotePeer,c.remoteAddr),await t.close(r)}catch(s){this.log.error("incoming DCUtR from %p failed",t.remotePeer,s),e.abort(s)}finally{await e.close(r)}}getDialableMultiaddrs(e){const t=[];for(const r of e)if(!(r==null||r.length===0))try{const s=re(r);if(!C1(s,this.transportManager))continue;t.push(s)}catch{}return t}}const ko="/libp2p/dcutr";function Wp(n={}){return e=>new Zb(e,n)}function jb(n){return n[Symbol.asyncIterator]!=null}function pn(n){if(jb(n))return(async()=>{for await(const e of n);})();for(const e of n);}const Io=globalThis.CustomEvent??Event;async function*oo(n,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const r=e.ordered==null?!1:e.ordered,s=new EventTarget,i=[];let o=ae(),a=ae(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const p of n){if(i.length===t&&(o=ae(),await o.promise),u)break;const m={done:!1};i.push(m),p().then(g=>{m.done=!0,m.ok=!0,m.value=g,s.dispatchEvent(new Io("task-complete"))},g=>{m.done=!0,m.err=g,s.dispatchEvent(new Io("task-complete"))})}c=!0,s.dispatchEvent(new Io("task-complete"))}catch(p){l=p,s.dispatchEvent(new Io("task-complete"))}});function h(){return r?i[0]?.done:!!i.find(p=>p.done)}function*d(){for(;i.length>0&&i[0].done;){const p=i[0];if(i.shift(),p.ok)yield p.value;else throw u=!0,o.resolve(),p.err;o.resolve()}}function*f(){for(;h();)for(let p=0;p<i.length;p++)if(i[p].done){const m=i[p];if(i.splice(p,1),p--,m.ok)yield m.value;else throw u=!0,o.resolve(),m.err;o.resolve()}}for(;;){if(h()||(a=ae(),await a.promise),l!=null)throw l;if(r?yield*d():yield*f(),c&&i.length===0)break}}const Jb="0.1.0",ev="id",tv="id/push",rv="1.0.0",nv="1.0.0",sv=1024*8,iv=32;var Hs;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.protocolVersion!=null&&(r.uint32(42),r.string(t.protocolVersion)),t.agentVersion!=null&&(r.uint32(50),r.string(t.agentVersion)),t.publicKey!=null&&(r.uint32(10),r.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)r.uint32(18),r.bytes(i);if(t.observedAddr!=null&&(r.uint32(34),r.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)r.uint32(26),r.string(i);t.signedPeerRecord!=null&&(r.uint32(66),r.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={listenAddrs:[],protocols:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new _e('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new _e('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Hs||(Hs={}));const $t={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:sv,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:iv};function ov(n){if(n!=null&&n.length>0)try{return re(n)}catch{}}function av(n,e){return e??n.userAgent}async function Gp(n,e,t,r,s){if(t("received identify from %p",r.remotePeer),s==null)throw new Pe("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:re(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Tt(s.publicKey);if(!Ms(c).equals(r.remotePeer))throw new Pe("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",r.remotePeer);let c=s.signedPeerRecord;const l=await br.openAndCertify(c,Lt.DOMAIN);let u=Lt.createFromProtobuf(l.payload);const h=ro(l.publicKey.toCID());if(!u.peerId.equals(h))throw new Pe("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(u.peerId))throw new Pe("signing key does not match remote PeerId");let d;try{d=await n.get(u.peerId)}catch(f){if(f.name!=="NotFoundError")throw f}if(d!=null&&(i.metadata=d.metadata,d.peerRecordEnvelope!=null)){const f=await br.createFromProtobuf(d.peerRecordEnvelope),p=Lt.createFromProtobuf(f.payload);p.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",p.seqNumber,u.seqNumber),u=p,c=d.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(f=>({isCertified:!0,multiaddr:f})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",r.remotePeer);if(t.trace("patching %p with",r.remotePeer,i),await n.patch(r.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=V(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=V(s.protocolVersion)),t.trace("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>re(c)),observedAddr:s.observedAddr==null?void 0:re(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:r};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Qp{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??$t.timeout,this.maxInboundStreams=t.maxInboundStreams??$t.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??$t.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??$t.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??$t.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??$t.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??$t.protocolPrefix}/${Jb}`,agentVersion:av(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:V(this.host.agentVersion),ProtocolVersion:V(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class cv extends Qp{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??$t.protocolPrefix}/${tv}/${nv}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??$t.concurrency,(t.runOnSelfUpdate??$t.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",r=>{this.push().catch(s=>{this.log.error(s)})})}[rt]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(ne("p2p").code)),t=new Lt({peerId:this.peerId,multiaddrs:e}),r=await br.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=K(i.metadata.get("AgentVersion")??V(this.host.agentVersion)),a=K(i.metadata.get("ProtocolVersion")??V(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let d;const f=AbortSignal.timeout(c.timeout);try{d=await u.newStream(c.protocol,{signal:f,runOnLimitedConnection:c.runOnLimitedConnection}),await pt(d,{maxDataLength:c.maxMessageSize}).pb(Hs).write({listenAddrs:e.map(m=>m.bytes),signedPeerRecord:r.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:f}),await d.close({signal:f})}catch(p){c.log.error("could not push identify update to peer",p),d?.abort(p)}})}await pn(oo(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:r}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await pt(r,{maxDataLength:this.maxMessageSize}).pb(Hs).read(s);await r.close(s),await Gp(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),r.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}const lv=41;function Yp(n){try{const[[e,t]]=n.stringTuples();if(t==null)return!1;if(e===lv)return ty("2000::/3",t)}catch{}return!1}const uv=4,hv=41,dv=53,fv=54,pv=55,gv=56;function Qn(n){try{const[[e,t]]=n.stringTuples();if(t==null)return!0;if(e===dv||e===fv||e===pv||e===gv)return!1;if(e===uv||e===hv)return vn(t)??!1}catch{}return!0}const mv=41;class yv extends Qp{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??$t.protocolPrefix}/${ev}/${rv}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??$t.runOnConnectionOpen)&&e.events.addEventListener("connection:open",r=>{const s=r.detail;this.identify(s).catch(i=>{i.name!==Qa.name&&this.log.error("error during identify trigged by connection:open",i)})})}[rt]=["@libp2p/identify"];async _identify(e,t={}){let r;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await pt(r,{maxDataLength:this.maxMessageSize}).pb(Hs).read(t);return await r.close(t),i}catch(s){throw r?.abort(s),s}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=r;if(s==null)throw new Pe("public key was missing from identify message");const a=Tt(s),c=ro(a.toCID());if(!e.remotePeer.equals(c))throw new Pe("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new Pe("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),Gp(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=ov(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),Qn(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===mv&&!Yp(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Ea.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:r}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(ne("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Lt({peerId:this.peerId,multiaddrs:o});a=(await br.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Zw.matches(t.remoteAddr)||(c=void 0),await pt(r).pb(Hs).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:rr(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await r.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),r.abort(i)}}}function Xp(n={}){return e=>new yv(e,n)}function wv(n={}){return e=>new cv(e,n)}var M1=function(n,e,t){if(t||arguments.length===2)for(var r=0,s=e.length,i;r<s;r++)(i||!(r in e))&&(i||(i=Array.prototype.slice.call(e,0,r)),i[r]=e[r]);return n.concat(i||Array.prototype.slice.call(e))},bv=function(){function n(e,t,r){this.name=e,this.version=t,this.os=r,this.type="browser"}return n}(),vv=function(){function n(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return n}(),Ev=function(){function n(e,t,r,s){this.name=e,this.version=t,this.os=r,this.bot=s,this.type="bot-device"}return n}(),Sv=function(){function n(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return n}(),_v=function(){function n(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return n}(),xv=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,kv=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,L1=3,Iv=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",xv]],N1=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function Av(n){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new _v:typeof navigator<"u"?Pv(navigator.userAgent):Dv()}function Tv(n){return n!==""&&Iv.reduce(function(e,t){var r=t[0],s=t[1];if(e)return e;var i=s.exec(n);return!!i&&[r,i]},!1)}function Pv(n){var e=Tv(n);if(!e)return null;var t=e[0],r=e[1];if(t==="searchbot")return new Sv;var s=r[1]&&r[1].split(".").join("_").split("_").slice(0,3);s?s.length<L1&&(s=M1(M1([],s,!0),Rv(L1-s.length),!0)):s=[];var i=s.join("."),o=Cv(n),a=kv.exec(n);return a&&a[1]?new Ev(t,i,o,a[1]):new bv(t,i,o)}function Cv(n){for(var e=0,t=N1.length;e<t;e++){var r=N1[e],s=r[0],i=r[1],o=i.exec(n);if(o)return s}return null}function Dv(){var n=typeof process<"u"&&process.version;return n?new vv(process.version.slice(1)):null}function Rv(n){for(var e=[],t=0;t<n;t++)e.push("0");return e}class Zp extends Error{constructor(e){super(e),this.name="TimeoutError"}}let Mv=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const B1=n=>globalThis.DOMException===void 0?new Mv(n):new DOMException(n),O1=n=>{const e=n.reason===void 0?B1("This operation was aborted."):n.reason;return e instanceof Error?e:B1(e)};function ao(n,e){const{milliseconds:t,fallback:r,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:f}=e;f.aborted&&h(O1(f)),a=()=>{h(O1(f))},f.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(u,h);return}const d=new Zp;o=i.setTimeout.call(void 0,()=>{if(r){try{u(r())}catch(f){h(f)}return}typeof n.cancel=="function"&&n.cancel(),s===!1?u():s instanceof Error?h(s):(d.message=s??`Promise timed out after ${t} milliseconds`,h(d))},t),(async()=>{try{u(await n)}catch(f){h(f)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}const Lv=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"],F1=Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"),Nv="libp2p+webrtc+v1/",U1=Av(),Ch=U1!=null&&U1.name==="firefox",jp=async function*(){},Jp=async n=>{},Bv=30*1e3;function Ov(n,e,t=Bv,r){n.readyState==="open"&&Promise.resolve().then(async()=>{if(n.bufferedAmount>0){r.log("%s drain channel with %d buffered bytes",e,n.bufferedAmount);const s=ae();let i=!1;n.bufferedAmountLowThreshold=0;const o=()=>{i||(r.log("%s drain channel closed before drain",e),s.resolve())};n.addEventListener("close",o,{once:!0}),n.addEventListener("bufferedamountlow",()=>{i=!0,n.removeEventListener("close",o),s.resolve()}),await ao(s.promise,{milliseconds:t})}}).then(async()=>{n.readyState==="open"&&n.close()}).catch(s=>{r.log.error("error closing outbound stream",s)})}async function $1(n){return n=n??{},typeof n=="function"&&(n=await n()),n.iceServers=n.iceServers??Lv.map(e=>({urls:[e]})),n}const Fv=(n=32)=>Nv+[...Array(n)].map(()=>F1.at(Math.floor(Math.random()*F1.length))).join("");class cu{log;peerConnection;remoteAddr;timeline;metrics;source=jp();sink=Jp;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const r=this.peerConnection,s=r.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",r.connectionState,"initial state",s),(r.connectionState==="disconnected"||r.connectionState==="failed"||r.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}const Uv=8,Dh=1024*1024*4;let $v=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},eg=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Vv=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},V1=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function tg(n){return n[Symbol.asyncIterator]!=null}function rg(n,e){if(n.byteLength>e)throw new eg("Message length too long")}const mc=n=>{const e=ye(n),t=ct(e);return Ze(n,t),mc.bytes=e,t};mc.bytes=0;function lu(n,e){e=e??{};const t=e.lengthEncoder??mc,r=e?.maxDataLength??Dh;function*s(i){rg(i,r);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return tg(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}lu.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??mc,r=e?.maxDataLength??Dh;return rg(n,r),new ge(t(n.byteLength),n)};var Tn;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Tn||(Tn={}));const Rh=n=>{const e=ar(n);return Rh.bytes=ye(e),e};Rh.bytes=0;function uu(n,e){const t=new ge;let r=Tn.LENGTH,s=-1;const i=e?.lengthDecoder??Rh,o=e?.maxLengthLength??Uv,a=e?.maxDataLength??Dh;function*c(){for(;t.byteLength>0;){if(r===Tn.LENGTH)try{if(s=i(t),s<0)throw new $v("Invalid message length");if(s>a)throw new eg("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),r=Tn.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new Vv("Message length length too long");break}throw l}if(r===Tn.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,r=Tn.LENGTH}}}return tg(n)?async function*(){for await(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new V1("Unexpected end of input")}():function*(){for(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new V1("Unexpected end of input")}()}uu.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return uu(r,{...e??{},onLength:i=>{t=i}})};var vt;(function(n){(function(r){r.FIN="FIN",r.STOP_SENDING="STOP_SENDING",r.RESET="RESET",r.FIN_ACK="FIN_ACK"})(n.Flag||(n.Flag={}));let e;(function(r){r[r.FIN=0]="FIN",r[r.STOP_SENDING=1]="STOP_SENDING",r[r.RESET=2]="RESET",r[r.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.Flag||(n.Flag={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.flag!=null&&(s.uint32(8),n.Flag.codec().encode(r.flag,s)),r.message!=null&&(s.uint32(18),s.bytes(r.message)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.flag=n.Flag.codec().decode(r);break}case 2:{o.message=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(vt||(vt={}));const Hv=2*1024*1024,zv=30*1e3,yc=16*1024;function qv(n=yc){const e=ye(n-ye(n)),t=1+ye(Object.keys(vt.Flag).length-1),r=1,s=n-e-t-r,i=ye(s);return e+t+r+i}const Kv=qv(),Wv=5e3,Gv=5e3;class Qv extends vh{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace("readable and writeable ends closed",this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await ao(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),this.channel.close(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=_r(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??zv,this.maxBufferedAmount=e.maxBufferedAmount??Hv,this.maxMessageSize=(e.maxMessageSize??yc)-Kv,this.receiveFinAck=ae(),this.finAckTimeout=e.closeTimeout??Wv,this.openTimeout=e.openTimeout??Gv,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Nl("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const r=this;Promise.resolve().then(async()=>{for await(const s of uu(this.incomingData)){const i=r.processIncomingProtobuf(s);i!=null&&r.sourcePush(new ge(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Nl(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const r=AbortSignal.timeout(this.openTimeout),s=be([this.closeController.signal,r]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await zt(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const r=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=be([this.closeController.signal,r]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await zt(this.channel,"bufferedamountlow",s)}catch(i){throw r.aborted?new Ya(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.channel.send(e.subarray())}catch(r){this.log.error("error while sending message",r)}}async sendData(e){for(this.log.trace("-> will send %d bytes",e.byteLength),e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxMessageSize),r=e.subarray(0,t),s=vt.encode({message:r}),i=lu.single(s);this.log.trace("-> sending message %s",this.channel.readyState),await this._sendMessage(i),this.log.trace("-> sent message %s",this.channel.readyState),e.consume(t)}this.log.trace("-> sent data %s",this.channel.readyState)}async sendReset(){try{await this._sendFlag(vt.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(vt.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await Ht(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(r){this.log.error("failed to await FIN_ACK",r)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(vt.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=vt.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===vt.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(vt.Flag.FIN_ACK).catch(r=>{this.log.error("error sending FIN_ACK immediately",r)})),t.flag===vt.Flag.RESET&&this.reset(),t.flag===vt.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===vt.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',this.channel.readyState,e.toString()),!1;this.log.trace("sending flag %s",e.toString());const t=vt.encode({flag:e}),r=lu.single(t);try{return await this._sendMessage(r,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function ka(n){const{channel:e,direction:t}=n;return new Qv({id:t==="inbound"?`i${e.id}`:`r${e.id}`,log:n.logger.forComponent(`libp2p:webrtc:stream:${t}:${e.id}`),...n})}const ng="/webrtc";class Mh{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??ng,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',r.id),r.label==="init"){this.log.trace("closing early init channel"),r.close();return}const s={},i=ka({channel:r,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=r,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new Yv(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class Yv{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(r=>r.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??ng,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace("incoming datachannel with channel id %d",r.id),r.label==="init"){this.log.trace("closing init channel"),r.close();return}const s=r.id,i=ka({channel:r,direction:"inbound",onEnd:()=>{this.#e(i,r),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(r=>{r.onEnd=()=>{this.log("incoming early channel %s ended with state %s",r.channel.id,r.channel.readyState),this.#e(r.stream,r.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(r.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),Ov(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(r=>r.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=jp();sink=Jp;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const r=ka({channel:e,direction:"outbound",onEnd:()=>{this.#e(r,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(r),this.metrics?.increment({outgoing_stream:!0}),r}}const sg=globalThis.RTCPeerConnection,ig=globalThis.RTCSessionDescription,Xv=globalThis.RTCIceCandidate;class co extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class jr extends co{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}class Zv extends co{constructor(e,t){super(`Invalid fingerprint "${e}" within ${t}`),this.name="WebRTC/InvalidFingerprintError"}}class jv extends co{constructor(e){super(`A method (${e}) was called though it has been intentionally left unimplemented.`),this.name="WebRTC/UnimplementedError"}}class Jv extends co{constructor(e){super(`unsupported hash algorithm code: ${e} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `),this.name="WebRTC/UnsupportedHashAlgorithmError"}}var tr;(function(n){(function(r){r.SDP_OFFER="SDP_OFFER",r.SDP_ANSWER="SDP_ANSWER",r.ICE_CANDIDATE="ICE_CANDIDATE"})(n.Type||(n.Type={}));let e;(function(r){r[r.SDP_OFFER=0]="SDP_OFFER",r[r.SDP_ANSWER=1]="SDP_ANSWER",r[r.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.data!=null&&(s.uint32(18),s.string(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.data=r.string();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(tr||(tr={}));const og=async(n,e,t)=>{try{const r=ae();for(eE(n,r);;){const s=await Promise.race([r.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==tr.Type.ICE_CANDIDATE)throw new Pe("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new Q("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new Xv(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new Q("webrtc:add-ice-candidate",o.candidate)),await n.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(r){if(t.log.error("%s error parsing ICE candidate",t.direction,r),t.signal?.aborted===!0&&Lh(n)!=="connected")throw r}};function Lh(n){return Ch?n.iceConnectionState:n.connectionState}function eE(n,e){n[Ch?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(Lh(n)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new _0("RTCPeerConnection was closed"));break}}}async function tE({rtcConfiguration:n,dataChannel:e,signal:t,metrics:r,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=lE(s);r?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const h=u.getPeerId();if(h==null)throw new B("Relay peer was missing");const d=i.getConnections(Ue(h));let f,p=!1;d.length===0?(l?.(new Q("webrtc:dial-relay")),f=await o.dial(u,{signal:t,onProgress:l}),p=!0):(l?.(new Q("webrtc:reuse-relay-connection")),f=d[0]);try{l?.(new Q("webrtc:open-signaling-stream"));const m=await f.newStream(hu,{signal:t,runOnLimitedConnection:!0}),g=pt(m).pb(tr),y=new sg(n),b=new Mh({logger:c},{peerConnection:y,dataChannelOptions:e});try{const w=y.createDataChannel("init");y.onicecandidate=({candidate:I})=>{const D=JSON.stringify(I?.toJSON()??null);a.trace("initiator sending ICE candidate %o",I),g.write({type:tr.Type.ICE_CANDIDATE,data:D},{signal:t}).catch(v=>{a.error("error sending ICE candidate",v)})},y.onicecandidateerror=I=>{a.error("initiator ICE candidate error",I)};const k=await y.createOffer().catch(I=>{throw a.error("could not execute createOffer",I),new jr("Failed to set createOffer")});a.trace("initiator send SDP offer %s",k.sdp),l?.(new Q("webrtc:send-sdp-offer")),await g.write({type:tr.Type.SDP_OFFER,data:k.sdp},{signal:t}),await y.setLocalDescription(k).catch(I=>{throw a.error("could not execute setLocalDescription",I),new jr("Failed to set localDescription")}),l?.(new Q("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const _=await g.read({signal:t});if(_.type!==tr.Type.SDP_ANSWER)throw new jr("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",_.data);const A=new ig({type:"answer",sdp:_.data});return await y.setRemoteDescription(A).catch(I=>{throw a.error("could not execute setRemoteDescription",I),new jr("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new Q("webrtc:read-ice-candidates")),await og(y,g,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),w.close(),l?.(new Q("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await m.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:y,muxerFactory:b}}catch(w){throw a.error("outgoing signaling error",w),y.close(),m.abort(w),w}finally{y.onicecandidate=null,y.onicecandidateerror=null}}finally{if(p)try{await f.close({signal:t})}catch(m){f.abort(m)}}}const rE=Ce(Op.matchers[0],ce("p2p-circuit"));class nE extends Ke{transportManager;shutdownController;constructor(e,t){super(),this.transportManager=e.transportManager,this.shutdownController=t.shutdownController}async listen(){queueMicrotask(()=>{this.safeDispatchEvent("listening")})}getAddrs(){return this.transportManager.getListeners().filter(e=>e!==this).map(e=>e.getAddrs().filter(t=>rE.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}async close(){this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function sE({peerConnection:n,stream:e,signal:t,connection:r,log:s}){s.trace("new inbound signaling stream");const i=pt(e).pb(tr);try{n.onicecandidate=({candidate:u})=>{const h=JSON.stringify(u?.toJSON()??null);s.trace("recipient sending ICE candidate %s",h),i.write({type:tr.Type.ICE_CANDIDATE,data:h},{signal:t}).catch(d=>{s.error("error sending ICE candidate",d)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==tr.Type.SDP_OFFER)throw new jr(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new ig({type:"offer",sdp:a.data});await n.setRemoteDescription(c).catch(u=>{throw s.error("could not execute setRemoteDescription",u),new jr("Failed to set remoteDescription")});const l=await n.createAnswer().catch(u=>{throw s.error("could not execute createAnswer",u),new jr("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:tr.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await n.setLocalDescription(l).catch(u=>{throw s.error("could not execute setLocalDescription",u),new jr("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await og(n,i,{direction:"recipient",signal:t,log:s})}catch(a){if(Lh(n)!=="connected")throw s.error("error while handling signaling stream from peer %a",r.remoteAddr,a),n.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",r.remoteAddr,a)}const o=re(`/webrtc/p2p/${r.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}const iE="/webrtc",oE="/p2p-circuit",hu="/webrtc-signaling/0.0.1",aE=30*1e3;class cE{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[Ga]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[rt]=["@libp2p/transport"];[cn]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(hu,e=>{this._onProtocol(e).catch(t=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,t)})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(hu),this._started=!1}createListener(e){return new nE(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(au.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:r,peerConnection:s,muxerFactory:i}=await tE({rtcConfiguration:await $1(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new cu(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:r,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t}){const r=AbortSignal.timeout(this.init.inboundConnectionTimeout??aE),s=new sg(await $1(this.init.rtcConfiguration)),i=new Mh(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await sE({peerConnection:s,connection:e,stream:t,signal:r,log:this.log});await t.close({signal:r});const a=new cu(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const r=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",r),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",r)})}}function lE(n){const e=n.toString().split(iE+"/");if(e.length!==2)throw new B("webrtc protocol was not present in multiaddr");if(!e[0].includes(oE))throw new B("p2p-circuit protocol was not present in multiaddr");let t=re(e[0]);const s=re("/"+e[1]).getPeerId();if(s==null)throw new B("destination peer id was missing");const i=t.protos().pop();if(i===void 0)throw new B("invalid multiaddr");return i.name!=="p2p"&&(t=t.encapsulate(`/p2p/${s}`)),{baseAddr:t,peerId:Ue(s)}}class uE extends Ke{async listen(){throw new jv("WebRTCTransport.createListener")}getAddrs(){return[]}async close(){}}const ag=Object.values(na).map(n=>n.decoder).reduce((n,e)=>n.or(e)),hE=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function dE(n){return n?.match(hE)?.groups?.fingerprint}function cg(n){const t=n.stringTuples().filter(r=>r[0]===xE).map(r=>r[1])[0];if(t===void 0||t==="")throw new B(`Couldn't find a certhash component of multiaddr: ${n.toString()}`);return t}function fE(n){return je(ag.decode(n))}function pE(n){const e=fE(cg(n)),t=mE(e.code),r=e.digest.reduce((i,o)=>i+o.toString(16).padStart(2,"0"),""),s=r.match(/.{1,2}/g);if(s==null)throw new Zv(r,n.toString());return`${t} ${s.join(":").toUpperCase()}`}function gE(n){const e=n.split(":").map(s=>parseInt(s,16)),t=Uint8Array.from(e),r=Br(Nt.code,t);return re(`/certhash/${th.encode(r.bytes)}`)}function mE(n){switch(n){case 17:return"sha-1";case 18:return"sha-256";case 19:return"sha-512";default:throw new Jv(n)}}function yE(n,e){const{host:t,port:r,family:s}=n.toOptions(),i=pE(n);return{type:"answer",sdp:`v=0
o=- 0 0 IN IP${s} ${t}
s=-
t=0 0
a=ice-lite
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${s} ${t}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:${i}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${yc}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${r} typ host
a=end-of-candidates
`}}function wE(n,e){const{host:t,port:r,family:s}=n.toOptions();return{type:"offer",sdp:`v=0
o=- 0 0 IN IP${s} ${t}
s=-
c=IN IP${s} ${t}
t=0 0
a=ice-options:ice2,trickle
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${yc}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${r} typ host
a=end-of-candidates
`}}function H1(n,e){if(n.sdp===void 0)throw new B("Can't munge a missing SDP");const t=n.sdp.includes(`\r
`)?`\r
`:`
`;return n.sdp=n.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+e+t).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+e+t),n}const tl=V("libp2p-webrtc-noise:");function bE(n,e,t){const r=n.trim().toLowerCase().replaceAll(":",""),s=V(r,"hex"),i=Br(Nt.code,s),o=ag.decode(cg(e)),a=tl.byteLength+i.bytes.byteLength+o.byteLength;return We(t==="server"?[tl,o,i.bytes]:[tl,i.bytes,o],a)}const vE=Ch?"iceconnectionstatechange":"connectionstatechange";async function EE(n,e,t){const r=n.createDataChannel("",{negotiated:!0,id:0});if(t.role==="client"){t.log.trace("client creating local offer");const d=await n.createOffer();t.log.trace("client created local offer %s",d.sdp);const f=H1(d,e);t.log.trace("client setting local offer %s",f.sdp),await n.setLocalDescription(f);const p=yE(t.remoteAddr,e);t.log.trace("client setting server description %s",p.sdp),await n.setRemoteDescription(p)}else{const d=wE(t.remoteAddr,e);t.log.trace("server setting client %s %s",d.type,d.sdp),await n.setRemoteDescription(d),t.log.trace("server creating local answer");const f=await n.createAnswer();t.log.trace("server created local answer");const p=H1(f,e);t.log.trace("server setting local description %s",f.sdp),await n.setLocalDescription(p)}if(t.log.trace("%s wait for handshake channel to open",t.role),await zt(r,"open",t.signal),t.log.trace("%s handshake channel opened",t.role),t.role==="server"){const d=n.remoteFingerprint()?.value??"";t.remoteAddr=t.remoteAddr.encapsulate(gE(d))}const s=dE(n.localDescription?.sdp);if(s==null)throw new co("Could not get fingerprint from local description sdp");t.log.trace("%s performing noise handshake",t.role);const i=bE(s,t.remoteAddr,t.role),o=wh({prologueBytes:i})(t),a=ka({channel:r,direction:"inbound",logger:t.logger,...t.dataChannel??{}}),c={...a,sink:a.sink.bind(a),source:async function*(){for await(const d of a.source)for(const f of d)yield f}()},l=new cu(t,{peerConnection:n,remoteAddr:t.remoteAddr,timeline:{open:Date.now()},metrics:t.events});n.addEventListener(vE,()=>{switch(n.connectionState){case"failed":case"disconnected":case"closed":l.close().catch(d=>{t.log.error("error closing connection",d)});break}}),t.events?.increment({peer_connection:!0});const u=new Mh(t,{peerConnection:n,metrics:t.events,dataChannelOptions:t.dataChannel});if(t.role==="client")return t.log.trace("%s secure inbound",t.role),await o.secureInbound(c,{remotePeer:t.remotePeerId}),t.log.trace("%s upgrade outbound",t.role),t.upgrader.upgradeOutbound(l,{skipProtection:!0,skipEncryption:!0,muxerFactory:u});t.log.trace("%s secure outbound",t.role);const h=await o.secureOutbound(c,{remotePeer:t.remotePeerId});l.remoteAddr=l.remoteAddr.encapsulate(`/p2p/${h.remotePeer}`),t.log.trace("%s upgrade inbound",t.role),await t.upgrader.upgradeInbound(l,{skipProtection:!0,skipEncryption:!0,muxerFactory:u})}async function SE(n,e,t,r){r==null&&(r=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256"}));const s=typeof t=="function"?await t():t;return new RTCPeerConnection({...s??{},certificates:[r]})}const _E=1e4;ne("webrtc-direct").code;const xE=ne("certhash").code;class kE{log;metrics;components;init;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:webrtc-direct"),this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}[Ga]=!0;[Symbol.toStringTag]="@libp2p/webrtc-direct";[rt]=["@libp2p/transport"];async dial(e,t){t?.signal?.throwIfAborted();const r=await this._connect(e,t);return this.log("dialing address: %a",e),r}createListener(e){return new uE(this.components,{...this.init,...e})}listenFilter(e){return e.filter(ou.exactMatch)}dialFilter(e){return this.listenFilter(e)}async _connect(e,t){let r;const s=e.getPeerId();s!=null&&(r=Ue(s));const i=Fv(),o=await SE("client",i,typeof this.init.rtcConfiguration=="function"?await this.init.rtcConfiguration():this.init.rtcConfiguration??{});try{return await Ht(EE(o,i,{role:"client",log:this.log,logger:this.components.logger,metrics:this.components.metrics,events:this.metrics?.dialerEvents,signal:t.signal??AbortSignal.timeout(_E),remoteAddr:e,dataChannel:this.init.dataChannel,upgrader:t.upgrader,peerId:this.components.peerId,remotePeerId:r,privateKey:this.components.privateKey}),t.signal)}catch(a){throw o.close(),a}}}function IE(n){return e=>new kE(e,n)}function lg(n){return e=>new cE(e,n)}const AE=[ne("tcp").code,ne("dns").code,ne("dnsaddr").code,ne("dns4").code,ne("dns6").code];function z1(n){return ug("sni",n)?.[1]}function q1(n){const e=ug("tcp",n)?.[1];return e==null?"":`:${e}`}function ug(n,e){let t;try{t=ne(n).code}catch{return}for(const[r,s]of e)if(r===t&&s!=null)return[r,s]}function K1(n){return n.some(([e,t])=>e===ne("tls").code)}function Xt(n,e,t){const r=hg[ne(n).name];if(r==null)throw new Error(`Can't interpret protocol ${ne(n).name}`);const s=r(e,t);return n===ne("ip6").code?`[${s}]`:s}const hg={ip4:(n,e)=>n,ip6:(n,e)=>e.length===0?n:`[${n}]`,tcp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${Xt(t[0],t[1]??"",e)}:${n}`},udp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${Xt(t[0],t[1]??"",e)}:${n}`},dnsaddr:(n,e)=>n,dns4:(n,e)=>n,dns6:(n,e)=>n,dns:(n,e)=>n,ipfs:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Xt(t[0],t[1]??"",e)}`},p2p:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Xt(t[0],t[1]??"",e)}`},http:(n,e)=>{const t=K1(e),r=z1(e),s=q1(e);if(t&&r!=null)return`https://${r}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Xt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const r=Xt(t[0],t[1]??"",e),s=decodeURIComponent(n);return`${r}/${s}`},tls:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Xt(t[0],t[1]??"",e)},sni:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Xt(t[0],t[1]??"",e)},https:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=Xt(t[0],t[1]??"",e);return r=r.replace("tcp://",""),`https://${r}`},ws:(n,e)=>{const t=K1(e),r=z1(e),s=q1(e);if(t&&r!=null)return`wss://${r}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Xt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},wss:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=Xt(t[0],t[1]??"",e);return r=r.replace("tcp://",""),`wss://${r}`}};function dg(n,e){const r=re(n).stringTuples(),s=r.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=ne(s[0]),o=hg[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",r);return AE.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const TE=async n=>{if(n.readyState>=2)throw new Error("socket closed");n.readyState!==1&&await new Promise((e,t)=>{function r(){n.removeEventListener("open",s),n.removeEventListener("error",i)}function s(){r(),e()}function i(o){r(),t(o.error??new Error(`connect ECONNREFUSED ${n.url}`))}n.addEventListener("open",s),n.addEventListener("error",i)})},PE=(n,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async r=>{for await(const s of r){try{await TE(n)}catch(i){if(i.message==="socket closed")break;throw i}if(n.readyState===n.CLOSING||n.readyState===n.CLOSED)break;n.send(s)}e.closeOnEnd!=null&&n.readyState<=1&&await new Promise((s,i)=>{n.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{n.close()})})});var ds={},fi={},W1;function CE(){if(W1)return fi;W1=1,Object.defineProperty(fi,"__esModule",{value:!0});class n{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(r){if(this.isStopped)return;const s={value:r,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const r of this.pullQueue)r.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(r){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(r);this.pullQueue.length=0}else{const s=Promise.reject(r);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:r=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(r,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new n;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=r({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return fi.EventIterator=e,fi.default=e,fi}var G1;function DE(){if(G1)return ds;G1=1,Object.defineProperty(ds,"__esModule",{value:!0});const n=CE();ds.EventIterator=n.EventIterator;function e(t,r,s){return new n.EventIterator(({push:i})=>(this.addEventListener(t,i,r),()=>this.removeEventListener(t,i,r)),s)}return ds.subscribe=e,ds.default=n.EventIterator,ds}var RE=DE();function Q1(n){return n instanceof ArrayBuffer||n?.constructor?.name==="ArrayBuffer"&&typeof n?.byteLength=="number"}const ME=n=>{n.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(r){i();return}if(s!=null){o(s);return}const a=u=>{n.removeEventListener("open",c),n.removeEventListener("error",l),u()},c=()=>{a(i)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${n.url}`))})};n.addEventListener("open",c),n.addEventListener("error",l)})},t=async function*(){const i=new RE.EventIterator(({push:o,stop:a,fail:c})=>{const l=h=>{let d=null;typeof h.data=="string"&&(d=V(h.data)),Q1(h.data)&&(d=new Uint8Array(h.data)),h.data instanceof Uint8Array&&(d=h.data),d!=null&&o(d)},u=h=>{c(h.error??new Error("Socket error"))};return n.addEventListener("message",l),n.addEventListener("error",u),n.addEventListener("close",a),()=>{n.removeEventListener("message",l),n.removeEventListener("error",u),n.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Q1(o)?new Uint8Array(o):o}();let r=n.readyState===1,s;return n.addEventListener("open",()=>{r=!0,s=null}),n.addEventListener("close",()=>{r=!1,s=null}),n.addEventListener("error",i=>{r||(s=i.error??new Error(`connect ECONNREFUSED ${n.url}`))}),Object.assign(t,{connected:e})},LE=(n,e)=>{e=e??{};const t=ME(n);let r=e.remoteAddress,s=e.remotePort;if(n.url!=null)try{const o=new URL(n.url);r=o.hostname,s=parseInt(o.port,10)}catch{}if(r==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:PE(n,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(n.readyState===n.CONNECTING||n.readyState===n.OPEN)&&await new Promise(o=>{n.addEventListener("close",()=>{o()}),n.close()})},destroy:()=>{n.terminate!=null?n.terminate():n.close()},remoteAddress:r,remotePort:s,socket:n}},NE=WebSocket,BE={"http:":"ws:","https:":"wss:"},Y1="ws:",OE=(n,e)=>{if(n.startsWith("//")&&(n=`${e?.protocol??Y1}${n}`),n.startsWith("/")&&e!=null){const r=e.protocol??Y1,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";n=`${r}//${s}${i}${n}`}const t=new URL(n);for(const[r,s]of Object.entries(BE))t.protocol===r&&(t.protocol=s);return t};function FE(n,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const r=OE(n,t),s=new NE(r.toString(),e.websocket);return LE(s,e)}function fg(n){return n.filter(e=>Sa.exactMatch(e)||zi.exactMatch(e))}function UE(){throw new Error("WebSocket Servers can not be created in the browser!")}const $E=500;function VE(n,e,t){const r=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:r,async sink(a){try{await n.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&r.error(c)}},source:n.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout($E);a={...a,signal:u}}const l=()=>{const{host:u,port:h}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s after %dms, destroying it manually",u,h,Date.now()-c),this.abort(new Un("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await n.close()}catch(u){r.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s due to error",c,l,a),n.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return n.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}let HE=class{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[Ga]=!0;[Symbol.toStringTag]="@libp2p/websockets";[rt]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=await this._connect(e,t),s=VE(r,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const s=ae(),i=FE(dg(e),this.init);i.socket.addEventListener("error",()=>{const o=new _0(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new Q("websockets:open-connection")),await Ht(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted===!0&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return UE({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):fg(e)}dialFilter(e){return this.listenFilter(e)}};function pg(n={}){return e=>new HE(e,n)}var rl={exports:{}},X1;function zE(){return X1||(X1=1,function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,h,d){if(typeof u!="function")throw new TypeError("The listener must be a function");var f=new s(u,h||c,d),p=t?t+l:l;return c._events[p]?c._events[p].fn?c._events[p]=[c._events[p],f]:c._events[p].push(f):(c._events[p]=f,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,h;if(this._eventsCount===0)return l;for(h in u=this._events)e.call(u,h)&&l.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,h=this._events[u];if(!h)return[];if(h.fn)return[h.fn];for(var d=0,f=h.length,p=new Array(f);d<f;d++)p[d]=h[d].fn;return p},a.prototype.listenerCount=function(l){var u=t?t+l:l,h=this._events[u];return h?h.fn?1:h.length:0},a.prototype.emit=function(l,u,h,d,f,p){var m=t?t+l:l;if(!this._events[m])return!1;var g=this._events[m],y=arguments.length,b,w;if(g.fn){switch(g.once&&this.removeListener(l,g.fn,void 0,!0),y){case 1:return g.fn.call(g.context),!0;case 2:return g.fn.call(g.context,u),!0;case 3:return g.fn.call(g.context,u,h),!0;case 4:return g.fn.call(g.context,u,h,d),!0;case 5:return g.fn.call(g.context,u,h,d,f),!0;case 6:return g.fn.call(g.context,u,h,d,f,p),!0}for(w=1,b=new Array(y-1);w<y;w++)b[w-1]=arguments[w];g.fn.apply(g.context,b)}else{var k=g.length,_;for(w=0;w<k;w++)switch(g[w].once&&this.removeListener(l,g[w].fn,void 0,!0),y){case 1:g[w].fn.call(g[w].context);break;case 2:g[w].fn.call(g[w].context,u);break;case 3:g[w].fn.call(g[w].context,u,h);break;case 4:g[w].fn.call(g[w].context,u,h,d);break;default:if(!b)for(_=1,b=new Array(y-1);_<y;_++)b[_-1]=arguments[_];g[w].fn.apply(g[w].context,b)}}return!0},a.prototype.on=function(l,u,h){return i(this,l,u,h,!1)},a.prototype.once=function(l,u,h){return i(this,l,u,h,!0)},a.prototype.removeListener=function(l,u,h,d){var f=t?t+l:l;if(!this._events[f])return this;if(!u)return o(this,f),this;var p=this._events[f];if(p.fn)p.fn===u&&(!d||p.once)&&(!h||p.context===h)&&o(this,f);else{for(var m=0,g=[],y=p.length;m<y;m++)(p[m].fn!==u||d&&!p[m].once||h&&p[m].context!==h)&&g.push(p[m]);g.length?this._events[f]=g.length===1?g[0]:g:o(this,f)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a}(rl)),rl.exports}var qE=zE();const KE=rs(qE);function WE(n,e,t){let r=0,s=n.length;for(;s>0;){const i=Math.trunc(s/2);let o=r+i;t(n[o],e)<=0?(r=++o,s-=i+1):s=i}return r}let GE=class{#e=[];enqueue(e,t){t={priority:0,...t};const r={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(r);return}const s=WE(this.#e,r,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,r)}setPriority(e,t){const r=this.#e.findIndex(i=>i.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(r,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class Ia extends KE{#e;#t;#r=0;#s;#a;#l=0;#i;#u;#n;#g;#o=0;#h;#c;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:GE,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#t=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#s=e.intervalCap,this.#a=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#c=e.autoStart===!1}get#v(){return this.#t||this.#r<this.#s}get#E(){return this.#o<this.#h}#S(){this.#o--,this.#d(),this.emit("next")}#_(){this.#w(),this.#y(),this.#u=void 0}get#x(){const e=Date.now();if(this.#i===void 0){const t=this.#l-e;if(t<0)this.#r=this.#e?this.#o:0;else return this.#u===void 0&&(this.#u=setTimeout(()=>{this.#_()},t)),!0}return!1}#d(){if(this.#n.size===0)return this.#i&&clearInterval(this.#i),this.#i=void 0,this.emit("empty"),this.#o===0&&this.emit("idle"),!1;if(!this.#c){const e=!this.#x;if(this.#v&&this.#E){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#t||this.#i!==void 0||(this.#i=setInterval(()=>{this.#w()},this.#a),this.#l=Date.now()+this.#a)}#w(){this.#r===0&&this.#o===0&&this.#i&&(clearInterval(this.#i),this.#i=void 0),this.#r=this.#e?this.#o:0,this.#f()}#f(){for(;this.#d(););}get concurrency(){return this.#h}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#h=e,this.#f()}async#k(e){return new Promise((t,r)=>{e.addEventListener("abort",()=>{r(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((r,s)=>{this.#n.enqueue(async()=>{this.#o++,this.#r++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=ao(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#k(t.signal)]));const o=await i;r(o),this.emit("completed",o)}catch(i){if(i instanceof Zp&&!t.throwOnTimeout){r();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#d()})}async addAll(e,t){return Promise.all(e.map(async r=>this.add(r,t)))}start(){return this.#c?(this.#c=!1,this.#f(),this):this}pause(){this.#c=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#p("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#p("next",()=>this.#n.size<e)}async onIdle(){this.#o===0&&this.#n.size===0||await this.#p("idle")}async#p(e,t){return new Promise(r=>{const s=()=>{t&&!t()||(this.off(e,s),r())};this.on(e,s)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#o}get isPaused(){return this.#c}}function gg(n){const e=[gn.A];return n==null?e:Array.isArray(n)?n.length===0?e:n:[n]}const mg=60;function yg(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(e=>({name:e.name,type:gn[e.type]})),Answer:(n.Answer??n.answers??[]).map(e=>({name:e.name,type:gn[e.type],TTL:e.TTL??e.ttl??mg,data:e.data instanceof Uint8Array?K(e.data):e.data}))}}const QE=4;function Z1(n,e={}){const t=new Ia({concurrency:e.queryConcurrency??QE});return async(r,s={})=>{const i=new URLSearchParams;i.set("name",r),gg(s.types).forEach(a=>{i.append("type",gn[a])}),s.onProgress?.(new Q("dns:query",{detail:r}));const o=await t.add(async()=>{const a=await fetch(`${n}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=yg(await a.json());return s.onProgress?.(new Q("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function YE(){return[Z1("https://cloudflare-dns.com/dns-query"),Z1("https://dns.google/resolve")]}var nl,j1;function XE(){return j1||(j1=1,nl=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),r=Object.create(null);function s(i,o){t[i]=o,e++,e>=n&&(e=0,r=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||r[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),r[i]!==void 0&&(r[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=r[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),r=Object.create(null)}}}),nl}var ZE=XE();const jE=rs(ZE);class JE{lru;constructor(e){this.lru=jE(e)}get(e,t){let r=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){r=!1;break}s.push(...o)}if(r)return yg({answers:s})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,s=this.lru.get(r);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:gn[a.type]}));return i.length===0&&this.lru.remove(r),i}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(r)??[];s.push({expires:Date.now()+(t.TTL??mg)*1e3,value:t}),this.lru.set(r,s)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}function eS(n){return new JE(n)}const tS=1e3;let rS=class{resolvers;cache;constructor(e){this.resolvers={},this.cache=eS(e.cacheSize??tS),Object.entries(e.resolvers??{}).forEach(([t,r])=>{Array.isArray(r)||(r=[r]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=r}),this.resolvers["."]==null&&(this.resolvers["."]=YE())}async query(e,t={}){const r=gg(t.types),s=t.cached!==!1?this.cache.get(e,r):void 0;if(s!=null)return t.onProgress?.(new Q("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:r});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new Q("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${r} failed`)}};var gn;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(gn||(gn={}));function wg(n={}){return new rS(n)}const nS=32,{code:sS}=ne("dnsaddr");class iS extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const bg=async function(e,t={}){const r=t.maxRecursiveDepth??nS;if(r===0)throw new iS("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===sS)??[],o=await(t?.dns??wg()).query(`_dnsaddr.${s}`,{signal:t?.signal,types:[gn.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const h=re(u);if(u.startsWith("/dnsaddr")){const d=await h.resolve({...t,maxRecursiveDepth:r-1});c.push(...d.map(f=>f.toString()))}else c.push(h.toString())}return c};var sl,J1;function oS(){return J1||(J1=1,sl=n=>{if(Object.prototype.toString.call(n)!=="[object Object]")return!1;const e=Object.getPrototypeOf(n);return e===null||e===Object.prototype}),sl}var Ao,ef;function aS(){if(ef)return Ao;ef=1;const n=oS(),{hasOwnProperty:e}=Object.prototype,{propertyIsEnumerable:t}=Object,r=(f,p,m)=>Object.defineProperty(f,p,{value:m,writable:!0,enumerable:!0,configurable:!0}),s=Ao,i={concatArrays:!1,ignoreUndefined:!1},o=f=>{const p=[];for(const m in f)e.call(f,m)&&p.push(m);if(Object.getOwnPropertySymbols){const m=Object.getOwnPropertySymbols(f);for(const g of m)t.call(f,g)&&p.push(g)}return p};function a(f){return Array.isArray(f)?c(f):n(f)?l(f):f}function c(f){const p=f.slice(0,0);return o(f).forEach(m=>{r(p,m,a(f[m]))}),p}function l(f){const p=Object.getPrototypeOf(f)===null?Object.create(null):{};return o(f).forEach(m=>{r(p,m,a(f[m]))}),p}const u=(f,p,m,g)=>(m.forEach(y=>{typeof p[y]>"u"&&g.ignoreUndefined||(y in f&&f[y]!==Object.getPrototypeOf(f)?r(f,y,d(f[y],p[y],g)):r(f,y,a(p[y])))}),f),h=(f,p,m)=>{let g=f.slice(0,0),y=0;return[f,p].forEach(b=>{const w=[];for(let k=0;k<b.length;k++)e.call(b,k)&&(w.push(String(k)),b===f?r(g,y++,b[k]):r(g,y++,a(b[k])));g=u(g,b,o(b).filter(k=>!w.includes(k)),m)}),g};function d(f,p,m){return m.concatArrays&&Array.isArray(f)&&Array.isArray(p)?h(f,p,m):!n(p)||!n(f)?a(p):u(f,p,o(p),m)}return Ao=function(...f){const p=d(a(i),this!==s&&this||{},i);let m={_:{}};for(const g of f)if(g!==void 0){if(!n(g))throw new TypeError("`"+g+"` is not an Option Object");m=d(m,{_:g},p)}return m._},Ao}var cS=aS();const Nh=rs(cS),lS={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:n=>n},connectionManager:{resolvers:{dnsaddr:bg}},transportManager:{faultTolerance:Ss.FATAL_ALL}};async function uS(n){const e=Nh(lS,n);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new B("Private network is enforced, but no protector was provided");return e}const zs=1e3,qs=zs*60,Ks=qs*60,Yn=Ks*24,hS=Yn*7,dS=Yn*365.25;function vg(n,e){try{if(typeof n=="string"&&n.length>0)return fS(n);if(typeof n=="number"&&isFinite(n))return e?.long?gS(n):pS(n);throw new Error("Value is not a string or number.")}catch(t){const r=mS(t)?`${t.message}. value=${JSON.stringify(n)}`:"An unknown error has occured.";throw new Error(r)}}function fS(n){if(n=String(n),n.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(!e)return NaN;const t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*dS;case"weeks":case"week":case"w":return t*hS;case"days":case"day":case"d":return t*Yn;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Ks;case"minutes":case"minute":case"mins":case"min":case"m":return t*qs;case"seconds":case"second":case"secs":case"sec":case"s":return t*zs;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${r} was matched, but no matching case exists.`)}}function pS(n){const e=Math.abs(n);return e>=Yn?`${Math.round(n/Yn)}d`:e>=Ks?`${Math.round(n/Ks)}h`:e>=qs?`${Math.round(n/qs)}m`:e>=zs?`${Math.round(n/zs)}s`:`${n}ms`}function gS(n){const e=Math.abs(n);return e>=Yn?To(n,e,Yn,"day"):e>=Ks?To(n,e,Ks,"hour"):e>=qs?To(n,e,qs,"minute"):e>=zs?To(n,e,zs,"second"):`${n} ms`}function To(n,e,t,r){const s=e>=t*1.5;return`${Math.round(n/t)} ${r}${s?"s":""}`}function mS(n){return typeof n=="object"&&n!==null&&"message"in n}function yS(n){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=vg,t.destroy=l,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let d=0;d<u.length;d++)h=(h<<5)-h+u.charCodeAt(d),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,d=null,f,p;function m(...g){if(!m.enabled)return;const y=m,b=Number(new Date),w=b-(h||b);y.diff=w,y.prev=h,y.curr=b,h=b,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let k=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(A,I)=>{if(A==="%%")return"%";k++;const D=t.formatters[I];if(typeof D=="function"){const v=g[k];A=D.call(y,v),g.splice(k,1),k--}return A}),t.formatArgs.call(y,g),(y.log||t.log).apply(y,g)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>d!==null?d:(f!==t.namespaces&&(f=t.namespaces,p=t.enabled(u)),p),set:g=>{d=g}}),typeof t.init=="function"&&t.init(m),m}function r(u,h){const d=t(this.namespace+(typeof h>"u"?":":h)+u);return d.log=this.log,d}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const d=(typeof u=="string"?u:"").split(/[\s,]+/),f=d.length;for(h=0;h<f;h++)d[h]&&(u=d[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,d;for(h=0,d=t.skips.length;h<d;h++)if(t.skips[h].test(u))return!1;for(h=0,d=t.names.length;h<d;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var wS={};const Aa=kS(),bS=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function vS(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function ES(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+vg(this.diff),!this.useColors)return;const e="color: "+this.color;n.splice(1,0,e,"color: inherit");let t=0,r=0;n[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(r=t))}),n.splice(r,0,e)}const SS=console.debug??console.log??(()=>{});function _S(n){try{n?Aa?.setItem("debug",n):Aa?.removeItem("debug")}catch{}}function xS(){let n;try{n=Aa?.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=wS.DEBUG),n}function kS(){try{return localStorage}catch{}}function IS(n){n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Mt=yS({formatArgs:ES,save:_S,load:xS,useColors:vS,setupFormatters:IS,colors:bS,storage:Aa,log:SS});Mt.formatters.b=n=>n==null?"undefined":ze.baseEncode(n);Mt.formatters.t=n=>n==null?"undefined":xt.baseEncode(n);Mt.formatters.m=n=>n==null?"undefined":qt.baseEncode(n);Mt.formatters.p=n=>n==null?"undefined":n.toString();Mt.formatters.c=n=>n==null?"undefined":n.toString();Mt.formatters.k=n=>n==null?"undefined":n.toString();Mt.formatters.a=n=>n==null?"undefined":n.toString();Mt.formatters.e=n=>n==null?"undefined":tf(n.stack)??tf(n.message)??n.toString();function AS(n){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=n,e.destroy=()=>!0,e.extend=()=>e,e}function wc(){return{forComponent(n){return ri(n)}}}function ri(n){let e=AS(`${n}:trace`);return Mt.enabled(`${n}:trace`)&&Mt.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Mt(`${n}:trace`)),Object.assign(Mt(n),{error:Mt(`${n}:error`),trace:e})}function tf(n){if(n!=null&&(n=n.trim(),n.length!==0))return n}function TS(n){return n[Symbol.asyncIterator]!=null}function Ta(n){if(TS(n))return(async()=>{const t=[];for await(const r of n)t.push(r);return t})();const e=[];for(const t of n)e.push(t);return e}const an={},Xn=n=>{n.addEventListener("message",e=>{Xn.dispatchEvent("message",n,e)}),n.port!=null&&n.port.addEventListener("message",e=>{Xn.dispatchEvent("message",n,e)})};Xn.addEventListener=(n,e)=>{an[n]==null&&(an[n]=[]),an[n].push(e)};Xn.removeEventListener=(n,e)=>{an[n]!=null&&(an[n]=an[n].filter(t=>t===e))};Xn.dispatchEvent=function(n,e,t){an[n]!=null&&an[n].forEach(r=>r(e,t))};const rf="lock:worker:request-read",nf="lock:worker:release-read",sf="lock:master:grant-read",of="lock:worker:request-write",af="lock:worker:release-write",cf="lock:master:grant-write",PS=(n=21)=>Math.random().toString().substring(2),lf=(n,e,t,r,s)=>(i,o)=>{if(o.data.type!==t)return;const a={type:o.data.type,name:o.data.name,identifier:o.data.identifier};n.dispatchEvent(new MessageEvent(e,{data:{name:a.name,handler:async()=>{i.postMessage({type:s,name:a.name,identifier:a.identifier}),await new Promise(c=>{const l=u=>{if(u?.data==null)return;const h={type:u.data.type,name:u.data.name,identifier:u.data.identifier};h.type===r&&h.identifier===a.identifier&&(i.removeEventListener("message",l),c())};i.addEventListener("message",l)})}}}))},uf=(n,e,t,r)=>async()=>{const s=PS();return globalThis.postMessage({type:e,identifier:s,name:n}),new Promise(i=>{const o=a=>{if(a?.data==null)return;const c={type:a.data.type,identifier:a.data.identifier};c.type===t&&c.identifier===s&&(globalThis.removeEventListener("message",o),i(()=>{globalThis.postMessage({type:r,identifier:s,name:n})}))};globalThis.addEventListener("message",o)})},CS={singleProcess:!1},DS=n=>{if(n=Object.assign({},CS,n),!!globalThis.document||n.singleProcess){const t=new EventTarget;return Xn.addEventListener("message",lf(t,"requestReadLock",rf,nf,sf)),Xn.addEventListener("message",lf(t,"requestWriteLock",of,af,cf)),t}return{isWorker:!0,readLock:t=>uf(t,rf,sf,nf),writeLock:t=>uf(t,of,cf,af)}},En={};let Qr;async function il(n,e){let t;const r=new Promise(s=>{t=s});return n.add(async()=>ao((async()=>{await new Promise(s=>{t(()=>{s()})})})(),{milliseconds:e.timeout})),r}const RS=(n,e)=>{if(Qr.isWorker===!0)return{readLock:Qr.readLock(n,e),writeLock:Qr.writeLock(n,e)};const t=new Ia({concurrency:1});let r;return{async readLock(){if(r!=null)return il(r,e);r=new Ia({concurrency:e.concurrency,autoStart:!1});const s=r,i=il(r,e);return t.add(async()=>{s.start(),await s.onIdle().then(()=>{r===s&&(r=null)})}),i},async writeLock(){return r=null,il(t,e)}}},MS={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function Bh(n){const e=Object.assign({},MS,n);return Qr==null&&(Qr=DS(e),Qr.isWorker!==!0&&(Qr.addEventListener("requestReadLock",t=>{En[t.data.name]!=null&&En[t.data.name].readLock().then(async r=>t.data.handler().finally(()=>{r()}))}),Qr.addEventListener("requestWriteLock",async t=>{En[t.data.name]!=null&&En[t.data.name].writeLock().then(async r=>t.data.handler().finally(()=>{r()}))}))),En[e.name]==null&&(En[e.name]=RS(e.name,e)),En[e.name]}var Pa;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:oe(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),function(t){let r;t.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Da.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Da.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(l&7);break}}}return a})),r),t.encode=s=>ee(s,t.codec()),t.decode=(s,i)=>J(s,t.codec(),i)}(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.addresses!=null)for(const i of t.addresses)r.uint32(10),Ca.codec().encode(i,r);if(t.protocols!=null)for(const i of t.protocols)r.uint32(18),r.string(i);if(t.publicKey!=null&&(r.uint32(34),r.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:i,value:o},r);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:i,value:o},r);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new _e('Decode error - map field "addresses" had too many elements');i.addresses.push(Ca.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new _e('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Td('Decode error - map field "metadata" had too many elements');const c=n.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Td('Decode error - map field "tags" had too many elements');const c=n.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Pa||(Pa={}));var Ca;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(t.multiaddr)),t.isCertified!=null&&(r.uint32(16),r.bool(t.isCertified)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={multiaddr:oe(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Ca||(Ca={}));var Da;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.value!=null&&t.value!==0&&(r.uint32(8),r.uint32(t.value)),t.expiry!=null&&(r.uint32(16),r.uint64(t.expiry)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={value:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Da||(Da={}));function wi(n,e){const t=Pa.decode(e);if(t.publicKey!=null&&n.publicKey==null){const i=Tt(t.publicKey);n=Ms(i)}const r=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||r.set(i,o);return{...t,id:n,addresses:t.addresses.map(({multiaddr:i,isCertified:o})=>({multiaddr:re(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:r}}const Pr="/",Eg=new TextEncoder().encode(Pr),Po=Eg[0];class Te{_buf;constructor(e,t){if(typeof e=="string")this._buf=V(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Po)throw new Error("Invalid key")}toString(e="utf8"){return K(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Te(e.join(Pr))}static random(){return new Te(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Te(e):typeof e.uint8Array=="function"?new Te(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Eg),this._buf[0]!==Po){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Po,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Po;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let s=0;s<t.length;s++){if(r.length<s+1)return!1;const i=t[s],o=r[s];if(i<o)return!0;if(i>o)return!1}return t.length<r.length}reverse(){return Te.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Pr).slice(1)}type(){return LS(this.baseNamespace())}name(){return NS(this.baseNamespace())}instance(e){return new Te(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Pr)||(e+=Pr),e+=this.type(),new Te(e)}parent(){const e=this.list();return e.length===1?new Te(Pr):new Te(e.slice(0,-1).join(Pr))}child(e){return this.toString()===Pr?e:e.toString()===Pr?this:new Te(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Te.withNamespaces([...this.namespaces(),...BS(e.map(t=>t.namespaces()))])}}function LS(n){const e=n.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function NS(n){const e=n.split(":");return e[e.length-1]}function BS(n){return[].concat(...n)}const Sg="/peers/";function pi(n){if(!v0(n)||n.type==null)throw new B("Invalid PeerId");const e=n.toCID().toString();return new Te(`${Sg}${e}`)}async function OS(n,e,t){const r=new Map;for(const s of t){if(s==null)continue;if(s.multiaddr instanceof Uint8Array&&(s.multiaddr=re(s.multiaddr)),!uc(s.multiaddr))throw new B("Multiaddr was invalid");if(!await e(n,s.multiaddr))continue;const i=s.isCertified??!1,o=s.multiaddr.toString(),a=r.get(o);a!=null?s.isCertified=a.isCertified||i:r.set(o,{multiaddr:s.multiaddr,isCertified:i})}return[...r.values()].sort((s,i)=>s.multiaddr.toString().localeCompare(i.multiaddr.toString())).map(({isCertified:s,multiaddr:i})=>({isCertified:s,multiaddr:i.bytes}))}async function ol(n,e,t,r){if(e==null)throw new B("Invalid PeerData");if(e.publicKey!=null&&n.publicKey!=null&&!e.publicKey.equals(n.publicKey))throw new B("publicKey bytes do not match peer id publicKey bytes");const s=r.existingPeer;if(s!=null&&!n.equals(s.id))throw new B("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,l=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(d=>({isCertified:!1,multiaddr:d}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const d=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Co(d,{validate:hf})}if(e.tags!=null){const d=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Co(d,{validate:df,map:ff})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(d=>({isCertified:!1,multiaddr:d}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const d=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[f,p]of d)p==null?a.delete(f):a.set(f,p);a=Co([...a.entries()],{validate:hf})}if(e.tags!=null){const d=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),f=new Map(c);for(const[p,m]of d)m==null?f.delete(p):f.set(p,m);c=Co([...f.entries()],{validate:df,map:ff})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;s?.id.publicKey!=null?u=rr(s.id.publicKey):e.publicKey!=null?u=rr(e.publicKey):n.publicKey!=null&&(u=rr(n.publicKey));const h={addresses:await OS(n,r.addressFilter??(async()=>!0),i),protocols:[...o.values()].sort((d,f)=>d.localeCompare(f)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return n.type!=="RSA"&&delete h.publicKey,h}function Co(n,e){const t=new Map;for(const[r,s]of n)s!=null&&e.validate(r,s);for(const[r,s]of n.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(r,e.map?.(r,s)??s);return t}function hf(n,e){if(typeof n!="string")throw new B("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new B("Metadata value must be a Uint8Array")}function df(n,e){if(typeof n!="string")throw new B("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new B("Tag value must be an integer");if(e.value<0||e.value>100)throw new B("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new B("Tag ttl must be an integer");if(e.ttl<0)throw new B("Tag ttl must be between greater than 0")}}function ff(n,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function qo(n,e){const t=n.toString().split("/")[2],r=Y.parse(t,xt),s=ro(r);return wi(s,e)}function FS(n){return n==null?{}:{prefix:Sg,filters:(n.filters??[]).map(e=>({key:t,value:r})=>e(qo(t,r))),orders:(n.orders??[]).map(e=>(t,r)=>e(qo(t.key,t.value),qo(r.key,r.value)))}}class US{peerId;datastore;lock;addressFilter;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=Bh({name:"peer-store",singleProcess:!0})}async has(e){return this.datastore.has(pi(e))}async delete(e){if(this.peerId.equals(e))throw new B("Cannot delete self peer");await this.datastore.delete(pi(e))}async load(e){const t=await this.datastore.get(pi(e));return wi(e,t)}async save(e,t){const{existingBuf:r,existingPeer:s}=await this.#e(e),i=await ol(e,t,"patch",{addressFilter:this.addressFilter});return this.#t(e,i,r,s)}async patch(e,t){const{existingBuf:r,existingPeer:s}=await this.#e(e),i=await ol(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:s});return this.#t(e,i,r,s)}async merge(e,t){const{existingBuf:r,existingPeer:s}=await this.#e(e),i=await ol(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return this.#t(e,i,r,s)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(FS(e??{}))){const s=qo(t,r);s.id.equals(this.peerId)||(yield s)}}async#e(e){try{const t=await this.datastore.get(pi(e)),r=wi(e,t);return{existingBuf:t,existingPeer:r}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}return{}}async#t(e,t,r,s){const i=Pa.encode(t);return r!=null&&pe(i,r)?{peer:wi(e,i),previous:s,updated:!1}:(await this.datastore.put(pi(e),i),{peer:wi(e,i),previous:s,updated:!0})}}class $S{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new US(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const r=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),r()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Ta(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async save(e,t){this.log.trace("save await write lock");const r=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("save release write lock"),r()}}async patch(e,t){this.log.trace("patch await write lock");const r=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("patch release write lock"),r()}}async merge(e,t){this.log.trace("merge await write lock");const r=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("merge release write lock"),r()}}async consumePeerRecord(e,t){const r=await br.openAndCertify(e,Lt.DOMAIN),s=ro(r.publicKey.toCID());if(t?.equals(s)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,s),!1;const i=Lt.createFromProtobuf(r.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await br.createFromProtobuf(o.peerRecordEnvelope),c=Lt.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:e,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function VS(n,e={}){return new $S(n,e)}class Ws extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Ws.name;code=Ws.code;constructor(e="Not Found"){super(e)}}function HS(n){return n[Symbol.asyncIterator]!=null}function kn(n,e){let t=0;if(HS(n))return async function*(){for await(const c of n)await e(c,t++)&&(yield c)}();const r=Eh(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of r)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of r)a(c,t++)&&(yield c)}()}function zS(n){return n[Symbol.asyncIterator]!=null}function pf(n,e){return zS(n)?async function*(){yield*(await Ta(n)).sort(e)}():function*(){yield*Ta(n).sort(e)}()}function qS(n){return n[Symbol.asyncIterator]!=null}function Ra(n,e){return qS(n)?async function*(){let t=0;if(!(e<1)){for await(const r of n)if(yield r,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const r of n)if(yield r,t++,t===e)return}}()}class KS{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,s){e.push({key:r,value:s})},delete(r){t.push(r)},commit:async r=>{await pn(this.putMany(e,r)),e=[],await pn(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(e.prefix!=null){const s=e.prefix;r=kn(r,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>kn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>pf(s,i),r)),e.offset!=null){let s=0;const i=e.offset;r=kn(r,()=>s++>=i)}return e.limit!=null&&(r=Ra(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;r=kn(r,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>kn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>pf(s,i),r)),e.offset!=null){const s=e.offset;let i=0;r=kn(r,()=>i++>=s)}return e.limit!=null&&(r=Ra(r,e.limit)),r}}class _g extends KS{data;constructor(){super(),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(t==null)throw new Ws;return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new Te(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new Te(e)}}function WS(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}const gf=864e13,GS=448,al=449,QS=53,YS=54,XS=55,ZS=56;class jS{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const r of this.mappings.values())if(r.domain===t)return!0;return!1}add(e,t){t.forEach(r=>{this.log("add DNS mapping %s to %s",r,e);const s=vn(r)===!0;this.mappings.set(r,{domain:e,verified:s,expires:s?gf-Date.now():0,lastVerified:s?gf-Date.now():void 0})})}remove(e){const t=this.findHost(e);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),r=r||i.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(r,1),r--,t.push({multiaddr:re(`/${i.map(u=>[ne(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let r=0;r<e.length;r++)if(e[r][0]===GS&&e[r+1]?.[0]!==al)return e.splice(r+1,0,[al,t]),!0;return!1}confirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===al||t[0]===QS||t[0]===YS||t[0]===XS||t[0]===ZS)return t[1]}}const cl=4,ll=41,ul=6,JS=273;class e_{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const r of this.mappings.values())for(const s of r)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,r,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:r,externalPort:s,externalFamily:Bs(r)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),r=t[0][1]??"",s=t[1][0]===ul?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===r&&u.externalPort===i&&u.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,r,i,s),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:r}of e){const s=r.stringTuples();let i;if((s[0][0]===cl||s[0][0]===ll)&&s[1][0]===ul?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===cl||s[0][0]===ll)&&s[1][0]===JS&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?cl:ll,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:re(`/${s.map(c=>[ne(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const r=e.stringTuples(),s=r[0][1]??"",i=r[1][0]===ul?"tcp":"udp",o=parseInt(r[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===s&&u.externalPort===o&&u.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,s,o,i),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}const t_=4,r_=41;function n_(n){try{const[[e,t]]=n.stringTuples();if(t==null)return!1;if(e===t_)return t.startsWith("169.254.");if(e===r_)return t.toLowerCase().startsWith("fe80")}catch{}return!1}const s_={maxObservedAddresses:10};class i_{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??s_.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Qn(e)||n_(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:re(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),s=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,s),i}}const o_={maxObservedAddresses:10};class a_{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??o_.maxObservedAddresses}get(e,t){if(Qn(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let s=this.addresses.get(r);return s==null&&(s={verified:!1,expires:0},this.addresses.set(r,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),r=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(r,s),i}unconfirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(r,s),i}toKey(e){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}}const mf=6e4,yf={addressVerificationTTL:mf*10,addressVerificationRetry:mf*5},c_=n=>n;function hl(n,e){const t=n.getPeerId();return t!=null&&Ue(t).equals(e)&&(n=n.decapsulate(re(`/p2p/${e.toString()}`))),n}class l_{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:r=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new i_(e,t),this.dnsMappings=new jS(e,t),this.ipMappings=new e_(e,t),this.transportAddresses=new a_(e,t),this.announceFilter=t.announceFilter??c_,this.observedAddressFilter=Wn(1024),this.addressVerificationTTL=t.addressVerificationTTL??yf.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??yf.addressVerificationRetry,this._updatePeerStoreAddresses=WS(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>re(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>re(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>re(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),r=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=hl(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=hl(e,this.components.peerId);let r=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),r=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)),r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=hl(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(r=>{if(!r.verified)return!1;const s=r.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>r.multiaddr);return this.announceFilter(t.map(r=>{const s=re(r);return s.protos().pop()?.path===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return e.map(r=>({multiaddr:r,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];return t=t.concat(this.components.transportManager.getAddrs().map(r=>this.transportAddresses.get(r,this.addressVerificationTTL))),t=t.concat(this.getAppendAnnounceAddrs().map(r=>({multiaddr:r,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(re(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.add(e,t,r,s,i),this.observed.removePrefixed(`/ip${Bs(r)?4:6}/${r}/${i}/${s}`)}removePublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.remove(re(`/ip${Bs(r)?4:6}/${r}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||vn(t.host)===!0)return!1;const r=this.components.transportManager.getListeners(),s=[i=>zi.exactMatch(i)||Sa.exactMatch(i),i=>Ea.exactMatch(i),i=>eb.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=r.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&i(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var wf;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.NOT_FOUND="Not found"})(wf||(wf={}));class u_ extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class h_ extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class dl extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class bf extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class d_ extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class f_ extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class p_ extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class vf extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class du extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class g_ extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class m_ extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Do extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Ro extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class y_ extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class w_{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;this.components.logger==null&&(this.components.logger=wc())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>Hu(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const b_=["metrics","connectionProtector","dns"],v_=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function E_(n={}){const e=new w_(n);return new Proxy(e,{get(r,s,i){if(typeof s=="string"&&!v_.includes(s)){const o=e.components[s];if(o==null&&!b_.includes(s))throw new u_(`${s} not set`);return o}return Reflect.get(r,s,i)},set(r,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(r,s,i),!0}})}function S_(n){const e={};for(const t of Object.values(n.components))for(const r of __(t))e[r]=!0;for(const t of Object.values(n.components))for(const r of x_(t))if(e[r]!==!0)throw new h_(`Service "${k_(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function __(n){return Array.isArray(n?.[rt])?n[rt]:[]}function x_(n){return Array.isArray(n?.[cn])?n[cn]:[]}function k_(n){return n?.[Symbol.toStringTag]??n?.toString()??"unknown"}const I_=4,A_=41;function T_(n={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(zi.matches(e))return!1;const t=e.stringTuples();return t[0][0]===I_||t[0][0]===A_?!!vn(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...n}}class xg{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new P_}async consume(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new xb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await Kp(a)}return o}penalty(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:s,isFirstInDuration:!1}}set(e,t,r=0){const s=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class P_{storage;constructor(){this.storage=new Map}incrby(e,t,r){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const s=r*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function kg(n){if(v0(n))return{peerId:n,multiaddrs:[]};Array.isArray(n)||(n=[n]);let e;if(n.length>0){const t=n[0].getPeerId();e=t==null?void 0:Ue(t),n.forEach(r=>{if(!uc(r))throw new Uu("Invalid multiaddr");const s=r.getPeerId();if(s==null){if(e!=null)throw new B("Multiaddrs must all have the same peer id or have no peer id")}else{const i=Ue(s);if(e?.equals(i)!==!0)throw new B("Multiaddrs must all have the same peer id or have no peer id")}})}return{peerId:e,multiaddrs:n}}const C_=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function D_(n,e){const t=n?.streams?.map(s=>s.protocol)??[],r=e?.closableProtocols??C_;if(!(t.filter(s=>s!=null&&!r.includes(s)).length>0))try{await n?.close(e)}catch(s){n?.abort(s)}}const Ig=5e3,Ef=3e3,Sf=2e3,Ag=25,R_=5,M_=10,L_=5,N_="last-dial-failure",B_="last-dial-success",Tg=500,Pg=100,Cg=50;async function O_(n,e){let t=!1;for(const s of Sh.keys())if(t=n.protoNames().includes(s),t)break;if(!t)return[n];const r=await n.resolve(e);return e.log("resolved %s to",n,r.map(s=>s.toString())),r}function fu(n){try{let e;if(typeof n=="string"?e=re(n):e=n,!e.protoNames().includes("ipcidr")){const r=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(r)}return ly(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${n}`)}}const F_={maxConnections:Pg};class U_{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??F_.maxConnections,this.allow=(t.allow??[]).map(r=>fu(r)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const r=new bn;for(const a of e){const c=a.remotePeer;if(!r.has(c)){r.set(c,0);try{const l=await this.peerStore.get(c);r.set(c,[...l.tags.values()].reduce((u,h)=>u+h.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,r),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await D_(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((r,s)=>{const i=r.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((r,s)=>r.direction==="outbound"&&s.direction==="inbound"?1:r.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((r,s)=>r.streams.length>s.streams.length?1:r.streams.length<s.streams.length?-1:0).sort((r,s)=>{const i=t.get(r.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class $_ extends Gn{constructor(e={}){super({...e,sort:(t,r)=>t.options.priority>r.options.priority?-1:t.options.priority<r.options.priority?1:0})}}function V_(n,e){const t=Ea.exactMatch(n.multiaddr),r=Ea.exactMatch(e.multiaddr);if(t&&!r)return-1;if(!t&&r)return 1;const s=Sa.exactMatch(n.multiaddr),i=Sa.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=zi.exactMatch(n.multiaddr),a=zi.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=au.exactMatch(n.multiaddr),l=au.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=ou.exactMatch(n.multiaddr),h=ou.exactMatch(e.multiaddr);if(u&&!h)return-1;if(!u&&h)return 1;const d=E1.exactMatch(n.multiaddr),f=E1.exactMatch(e.multiaddr);return d&&!f?-1:!d&&f?1:0}function H_(n,e){const t=Qn(n.multiaddr),r=Qn(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function z_(n,e){return n.isCertified&&!e.isCertified?-1:!n.isCertified&&e.isCertified?1:0}function q_(n,e){const t=dn.exactMatch(n.multiaddr),r=dn.exactMatch(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function K_(n){return n.sort(V_).sort(z_).sort(q_).sort(H_)}const Mo={maxParallelDials:Cg,maxDialQueueLength:Tg,maxPeerAddrsToDial:Ag,dialTimeout:Ig};class W_{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Mo.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Mo.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Mo.dialTimeout,this.connections=t.connections??new bn,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[r,s]of Object.entries(t.resolvers??{}))Sh.set(r,s);this.queue=new $_({concurrency:t.maxParallelDials??Mo.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",r=>{r.detail.name!==Un.name&&this.log.error("error in dial queue - %e",r.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:s}=kg(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(r)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new Q("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(r?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of s)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",r);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new Q("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Ei("Dial queue is full");return this.log("creating dial target for %p",r,s.map(a=>a.toString())),t.onProgress?.(new Q("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a?.onProgress?.(new Q("dial-queue:start-dial"));const c=be([this.shutDownController.signal,a.signal]);let l;try{l=await this.calculateMultiaddrs(r,a?.multiaddrs,{...a,signal:c}),a?.onProgress?.(new Q("dial-queue:calculated-addresses",l)),l.map(({multiaddr:u})=>u.toString()).forEach(u=>{a?.multiaddrs.add(u)})}catch(u){throw c.clear(),u}try{let u=0;const h=[];for(const d of l){if(u===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",u,r),new Ei("Peer had more than maxPeerAddrsToDial");u++;try{const f=await this.components.transportManager.dial(d.multiaddr,{...a,signal:c});this.log("dial to %a succeeded",d.multiaddr);try{await this.components.peerStore.merge(f.remotePeer,{multiaddrs:[f.remoteAddr],metadata:{[B_]:V(Date.now().toString())}})}catch(p){this.log.error("could not update last dial failure key for %p",r,p)}return f}catch(f){if(this.log.error("dial failed to %a",d.multiaddr,f),r!=null)try{await this.components.peerStore.merge(r,{metadata:{[N_]:V(Date.now().toString())}})}catch(p){this.log.error("could not update last dial failure key for %p",r,p)}if(c.aborted)throw new Ya(f.message);h.push(f)}}throw h.length===1?h[0]:new AggregateError(h,"All multiaddr dials failed")}finally{c.clear()}},{peerId:r,priority:t.priority??Dg,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async calculateMultiaddrs(e,t=new Set,r={}){const s=[...t].map(h=>({multiaddr:re(h),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Ei("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new vf("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const h=await this.components.peerStore.get(e);s.push(...h.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:d})=>d.toString()))}catch(h){if(h.name!=="NotFoundError")throw h}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const h=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:d})=>d.toString())),s.push(...h.multiaddrs.map(d=>({multiaddr:d,isCertified:!1})))}catch(h){h.name!=="NoPeerRoutersError"&&this.log.error("looking up multiaddrs for %p in the peer routing failed",e,h)}}}let i=(await Promise.all(s.map(async h=>{const d=await O_(h.multiaddr,{dns:this.components.dns,...r,log:this.log});return d.length===1&&d[0].equals(h.multiaddr)?h:d.map(f=>({multiaddr:f,isCertified:!1}))}))).flat();if(e!=null){const h=`/p2p/${e.toString()}`;i=i.map(d=>d.multiaddr.protos().pop()?.path===!0?d:d.multiaddr.getPeerId()==null?{multiaddr:d.multiaddr.encapsulate(h),isCertified:d.isCertified}:d)}const o=i.filter(h=>{if(this.components.transportManager.dialTransportForMultiaddr(h.multiaddr)==null)return!1;const d=h.multiaddr.getPeerId();return e!=null&&d!=null?e.equals(d):!0}),a=new Map;for(const h of o){const d=h.multiaddr.toString(),f=a.get(d);if(f!=null){f.isCertified=f.isCertified||h.isCertified||!1;continue}a.set(d,h)}const c=[...a.values()];if(c.length===0)throw new du("The dial request has no valid addresses");const l=[];for(const h of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(h.multiaddr)||l.push(h);const u=this.addressSorter==null?K_(l):l.sort(this.addressSorter);if(u.length===0)throw new vf("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:h})=>h.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:h})=>h.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?r.find(s=>!dn.matches(s.multiaddr))!=null:!0}catch(r){this.log.trace("error calculating if multiaddr(s) were dialable",r)}return!1}}var fl={},pl,_f;function G_(){if(_f)return pl;_f=1;function n(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return pl=n,n.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},n.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},n.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},r),this._options.unref&&this._timer.unref(),!0},n.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},n.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},n.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},n.prototype.start=n.prototype.try,n.prototype.errors=function(){return this._errors},n.prototype.attempts=function(){return this._attempts},n.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,r=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=r&&(t=i,r=a)}return t},pl}var xf;function Q_(){return xf||(xf=1,function(n){var e=G_();n.operation=function(t){var r=n.timeouts(t);return new e(r,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},n.timeouts=function(t){if(t instanceof Array)return[].concat(t);var r={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)r[s]=t[s];if(r.minTimeout>r.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<r.retries;o++)i.push(this.createTimeout(o,r));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,r)),i.sort(function(a,c){return a-c}),i},n.createTimeout=function(t,r){var s=r.randomize?Math.random()+1:1,i=Math.round(s*Math.max(r.minTimeout,1)*Math.pow(r.factor,t));return i=Math.min(i,r.maxTimeout),i},n.wrap=function(t,r,s){if(r instanceof Array&&(s=r,r=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(u){var h=n.operation(r),d=Array.prototype.slice.call(arguments,1),f=d.pop();d.push(function(p){h.retry(p)||(p&&(arguments[0]=h.mainError()),f.apply(this,arguments))}),h.attempt(function(){u.apply(t,d)})}.bind(t,c),t[a].options=r}}}(fl)),fl}var gl,kf;function Y_(){return kf||(kf=1,gl=Q_()),gl}var X_=Y_();const Z_=rs(X_),j_=Object.prototype.toString,J_=n=>j_.call(n)==="[object Error]",ex=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function tx(n){return n&&J_(n)&&n.name==="TypeError"&&typeof n.message=="string"?n.message==="Load failed"?n.stack===void 0:ex.has(n.message):!1}class rx extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const If=(n,e,t)=>{const r=t.retries-(e-1);return n.attemptNumber=e,n.retriesLeft=r,n};async function nx(n,e){return new Promise((t,r)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=Z_.operation(e),i=()=>{s.stop(),r(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await n(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof rx)throw c.originalError;if(c instanceof TypeError&&!tx(c))throw c;if(If(c,a,e),await e.shouldRetry(c)||(s.stop(),r(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){If(l,a,e),o(),r(l)}}})})}class sx{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new fn({concurrency:t.maxParallelReconnects??L_,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",r=>{this.maybeReconnect(r.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",r.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Af(t)&&(this.queue.has(e)||this.queue.add(async r=>{await nx(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:r?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:r?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(Wa)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async r=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,r)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>Af(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(r=>{this.log.error(r)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function Af(n){for(const e of n.tags.keys())if(e.startsWith(Wa))return!0;return!1}const Dg=50,ml={maxConnections:Pg,inboundConnectionThreshold:R_,maxIncomingPendingConnections:M_};class ix{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??ml.maxConnections,this.maxConnections<1)throw new B("Connection Manager maxConnections must be greater than 0");this.connections=new bn,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(r=>fu(r)),this.deny=(t.deny??[]).map(r=>fu(r)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??ml.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new xg({points:t.inboundConnectionThreshold??ml.inboundConnectionThreshold,duration:1}),this.connectionPruner=new U_({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(r=>re(r))}),this.dialQueue=new W_(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??Cg,maxDialQueueLength:t.maxDialQueueLength??Tg,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Ag,dialTimeout:t.dialTimeout??Ig,resolvers:t.resolvers??{dnsaddr:bg},connections:this.connections}),this.reconnectQueue=new sx({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const s of r.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const r of this.connections.values())for(const s of r){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[r,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[r]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Nr(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await wn(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const r=t.remotePeer,s=!this.connections.has(r),i=this.connections.get(r)??[];i.push(t),this.connections.set(r,i),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,i=(this.connections.get(r)??[]).filter(o=>o.id!==t.id);this.connections.set(r,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new Ri("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=kg(e);if(this.peerId.equals(r))throw new x0("Can not dial self");if(r!=null&&t.force!==!0){this.log("dial %p",r);const a=this.getConnections(r).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new Q("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Dg});if(s.status!=="open")throw new S0("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new Uu("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(r=>re(r))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class yl{movingAverage;variance;deviation;forecast;timespan;previousTime;constructor(e){this.timespan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timespan)}push(e,t=Date.now()){if(this.previousTime!=null){const r=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=r*s;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=e;this.previousTime=t}}const ox=1.2,ax=2,cx=2e3;class qi{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;constructor(e={}){this.success=new yl(e.interval??5e3),this.failure=new yl(e.interval??5e3),this.next=new yl(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??ax,this.timeoutMultiplier=e.timeoutMultiplier??ox,this.minTimeout=e.minTimeout??cx,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),r=AbortSignal.timeout(t),s=be([e.signal,r]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const lx=1e4,ux="1.0.0",hx="ping",dx="ipfs",Tf=32,fx=!0;class px{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??dx}/${hx}/${ux}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??lx,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??fx,this.timeout=new qi({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[rt]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}),i=la(s);t=Date.now(),await Promise.all([i.write(un(Tf),{signal:r}),i.read(Tf,{signal:r})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:r})}catch(r){if(r.name!=="UnsupportedProtocolError")throw r;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class gx{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()}),getAttributesFromYieldedValue:(r,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],r.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([r])=>({key:K(r,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([r])=>({key:K(r,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new dl("No content routers available");const r=this,s=new sr;for await(const i of sn(...r.routers.map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new dl("No content routers available");await Promise.all(this.routers.map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new dl("No content routers available");await Promise.all(this.routers.map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new Ri;await Promise.all(this.routers.map(async s=>{await s.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new Ri;return Promise.any(this.routers.map(async r=>r.get(e,t)))}}class mx{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,peer:r.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,key:K(r,"base36")}),getAttributesFromYieldedValue:(r,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],r.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new bf("No peer routers available");if(e.toString()===this.peerId.toString())throw new d_("Should not try to find self");const r=this,s=sn(...this.routers.map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new It}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new bf("No peer routers available");const r=this,s=Wn(1024);for await(const i of oo(async function*(){const o=sn(...r.routers.map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...t,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class yx extends Ke{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=be([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=ae(),yield(await zt(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=be([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=un(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Ht(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,r)}catch(s){this.log.error("randomwalk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("randomwalk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1})}}const Rg=32,Mg=64;class wx{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new f_(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e)&&r?.force!==!0)throw new p_(`Handler already registered for protocol ${e}`);const s=Nh.bind({ignoreUndefined:!0})({maxInboundStreams:Rg,maxOutboundStreams:Mg},r);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(r=>{this.handlers.delete(r)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new B("invalid topology");const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),r.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(r=>{for(const s of r.protocols){const i=this.topologies.get(s);if(i!=null)for(const o of i.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(r=>{r.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,r)})}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,s=(r?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())r.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,r))}}}class bx extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Lg(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new bx({name:e,metrics:t}):r=new Map,r}class vx{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=Lg({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ss.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new B("Transport must have a valid tag");if(this.transports.has(t))throw new B(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const s=r.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(r==null)throw new y_(`No transport available for address ${String(e)}`);return t?.onProgress?.(new Q("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new Ri("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t=[];for(const[r,s]of this.transports.entries()){const i=s.listenFilter(e),o=[];for(const l of i){this.log("creating listener for %s on %a",r,l);const u=s.createListener({upgrader:this.components.upgrader});let h=this.listeners.get(r)??[];h==null&&(h=[],this.listeners.set(r,h)),h.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const d=h.findIndex(f=>f===u);h.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),o.push(u.listen(l))}if(o.length===0){t.push(r);continue}if((await Promise.allSettled(o)).find(l=>l.status==="fulfilled")==null&&this.faultTolerance!==Ss.NO_FATAL)throw new du(`Transport (${r}) could not listen on any available address`)}if(t.length===this.transports.size){const r=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===Ss.FATAL_ALL)throw new du(r);this.log(`libp2p in dial mode only: ${r}`)}}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&r.push(s.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const St="/multistream/1.0.0",Oh=1024,Ex=V(`
`);async function bi(n,e,t){await n.write(e,t)}async function Sx(n,e,t){await n.writeV(e,t)}async function _x(n,e){const t=await n.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==Ex[0])throw e.log.error("Invalid mss message - missing newline",t),new Pe("Missing newline");return t.sublist(0,-1)}async function ks(n,e){const t=await _x(n,e);return K(t.subarray())}async function wl(n,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return xx(n,e[0],t);const r=Os(n,{...t,maxDataLength:Oh}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',St,s);const i=V(`${St}
`),o=V(`${s}
`);await Sx(r,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await ks(r,t);if(t.log.trace('select: read "%s"',a),a===St&&(t.log.trace("select: reading protocol response"),a=await ks(r,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await bi(r,V(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await ks(r,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:r.unwrap(),protocol:c}}throw new Qa("protocol selection failed")}function xx(n,e,t){const r=n.sink.bind(n),s=n.source;let i=!1,o=!1;const a=ae();let c=!1,l=!1;const u=ae();let h=!1,d=!1;const f=ae(),p=Os({sink:r,source:s},{...t,maxDataLength:Oh});n.sink=async b=>{const{sink:w}=p.unwrap();await w(async function*(){let k=!1;for await(const _ of b){if(l&&await u.promise,c)yield _;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',St,e,_.byteLength);const A=`${e}
`;yield new ge(Uint8Array.from([19]),V(`${St}
`),Ze(A.length),V(A),_).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',St,e,_.byteLength),c=!0,l=!1,u.resolve(),m().catch(I=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,I)})}k=!0}k||await m()}())};async function m(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await g()),h||(t.log.trace("optimistic: doing read protocol for %s stream",e),await y())}finally{o=!1,i=!0,a.resolve()}}async function g(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',St,e),await p.writeV([V(`${St}
`),V(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',St,e)}finally{c=!0,l=!1,u.resolve()}}async function y(){if(d){await f.promise;return}d=!0;try{t.log.trace("optimistic: reading multistream select header");let b=await ks(p,t);if(t.log.trace('optimistic: read multistream select header "%s"',b),b===St&&(b=await ks(p,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',b,e),b!==e)throw new Qa("protocol selection failed")}finally{h=!0,d=!1,f.resolve()}}if(n.source=async function*(){await m(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*p.unwrap().source}(),n.closeRead!=null){const b=n.closeRead.bind(n);n.closeRead=async w=>{i||await m().catch(k=>{t.log.error("could not negotiate protocol before close read",k)}),await b(w)}}if(n.closeWrite!=null){const b=n.closeWrite.bind(n);n.closeWrite=async w=>{i||await m().catch(k=>{t.log.error("could not negotiate protocol before close write",k)}),await b(w)}}if(n.close!=null){const b=n.close.bind(n);n.close=async w=>{const k=[];l&&k.push(u.promise),d&&k.push(f.promise),k.length>0?await Ht(Promise.all(k),w?.signal):(i=!0,o=!1,a.resolve()),await b(w)}}return{stream:n,protocol:e}}const Ng=1024*1024*4;let kx=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"};function Ix(n){return n[Symbol.asyncIterator]!=null}function Bg(n,e){if(n.byteLength>e)throw new kx("Message length too long")}const bc=n=>{const e=ye(n),t=ct(e);return Ze(n,t),bc.bytes=e,t};bc.bytes=0;function Og(n,e){e=e??{};const t=e.lengthEncoder??bc,r=e?.maxDataLength??Ng;function*s(i){Bg(i,r);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Ix(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}Og.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??bc,r=e?.maxDataLength??Ng;return Bg(n,r),new ge(t(n.byteLength),n)};var Pf;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Pf||(Pf={}));async function bl(n,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const r=Os(n,{...t,maxDataLength:Oh,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await ks(r,t);if(t.log.trace('handle: read "%s"',s),s===St){t.log.trace('handle: respond with "%s" for "%s"',St,s),await bi(r,V(`${St}
`),t),t.log.trace('handle: responded with "%s" for "%s"',St,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await bi(r,V(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:r.unwrap(),protocol:s};if(s==="ls"){const i=new ge(...e.map(o=>Og.single(V(`${o}
`))),V(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await bi(r,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await bi(r,V(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const Ax=500;class Tx{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[r6]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new s6("the connection is being closed");if(this.status==="closed")throw new S0("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new k0("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(Ax);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function Px(n){return new Tx(n)}function Cx(n,e){try{const{options:t}=e.getHandler(n);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Rg}function Dx(n,e,t={}){try{const{options:r}=e.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.name!=="UnhandledProtocolError")throw r}return t.maxOutboundStreams??Mg}function Cf(n,e,t){let r=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===n&&r++}),r}class Rx{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;outboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(r=>{this.connectionEncrypters.set(r.protocol,r)}),this.streamMuxers=new Map,t.streamMuxers.forEach(r=>{this.streamMuxers.set(r.protocol,r)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??Ef,this.outboundUpgradeTimeout=t.outboundUpgradeTimeout??Ef,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??Sf,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??Sf,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(r==null)return;if(await r.apply(this.components.connectionGater,t)===!0)throw new g_(`The multiaddr connection is blocked by gater.${e}`)}async upgradeInbound(e,t={}){let r=!1;try{if(this.metrics.dials?.increment({inbound:!0}),r=await this.components.connectionManager.acceptIncomingConnection(e),!r)throw new m_("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",t)}catch(s){throw this.metrics.errors?.increment({inbound:!0}),s}finally{r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t={}){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let s;r!=null&&(s=Ue(r),await this.shouldBlockConnection("denyOutboundConnection",s,e));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(r){throw this.metrics.errors?.increment({outbound:!0}),r}}async _performUpgrade(e,t,r){let s,i,o,a,c;if(r.signal==null){e.log("no abort signal was passed while trying to upgrade connection, falling back to default timeout");const u=AbortSignal.timeout(t==="inbound"?this.inboundUpgradeTimeout:this.outboundUpgradeTimeout);r.signal=u}this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(r?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,r))}try{if(s=l,r?.skipEncryption!==!0){r?.onProgress?.(new Q(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c}=await(t==="inbound"?this._encryptInbound(l,r):this._encryptOutbound(l,r));const u={...l,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new Uu(`${t} connection that skipped encryption must have a peer id`);const h=Ue(u);c="native",i=h}if(i.equals(this.components.peerId)){const u=new x0("Can not dial self");throw e.abort(u),u}if(o=s,r?.muxerFactory!=null)a=r.muxerFactory;else if(this.streamMuxers.size>0){r?.onProgress?.(new Q(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,r):this._multiplexOutbound({...l,...s},this.streamMuxers,r));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,h;a!=null&&(l=a.createStreamMuxer({direction:r,onIncomingStream:p=>{h!=null&&Promise.resolve().then(async()=>{const m=this.components.registrar.getProtocols(),g=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:y,protocol:b}=await bl(p,m,{signal:g,log:p.log,yieldBytes:!1});if(h==null)return;h.log("incoming stream opened on %s",b);const w=Cx(b,this.components.registrar);if(Cf(b,"inbound",h)===w){const _=new c6(`Too many inbound protocol streams for protocol "${b}" - limit ${w}`);throw p.abort(_),_}p.source=y.source,p.sink=y.sink,p.protocol=b,y.closeWrite!=null&&(p.closeWrite=y.closeWrite),y.closeRead!=null&&(p.closeRead=y.closeRead),y.close!=null&&(p.close=y.close),await this.components.peerStore.merge(o,{protocols:[b]}),this.components.metrics?.trackProtocolStream(p,h),this._onStream({connection:h,stream:p,protocol:b})}).catch(async m=>{h.log.error("error handling incoming stream id %s - %e",p.id,m),p.timeline.close==null&&await p.close()})}}),u=async(p,m={})=>{if(l==null)throw new Do("Connection is not multiplexed");h.log.trace("starting new stream for protocols %s",p);const g=await l.newStream();h.log.trace("started new stream %s for protocols %s",g.id,p);try{if(m.signal==null){g.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",p);const _=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);m={...m,signal:_}}g.log.trace("selecting protocol from protocols %s",p);const{stream:y,protocol:b}=await wl(g,p,{...m,log:g.log,yieldBytes:!0});g.log.trace("selected protocol %s",b);const w=Dx(b,this.components.registrar,m),k=Cf(b,"outbound",h);if(k>=w){const _=new Vu(`Too many outbound protocol streams for protocol "${b}" - ${k}/${w}`);throw g.abort(_),_}return await this.components.peerStore.merge(o,{protocols:[b]}),g.source=y.source,g.sink=y.sink,g.protocol=b,y.closeWrite!=null&&(g.closeWrite=y.closeWrite),y.closeRead!=null&&(g.closeRead=y.closeRead),y.close!=null&&(g.close=y.close),this.components.metrics?.trackProtocolStream(g,h),g}catch(y){throw h.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",r==="inbound"?"from":"to",e.maConn.remoteAddr,p,y),g.timeline.close==null&&g.abort(y),y}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(p=>{h.log.error("error piping data through muxer - %e",p)}));const d=s.timeline;s.timeline=new Proxy(d,{set:(...p)=>(p[1]==="close"&&p[2]!=null&&d.close==null&&(async()=>{try{h.status==="open"&&await h.close()}catch(m){h.log.error("error closing connection after timeline close %e",m)}finally{this.events.safeDispatchEvent("connection:close",{detail:h})}})().catch(m=>{h.log.error("error thrown while dispatching connection:close event %e",m)}),Reflect.set(...p))}),s.timeline.upgraded=Date.now();const f=()=>{throw new Do("Connection is not multiplexed")};return h=Px({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:s.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??f,getStreams:()=>l?.streams??[],close:async p=>{await l?.close(p),await s.close(p)},abort:p=>{s.abort(p),l?.abort(p)}}),this.events.safeDispatchEvent("connection:open",{detail:h}),h.__maConnTimeline=d,h}_onStream(e){const{connection:t,stream:r,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new k0("Cannot open protocol stream on limited connection");i({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await bl(e,r,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Ro(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Ro(s.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:s,protocol:i}=await wl(e,r,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Ro(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Ro(s.message)}}async _multiplexOutbound(e,t,r){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await wl(e,s,{...r,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new Do(String(i))}}async _multiplexInbound(e,t,r){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await bl(e,s,{...r,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new Do(String(i))}}}const Mx="2.6.3",pu="js-libp2p";function Fg(n,e){return`${n??pu}/${e??Mx} browser/${globalThis.navigator.userAgent}`}class Lx extends Ke{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Ke,r=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=r(l),h=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||h},this.peerId=e.peerId,this.logger=e.logger??wc(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??pu,i=e.nodeInfo?.version??pu,o=this.components=E_({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??Fg(s,i)},logger:this.logger,events:t,datastore:e.datastore??new _g,connectionGater:T_(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",VS(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(h=>h.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new Rx(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,outboundUpgradeTimeout:e.connectionManager?.outboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new vx(this.components,e.transportManager)),this.configureComponent("connectionManager",new ix(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new px(this.components,e.connectionMonitor)),this.configureComponent("registrar",new wx(this.components)),this.configureComponent("addressManager",new l_(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new mx(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new gx(this.components,{routers:c})),this.configureComponent("randomWalk",new yx(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",d=>{this.#e(d)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],h=u(this.components);if(h==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=h,this.configureComponent(l,h),h[As]!=null&&(this.log("registering service %s for content routing",l),c.push(h[As])),h[Ts]!=null&&(this.log("registering service %s for peer routing",l),a.push(h[Ts])),h[Qo]!=null&&(this.log("registering service %s for peer discovery",l),h[Qo].addEventListener?.("peer",d=>{this.#e(d)}))}S_(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new sr;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(t==null)throw new B("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new B("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){uc(e)&&(e=Ue(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const r=We([V("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(r,t),i=Tt(s);return await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,r)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(r=>{this.log.error(r)})}}async function Ug(n={}){n.privateKey??=await B3("Ed25519");const e=new Lx({...await uS(n),peerId:ym(n.privateKey)});return n.start!==!1&&await e.start(),e}function Nx(n){return n[Symbol.asyncIterator]!=null}function ni(n,e){let t=0;if(Nx(n))return async function*(){for await(const c of n)yield e(c,t++)}();const r=Eh(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){yield await o;for await(const c of r)yield e(c,t++)}();const a=e;return function*(){yield o;for(const c of r)yield a(c,t++)}()}const Lo="/ipfs/bitswap/1.2.0",Bx=1024,Ox=1024,Fx=1024,Ux=5e3,$x=10,Vx=50,Hx=!1,zx=3,$g=1024*1024*4,qx=$g;var Ye;(function(n){n.WantBlock="WantBlock",n.WantHave="WantHave"})(Ye||(Ye={}));var gu;(function(n){n[n.WantBlock=0]="WantBlock",n[n.WantHave=1]="WantHave"})(gu||(gu={}));(function(n){n.codec=()=>At(gu)})(Ye||(Ye={}));var Ki;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.cid!=null&&t.cid.byteLength>0&&(r.uint32(10),r.bytes(t.cid)),t.priority!=null&&t.priority!==0&&(r.uint32(16),r.int32(t.priority)),t.cancel!=null&&(r.uint32(24),r.bool(t.cancel)),t.wantType!=null&&(r.uint32(32),Ye.codec().encode(t.wantType,r)),t.sendDontHave!=null&&(r.uint32(40),r.bool(t.sendDontHave)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={cid:oe(0),priority:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.cid=t.bytes();break}case 2:{i.priority=t.int32();break}case 3:{i.cancel=t.bool();break}case 4:{i.wantType=Ye.codec().decode(t);break}case 5:{i.sendDontHave=t.bool();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Ki||(Ki={}));var Ma;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.entries!=null)for(const i of t.entries)r.uint32(10),Ki.codec().encode(i,r);t.full!=null&&(r.uint32(16),r.bool(t.full)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={entries:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.entries!=null&&i.entries.length===s.limits.entries)throw new _e('Decode error - map field "entries" had too many elements');i.entries.push(Ki.codec().decode(t,t.uint32(),{limits:s.limits?.entries$}));break}case 2:{i.full=t.bool();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Ma||(Ma={}));var Wi;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.prefix!=null&&t.prefix.byteLength>0&&(r.uint32(10),r.bytes(t.prefix)),t.data!=null&&t.data.byteLength>0&&(r.uint32(18),r.bytes(t.data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={prefix:oe(0),data:oe(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.prefix=t.bytes();break}case 2:{i.data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Wi||(Wi={}));var vr;(function(n){n.HaveBlock="HaveBlock",n.DontHaveBlock="DontHaveBlock"})(vr||(vr={}));var La;(function(n){n[n.HaveBlock=0]="HaveBlock",n[n.DontHaveBlock=1]="DontHaveBlock"})(La||(La={}));(function(n){n.codec=()=>At(La)})(vr||(vr={}));var Gi;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.cid!=null&&t.cid.byteLength>0&&(r.uint32(10),r.bytes(t.cid)),t.type!=null&&La[t.type]!==0&&(r.uint32(16),vr.codec().encode(t.type,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={cid:oe(0),type:vr.HaveBlock},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.cid=t.bytes();break}case 2:{i.type=vr.codec().decode(t);break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Gi||(Gi={}));var Qi;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.wantlist!=null&&(r.uint32(10),Ma.codec().encode(t.wantlist,r)),t.blocks!=null)for(const i of t.blocks)r.uint32(26),Wi.codec().encode(i,r);if(t.blockPresences!=null)for(const i of t.blockPresences)r.uint32(34),Gi.codec().encode(i,r);t.pendingBytes!=null&&t.pendingBytes!==0&&(r.uint32(40),r.int32(t.pendingBytes)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={blocks:[],blockPresences:[],pendingBytes:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.wantlist=Ma.codec().decode(t,t.uint32(),{limits:s.limits?.wantlist});break}case 3:{if(s.limits?.blocks!=null&&i.blocks.length===s.limits.blocks)throw new _e('Decode error - map field "blocks" had too many elements');i.blocks.push(Wi.codec().decode(t,t.uint32(),{limits:s.limits?.blocks$}));break}case 4:{if(s.limits?.blockPresences!=null&&i.blockPresences.length===s.limits.blockPresences)throw new _e('Decode error - map field "blockPresences" had too many elements');i.blockPresences.push(Gi.codec().decode(t,t.uint32(),{limits:s.limits?.blockPresences$}));break}case 5:{i.pendingBytes=t.int32();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Qi||(Qi={}));function Kx(n,e){for(const[t,r]of e.wantlist.entries()){const s=n.wantlist.get(t);s!=null&&(s.priority>r.priority&&(r.priority=s.priority),r.cancel=r.cancel??s.cancel,r.wantType=r.wantType??s.wantType,r.sendDontHave=r.sendDontHave??s.sendDontHave),n.wantlist.set(t,r)}for(const[t,r]of e.blockPresences.entries())n.blockPresences.set(t,r);for(const[t,r]of e.blocks.entries())n.blocks.set(t,r);return e.full&&!n.full&&(n.full=!0),n}class Wx extends Error{static name="BlockTooLargeError";constructor(e="Block too large"){super(e),this.name="BlockTooLargeError"}}const Gx=4193648,Qx=Gx+16;function*Yx(n,e){const t=[...n.wantlist.values()],r=[...n.blockPresences.values()],s=[...n.blocks.values()];let i=0,o=0,a=0,c=!1;for(;;){const l={wantlist:{full:n.full??!1,entries:[]},blockPresences:[],blocks:[],pendingBytes:0};let u=Qi.encode(l).byteLength,{added:h,hasMore:d,newSize:f}=vl(s,l.blocks,a,e,u,Xx);a+=h,u=f;const p=d;({added:h,hasMore:d,newSize:f}=vl(r,l.blockPresences,o,e,u,Zx)),o+=h,u=f;const m=d;if({added:h,hasMore:d,newSize:f}=vl(t,l.wantlist.entries,i,e,u,jx),i+=h,u=f,c=!p&&!m&&!d,c||(l.wantlist.full=!1),yield Qi.encode(l),c)break}}function vl(n,e,t,r,s,i){let o=0,a=!1;for(let c=t;c<n.length;c++){const l=n[c],u=i(l);if(u>Qx)throw new Wx("Cannot send block as after encoding it is over the max message size");const h=s+u;if(h>r){a=!0;break}e.push(l),o++,s=h}return{hasMore:a,added:o,newSize:s}}function Xx(n){return Fh(3,Wi.encode(n))}function Zx(n){return Fh(4,Gi.encode(n))}function jx(n){return Fh(1,Ki.encode(n))}function Fh(n,e){const t=ye(n),r=ye(e.byteLength);return t+r+e.byteLength}let Jx=class extends Ke{log;libp2p;routing;protocols;running;maxInboundStreams;maxOutboundStreams;messageReceiveTimeout;registrarIds;metrics;sendQueue;runOnLimitedConnections;maxOutgoingMessageSize;maxIncomingMessageSize;constructor(e,t={}){super(),this.log=e.logger.forComponent("helia:bitswap:network"),this.libp2p=e.libp2p,this.routing=e.routing,this.protocols=t.protocols??[Lo],this.registrarIds=[],this.running=!1,this._onStream=this._onStream.bind(this),this.maxInboundStreams=t.maxInboundStreams??Ox,this.maxOutboundStreams=t.maxOutboundStreams??Fx,this.messageReceiveTimeout=t.messageReceiveTimeout??Ux,this.runOnLimitedConnections=t.runOnLimitedConnections??Hx,this.maxIncomingMessageSize=t.maxIncomingMessageSize??$g,this.maxOutgoingMessageSize=t.maxOutgoingMessageSize??t.maxIncomingMessageSize??qx,this.metrics={blocksSent:e.metrics?.registerCounter("helia_bitswap_sent_blocks_total"),dataSent:e.metrics?.registerCounter("helia_bitswap_sent_data_bytes_total")},this.sendQueue=new fn({concurrency:t.messageSendConcurrency??Vx,metrics:e.metrics,metricName:"helia_bitswap_message_send_queue"}),this.sendQueue.addEventListener("error",r=>{this.log.error("error sending wantlist to peer",r.detail)})}async start(){if(this.running)return;this.running=!0,await this.libp2p.handle(this.protocols,this._onStream,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnections});const e={onConnect:t=>{this.safeDispatchEvent("peer:connected",{detail:t})},onDisconnect:t=>{this.safeDispatchEvent("peer:disconnected",{detail:t})}};this.registrarIds=[];for(const t of this.protocols)this.registrarIds.push(await this.libp2p.register(t,e));this.libp2p.getConnections().forEach(t=>{this.safeDispatchEvent("peer:connected",{detail:t.remotePeer})})}async stop(){if(this.running=!1,await this.libp2p.unhandle(this.protocols),this.registrarIds!=null){for(const e of this.registrarIds)this.libp2p.unregister(e);this.registrarIds=[]}}_onStream(e){if(!this.running)return;const{stream:t,connection:r}=e;Promise.resolve().then(async()=>{this.log("incoming new bitswap %s stream from %p",t.protocol,r.remotePeer);const s=()=>{t.status==="open"?t.abort(new Ya(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`)):this.log("stream aborted with status %s",t.status)};let i=AbortSignal.timeout(this.messageReceiveTimeout);i.addEventListener("abort",s),await t.closeWrite(),await Bt(t,o=>Fi(o,{maxDataLength:this.maxIncomingMessageSize}),async o=>{for await(const a of o)try{const c=Qi.decode(a);this.log("incoming new bitswap %s message from %p on stream",t.protocol,r.remotePeer,t.id),this.safeDispatchEvent("bitswap:message",{detail:{peer:r.remotePeer,message:c}}),i.removeEventListener("abort",s),i=AbortSignal.timeout(this.messageReceiveTimeout),i.addEventListener("abort",s)}catch(c){this.log.error("error reading incoming bitswap message from %p on stream",r.remotePeer,t.id,c),t.abort(c);break}})}).catch(s=>{this.log.error("error handling incoming stream from %p",r.remotePeer,s),t.abort(s)})}async*findProviders(e,t){t?.onProgress?.(new Q("bitswap:network:find-providers",e));for await(const r of this.routing.findProviders(e,t))await this.libp2p.isDialable(r.multiaddrs,{runOnLimitedConnection:this.runOnLimitedConnections})&&(yield r)}async findAndConnect(e,t){await pn(ni(Ra(this.findProviders(e,t),t?.maxProviders??zx),async r=>this.connectTo(r.id,t))).catch(r=>{this.log.error(r)})}async sendMessage(e,t,r){if(!this.running)throw new Error("network isn't running");const s=this.sendQueue.queue.find(i=>e.equals(i.options.peerId)&&i.status==="queued");if(s!=null){s.options.message=Kx(s.options.message,t),await s.join({signal:r?.signal});return}await this.sendQueue.add(async i=>{const o=i?.message;if(o==null)throw new B("No message to send");this.log("sendMessage to %p",e),i?.onProgress?.(new Q("bitswap:network:send-wantlist",e));const a=await this.libp2p.dialProtocol(e,Lo,i);await a.closeRead();try{await Bt(Yx(o,this.maxOutgoingMessageSize),c=>lc(c),a),await a.close(i)}catch(c){i?.onProgress?.(new Q("bitswap:network:send-wantlist:error",{peer:e,error:c})),this.log.error("error sending message to %p",e,c),a.abort(c)}this._updateSentStats(o.blocks)},{peerId:e,signal:r?.signal,message:t})}async connectTo(e,t){if(!this.running)throw new Ri("Network isn't running");t?.onProgress?.(new Q("bitswap:network:dial",e));const[r]=await Promise.all([this.libp2p.dial(e,t),zt(this.libp2p,"peer:identify",t?.signal,{filter:s=>{if(!s.detail.peerId.equals(e))return!1;if(s.detail.protocols.includes(Lo))return!0;throw new Qa(`${e} did not support ${Lo}`)}})]);return r}_updateSentStats(e){let t=0;for(const r of e.values())t+=r.data.byteLength;this.metrics.dataSent?.increment(t),this.metrics.blocksSent?.increment(e.size)}};class vi{full;pendingBytes;wantlist;blocks;blockPresences;constructor(e=!1,t=0){this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}addWantlistEntry(e,t){const r=qt.encode(e.multihash.bytes);this.wantlist.set(r,t)}addBlockPresence(e,t){const r=qt.encode(e.multihash.bytes);this.blockPresences.set(r,t)}addBlock(e,t){const r=qt.encode(e.multihash.bytes);this.blocks.set(r,t)}}function ek(n){let e=new Uint8Array(n.reduce((r,s)=>r+ye(s),0)),t=0;for(const r of n)e=Ze(r,e,t),t+=ye(r);return e}function Df(n){return ek([n.version,n.code,n.multihash.code,n.multihash.digest.byteLength])}class tk{peerId;blockstore;network;wants;exchangeCount;bytesSent;bytesReceived;lastExchange;maxSizeReplaceHasWithBlock;log;constructor(e,t){this.peerId=e.peerId,this.blockstore=e.blockstore,this.network=e.network,this.wants=new Map,this.log=e.logger.forComponent(`helia:bitswap:ledger:${e.peerId}`),this.exchangeCount=0,this.bytesSent=0,this.bytesReceived=0,this.maxSizeReplaceHasWithBlock=t.maxSizeReplaceHasWithBlock??Bx}sentBytes(e){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.bytesReceived+=e}debtRatio(){return this.bytesSent/(this.bytesReceived+1)}async sendBlocksToPeer(e){const t=new vi,r=new Set;for(const[s,i]of this.wants.entries())try{const o=await this.blockstore.get(i.cid,e);i.wantType===Ye.WantHave?o.byteLength<this.maxSizeReplaceHasWithBlock?(this.log("sending have and block for %c",i.cid),r.add(s),t.addBlock(i.cid,{data:o,prefix:Df(i.cid)})):(this.log("sending have for %c",i.cid),t.addBlockPresence(i.cid,{cid:i.cid.bytes,type:vr.HaveBlock})):(this.log("sending block for %c",i.cid),r.add(s),t.addBlock(i.cid,{data:o,prefix:Df(i.cid)}))}catch(o){if(o.name!=="NotFoundError")throw o;if(this.log("do not have block for %c",i.cid),!i.sendDontHave||i.sentDontHave===!0)continue;i.sentDontHave=!0,t.addBlockPresence(i.cid,{cid:i.cid.bytes,type:vr.DontHaveBlock})}if(t.blocks.size>0||t.blockPresences.size>0){this.log("sending message"),await this.network.sendMessage(this.peerId,t,e),this.log("sent message"),this.sentBytes([...t.blocks.values()].reduce((s,i)=>s+i.data.byteLength,0));for(const s of r)this.wants.delete(s)}}}class rk{blockstore;network;ledgerMap;maxSizeReplaceHasWithBlock;log;logger;constructor(e,t={}){this.blockstore=e.blockstore,this.network=e.network,this.maxSizeReplaceHasWithBlock=t.maxSizeReplaceHasWithBlock,this.log=e.logger.forComponent("helia:bitswap:peer-want-lists"),this.logger=e.logger,this.ledgerMap=zp({name:"helia_bitswap_ledger_map",metrics:e.metrics}),this.network.addEventListener("bitswap:message",r=>{this.receiveMessage(r.detail.peer,r.detail.message).catch(s=>{this.log.error("error receiving bitswap message from %p",r.detail.peer,s)})}),this.network.addEventListener("peer:disconnected",r=>{this.peerDisconnected(r.detail)})}ledgerForPeer(e){const t=this.ledgerMap.get(e);if(t!=null)return{peer:t.peerId,value:t.debtRatio(),sent:t.bytesSent,received:t.bytesReceived,exchanged:t.exchangeCount}}wantListForPeer(e){const t=this.ledgerMap.get(e);if(t!=null)return[...t.wants.values()]}peers(){return Array.from(this.ledgerMap.values()).map(e=>e.peerId)}async receiveMessage(e,t){let r=this.ledgerMap.get(e);if(r==null&&(r=new tk({peerId:e,blockstore:this.blockstore,network:this.network,logger:this.logger},{maxSizeReplaceHasWithBlock:this.maxSizeReplaceHasWithBlock}),this.ledgerMap.set(e,r)),r.receivedBytes(t.blocks?.reduce((s,i)=>s+i.data.byteLength,0)??0),t.wantlist!=null){t.wantlist.full===!0&&r.wants.clear();for(const s of t.wantlist.entries){const i=Y.decode(s.cid),o=K(i.multihash.bytes,"base64");s.cancel===!0?(this.log("peer %p cancelled want of block for %c",e,i),r.wants.delete(o)):(s.wantType===Ye.WantHave?this.log("peer %p wanted block presence for %c",e,i):this.log("peer %p wanted block for %c",e,i),r.wants.set(o,{cid:i,priority:s.priority,wantType:s.wantType??Ye.WantBlock,sendDontHave:s.sendDontHave??!1}))}}this.log("send blocks to peer"),await r.sendBlocksToPeer()}async receivedBlock(e,t){const r=K(e.multihash.bytes,"base64"),s=[];for(const i of this.ledgerMap.values())i.wants.has(r)&&s.push(i);await Promise.all(s.map(async i=>i.sendBlocksToPeer(t)))}peerDisconnected(e){this.ledgerMap.delete(e)}}const nk=["string","number","bigint","symbol"],sk=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function ik(n){if(n===null)return"null";if(n===void 0)return"undefined";if(n===!0||n===!1)return"boolean";const e=typeof n;if(nk.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(n))return"Array";if(ok(n))return"Buffer";const t=ak(n);return t||"Object"}function ok(n){return n&&n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer.call(null,n)}function ak(n){const e=Object.prototype.toString.call(n).slice(8,-1);if(sk.includes(e))return e}class S{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}S.uint=new S(0,"uint",!0);S.negint=new S(1,"negint",!0);S.bytes=new S(2,"bytes",!0);S.string=new S(3,"string",!0);S.array=new S(4,"array",!1);S.map=new S(5,"map",!1);S.tag=new S(6,"tag",!1);S.float=new S(7,"float",!0);S.false=new S(7,"false",!0);S.true=new S(7,"true",!0);S.null=new S(7,"null",!0);S.undefined=new S(7,"undefined",!0);S.break=new S(7,"break",!0);class F{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const si=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",ck=new TextDecoder,lk=new TextEncoder;function Na(n){return si&&globalThis.Buffer.isBuffer(n)}function Uh(n){return n instanceof Uint8Array?Na(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n:Uint8Array.from(n)}const uk=si?(n,e,t)=>t-e>64?globalThis.Buffer.from(n.subarray(e,t)).toString("utf8"):Mf(n,e,t):(n,e,t)=>t-e>64?ck.decode(n.subarray(e,t)):Mf(n,e,t),Vg=si?n=>n.length>64?globalThis.Buffer.from(n):Rf(n):n=>n.length>64?lk.encode(n):Rf(n),Tr=n=>Uint8Array.from(n),$h=si?(n,e,t)=>Na(n)?new Uint8Array(n.subarray(e,t)):n.slice(e,t):(n,e,t)=>n.slice(e,t),hk=si?(n,e)=>(n=n.map(t=>t instanceof Uint8Array?t:globalThis.Buffer.from(t)),Uh(globalThis.Buffer.concat(n,e))):(n,e)=>{const t=new Uint8Array(e);let r=0;for(let s of n)r+s.length>t.length&&(s=s.subarray(0,t.length-r)),t.set(s,r),r+=s.length;return t},dk=si?n=>globalThis.Buffer.allocUnsafe(n):n=>new Uint8Array(n);function fk(n,e){if(Na(n)&&Na(e))return n.compare(e);for(let t=0;t<n.length;t++)if(n[t]!==e[t])return n[t]<e[t]?-1:1;return 0}function Rf(n){const e=[];let t=0;for(let r=0;r<n.length;r++){let s=n.charCodeAt(r);s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&r+1<n.length&&(n.charCodeAt(r+1)&64512)===56320?(s=65536+((s&1023)<<10)+(n.charCodeAt(++r)&1023),e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128)}return e}function Mf(n,e,t){const r=[];for(;e<t;){const s=n[e];let i=null,o=s>239?4:s>223?3:s>191?2:1;if(e+o<=t){let a,c,l,u;switch(o){case 1:s<128&&(i=s);break;case 2:a=n[e+1],(a&192)===128&&(u=(s&31)<<6|a&63,u>127&&(i=u));break;case 3:a=n[e+1],c=n[e+2],(a&192)===128&&(c&192)===128&&(u=(s&15)<<12|(a&63)<<6|c&63,u>2047&&(u<55296||u>57343)&&(i=u));break;case 4:a=n[e+1],c=n[e+2],l=n[e+3],(a&192)===128&&(c&192)===128&&(l&192)===128&&(u=(s&15)<<18|(a&63)<<12|(c&63)<<6|l&63,u>65535&&u<1114112&&(i=u))}}i===null?(i=65533,o=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|i&1023),r.push(i),e+=o}return Hg(r)}const Lf=4096;function Hg(n){const e=n.length;if(e<=Lf)return String.fromCharCode.apply(String,n);let t="",r=0;for(;r<e;)t+=String.fromCharCode.apply(String,n.slice(r,r+=Lf));return t}const pk=256;class zg{constructor(e=pk){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const s=t.length-(this.maxCursor-this.cursor)-1;t.set(e,s)}else{if(t){const s=t.length-(this.maxCursor-this.cursor)-1;s<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,s),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=dk(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,this._initReuseChunk===null&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(this.chunks.length===1){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=$h(r,0,this.cursor)}else t=hk(this.chunks,this.cursor);return e&&this.reset(),t}}const G="CBOR decode error:",On="CBOR encode error:";function ii(n,e,t){if(n.length-e<t)throw new Error(`${G} not enough data for type`)}const tt=[24,256,65536,4294967296,BigInt("18446744073709551616")];function ns(n,e,t){ii(n,e,1);const r=n[e];if(t.strict===!0&&r<tt[0])throw new Error(`${G} integer encoded in more bytes than necessary (strict decode)`);return r}function ss(n,e,t){ii(n,e,2);const r=n[e]<<8|n[e+1];if(t.strict===!0&&r<tt[1])throw new Error(`${G} integer encoded in more bytes than necessary (strict decode)`);return r}function is(n,e,t){ii(n,e,4);const r=n[e]*16777216+(n[e+1]<<16)+(n[e+2]<<8)+n[e+3];if(t.strict===!0&&r<tt[2])throw new Error(`${G} integer encoded in more bytes than necessary (strict decode)`);return r}function os(n,e,t){ii(n,e,8);const r=n[e]*16777216+(n[e+1]<<16)+(n[e+2]<<8)+n[e+3],s=n[e+4]*16777216+(n[e+5]<<16)+(n[e+6]<<8)+n[e+7],i=(BigInt(r)<<BigInt(32))+BigInt(s);if(t.strict===!0&&i<tt[3])throw new Error(`${G} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(t.allowBigInt===!0)return i;throw new Error(`${G} integers outside of the safe integer range are not supported`)}function gk(n,e,t,r){return new F(S.uint,ns(n,e+1,r),2)}function mk(n,e,t,r){return new F(S.uint,ss(n,e+1,r),3)}function yk(n,e,t,r){return new F(S.uint,is(n,e+1,r),5)}function wk(n,e,t,r){return new F(S.uint,os(n,e+1,r),9)}function as(n,e){return Gt(n,0,e.value)}function Gt(n,e,t){if(t<tt[0]){const r=Number(t);n.push([e|r])}else if(t<tt[1]){const r=Number(t);n.push([e|24,r])}else if(t<tt[2]){const r=Number(t);n.push([e|25,r>>>8,r&255])}else if(t<tt[3]){const r=Number(t);n.push([e|26,r>>>24&255,r>>>16&255,r>>>8&255,r&255])}else{const r=BigInt(t);if(r<tt[4]){const s=[e|27,0,0,0,0,0,0,0];let i=Number(r&BigInt(4294967295)),o=Number(r>>BigInt(32)&BigInt(4294967295));s[8]=i&255,i=i>>8,s[7]=i&255,i=i>>8,s[6]=i&255,i=i>>8,s[5]=i&255,s[4]=o&255,o=o>>8,s[3]=o&255,o=o>>8,s[2]=o&255,o=o>>8,s[1]=o&255,n.push(s)}else throw new Error(`${G} encountered BigInt larger than allowable range`)}}as.encodedSize=function(e){return Gt.encodedSize(e.value)};Gt.encodedSize=function(e){return e<tt[0]?1:e<tt[1]?2:e<tt[2]?3:e<tt[3]?5:9};as.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};function bk(n,e,t,r){return new F(S.negint,-1-ns(n,e+1,r),2)}function vk(n,e,t,r){return new F(S.negint,-1-ss(n,e+1,r),3)}function Ek(n,e,t,r){return new F(S.negint,-1-is(n,e+1,r),5)}const Vh=BigInt(-1),qg=BigInt(1);function Sk(n,e,t,r){const s=os(n,e+1,r);if(typeof s!="bigint"){const i=-1-s;if(i>=Number.MIN_SAFE_INTEGER)return new F(S.negint,i,9)}if(r.allowBigInt!==!0)throw new Error(`${G} integers outside of the safe integer range are not supported`);return new F(S.negint,Vh-BigInt(s),9)}function Hh(n,e){const t=e.value,r=typeof t=="bigint"?t*Vh-qg:t*-1-1;Gt(n,e.type.majorEncoded,r)}Hh.encodedSize=function(e){const t=e.value,r=typeof t=="bigint"?t*Vh-qg:t*-1-1;return r<tt[0]?1:r<tt[1]?2:r<tt[2]?3:r<tt[3]?5:9};Hh.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0};function lo(n,e,t,r){ii(n,e,t+r);const s=$h(n,e+t,e+t+r);return new F(S.bytes,s,t+r)}function _k(n,e,t,r){return lo(n,e,1,t)}function xk(n,e,t,r){return lo(n,e,2,ns(n,e+1,r))}function kk(n,e,t,r){return lo(n,e,3,ss(n,e+1,r))}function Ik(n,e,t,r){return lo(n,e,5,is(n,e+1,r))}function Ak(n,e,t,r){const s=os(n,e+1,r);if(typeof s=="bigint")throw new Error(`${G} 64-bit integer bytes lengths not supported`);return lo(n,e,9,s)}function Ba(n){return n.encodedBytes===void 0&&(n.encodedBytes=n.type===S.string?Vg(n.value):n.value),n.encodedBytes}function vc(n,e){const t=Ba(e);Gt(n,e.type.majorEncoded,t.length),n.push(t)}vc.encodedSize=function(e){const t=Ba(e);return Gt.encodedSize(t.length)+t.length};vc.compareTokens=function(e,t){return Tk(Ba(e),Ba(t))};function Tk(n,e){return n.length<e.length?-1:n.length>e.length?1:fk(n,e)}function uo(n,e,t,r,s){const i=t+r;ii(n,e,i);const o=new F(S.string,uk(n,e+t,e+i),i);return s.retainStringBytes===!0&&(o.byteValue=$h(n,e+t,e+i)),o}function Pk(n,e,t,r){return uo(n,e,1,t,r)}function Ck(n,e,t,r){return uo(n,e,2,ns(n,e+1,r),r)}function Dk(n,e,t,r){return uo(n,e,3,ss(n,e+1,r),r)}function Rk(n,e,t,r){return uo(n,e,5,is(n,e+1,r),r)}function Mk(n,e,t,r){const s=os(n,e+1,r);if(typeof s=="bigint")throw new Error(`${G} 64-bit integer string lengths not supported`);return uo(n,e,9,s,r)}const Lk=vc;function oi(n,e,t,r){return new F(S.array,r,t)}function Nk(n,e,t,r){return oi(n,e,1,t)}function Bk(n,e,t,r){return oi(n,e,2,ns(n,e+1,r))}function Ok(n,e,t,r){return oi(n,e,3,ss(n,e+1,r))}function Fk(n,e,t,r){return oi(n,e,5,is(n,e+1,r))}function Uk(n,e,t,r){const s=os(n,e+1,r);if(typeof s=="bigint")throw new Error(`${G} 64-bit integer array lengths not supported`);return oi(n,e,9,s)}function $k(n,e,t,r){if(r.allowIndefinite===!1)throw new Error(`${G} indefinite length items not allowed`);return oi(n,e,1,1/0)}function zh(n,e){Gt(n,S.array.majorEncoded,e.value)}zh.compareTokens=as.compareTokens;zh.encodedSize=function(e){return Gt.encodedSize(e.value)};function ai(n,e,t,r){return new F(S.map,r,t)}function Vk(n,e,t,r){return ai(n,e,1,t)}function Hk(n,e,t,r){return ai(n,e,2,ns(n,e+1,r))}function zk(n,e,t,r){return ai(n,e,3,ss(n,e+1,r))}function qk(n,e,t,r){return ai(n,e,5,is(n,e+1,r))}function Kk(n,e,t,r){const s=os(n,e+1,r);if(typeof s=="bigint")throw new Error(`${G} 64-bit integer map lengths not supported`);return ai(n,e,9,s)}function Wk(n,e,t,r){if(r.allowIndefinite===!1)throw new Error(`${G} indefinite length items not allowed`);return ai(n,e,1,1/0)}function qh(n,e){Gt(n,S.map.majorEncoded,e.value)}qh.compareTokens=as.compareTokens;qh.encodedSize=function(e){return Gt.encodedSize(e.value)};function Gk(n,e,t,r){return new F(S.tag,t,1)}function Qk(n,e,t,r){return new F(S.tag,ns(n,e+1,r),2)}function Yk(n,e,t,r){return new F(S.tag,ss(n,e+1,r),3)}function Xk(n,e,t,r){return new F(S.tag,is(n,e+1,r),5)}function Zk(n,e,t,r){return new F(S.tag,os(n,e+1,r),9)}function Kh(n,e){Gt(n,S.tag.majorEncoded,e.value)}Kh.compareTokens=as.compareTokens;Kh.encodedSize=function(e){return Gt.encodedSize(e.value)};const jk=20,Jk=21,eI=22,tI=23;function rI(n,e,t,r){if(r.allowUndefined===!1)throw new Error(`${G} undefined values are not supported`);return r.coerceUndefinedToNull===!0?new F(S.null,null,1):new F(S.undefined,void 0,1)}function nI(n,e,t,r){if(r.allowIndefinite===!1)throw new Error(`${G} indefinite length items not allowed`);return new F(S.break,void 0,1)}function Wh(n,e,t){if(t){if(t.allowNaN===!1&&Number.isNaN(n))throw new Error(`${G} NaN values are not supported`);if(t.allowInfinity===!1&&(n===1/0||n===-1/0))throw new Error(`${G} Infinity values are not supported`)}return new F(S.float,n,e)}function sI(n,e,t,r){return Wh(Qh(n,e+1),3,r)}function iI(n,e,t,r){return Wh(Yh(n,e+1),5,r)}function oI(n,e,t,r){return Wh(Qg(n,e+1),9,r)}function Gh(n,e,t){const r=e.value;if(r===!1)n.push([S.float.majorEncoded|jk]);else if(r===!0)n.push([S.float.majorEncoded|Jk]);else if(r===null)n.push([S.float.majorEncoded|eI]);else if(r===void 0)n.push([S.float.majorEncoded|tI]);else{let s,i=!1;(!t||t.float64!==!0)&&(Wg(r),s=Qh(jt,1),r===s||Number.isNaN(r)?(jt[0]=249,n.push(jt.slice(0,3)),i=!0):(Gg(r),s=Yh(jt,1),r===s&&(jt[0]=250,n.push(jt.slice(0,5)),i=!0))),i||(aI(r),s=Qg(jt,1),jt[0]=251,n.push(jt.slice(0,9)))}}Gh.encodedSize=function(e,t){const r=e.value;if(r===!1||r===!0||r===null||r===void 0)return 1;if(!t||t.float64!==!0){Wg(r);let s=Qh(jt,1);if(r===s||Number.isNaN(r))return 3;if(Gg(r),s=Yh(jt,1),r===s)return 5}return 9};const Kg=new ArrayBuffer(9),Ut=new DataView(Kg,1),jt=new Uint8Array(Kg,0);function Wg(n){if(n===1/0)Ut.setUint16(0,31744,!1);else if(n===-1/0)Ut.setUint16(0,64512,!1);else if(Number.isNaN(n))Ut.setUint16(0,32256,!1);else{Ut.setFloat32(0,n);const e=Ut.getUint32(0),t=(e&2139095040)>>23,r=e&8388607;if(t===255)Ut.setUint16(0,31744,!1);else if(t===0)Ut.setUint16(0,(n&2147483648)>>16|r>>13,!1);else{const s=t-127;s<-24?Ut.setUint16(0,0):s<-14?Ut.setUint16(0,(e&2147483648)>>16|1<<24+s,!1):Ut.setUint16(0,(e&2147483648)>>16|s+15<<10|r>>13,!1)}}}function Qh(n,e){if(n.length-e<2)throw new Error(`${G} not enough data for float16`);const t=(n[e]<<8)+n[e+1];if(t===31744)return 1/0;if(t===64512)return-1/0;if(t===32256)return NaN;const r=t>>10&31,s=t&1023;let i;return r===0?i=s*2**-24:r!==31?i=(s+1024)*2**(r-25):i=s===0?1/0:NaN,t&32768?-i:i}function Gg(n){Ut.setFloat32(0,n,!1)}function Yh(n,e){if(n.length-e<4)throw new Error(`${G} not enough data for float32`);const t=(n.byteOffset||0)+e;return new DataView(n.buffer,t,4).getFloat32(0,!1)}function aI(n){Ut.setFloat64(0,n,!1)}function Qg(n,e){if(n.length-e<8)throw new Error(`${G} not enough data for float64`);const t=(n.byteOffset||0)+e;return new DataView(n.buffer,t,8).getFloat64(0,!1)}Gh.compareTokens=as.compareTokens;function fe(n,e,t){throw new Error(`${G} encountered invalid minor (${t}) for major ${n[e]>>>5}`)}function Ec(n){return()=>{throw new Error(`${G} ${n}`)}}const $=[];for(let n=0;n<=23;n++)$[n]=fe;$[24]=gk;$[25]=mk;$[26]=yk;$[27]=wk;$[28]=fe;$[29]=fe;$[30]=fe;$[31]=fe;for(let n=32;n<=55;n++)$[n]=fe;$[56]=bk;$[57]=vk;$[58]=Ek;$[59]=Sk;$[60]=fe;$[61]=fe;$[62]=fe;$[63]=fe;for(let n=64;n<=87;n++)$[n]=_k;$[88]=xk;$[89]=kk;$[90]=Ik;$[91]=Ak;$[92]=fe;$[93]=fe;$[94]=fe;$[95]=Ec("indefinite length bytes/strings are not supported");for(let n=96;n<=119;n++)$[n]=Pk;$[120]=Ck;$[121]=Dk;$[122]=Rk;$[123]=Mk;$[124]=fe;$[125]=fe;$[126]=fe;$[127]=Ec("indefinite length bytes/strings are not supported");for(let n=128;n<=151;n++)$[n]=Nk;$[152]=Bk;$[153]=Ok;$[154]=Fk;$[155]=Uk;$[156]=fe;$[157]=fe;$[158]=fe;$[159]=$k;for(let n=160;n<=183;n++)$[n]=Vk;$[184]=Hk;$[185]=zk;$[186]=qk;$[187]=Kk;$[188]=fe;$[189]=fe;$[190]=fe;$[191]=Wk;for(let n=192;n<=215;n++)$[n]=Gk;$[216]=Qk;$[217]=Yk;$[218]=Xk;$[219]=Zk;$[220]=fe;$[221]=fe;$[222]=fe;$[223]=fe;for(let n=224;n<=243;n++)$[n]=Ec("simple values are not supported");$[244]=fe;$[245]=fe;$[246]=fe;$[247]=rI;$[248]=Ec("simple values are not supported");$[249]=sI;$[250]=iI;$[251]=oI;$[252]=fe;$[253]=fe;$[254]=fe;$[255]=nI;const xr=[];for(let n=0;n<24;n++)xr[n]=new F(S.uint,n,1);for(let n=-1;n>=-24;n--)xr[31-n]=new F(S.negint,n,1);xr[64]=new F(S.bytes,new Uint8Array(0),1);xr[96]=new F(S.string,"",1);xr[128]=new F(S.array,0,1);xr[160]=new F(S.map,0,1);xr[244]=new F(S.false,!1,1);xr[245]=new F(S.true,!0,1);xr[246]=new F(S.null,null,1);function cI(n){switch(n.type){case S.false:return Tr([244]);case S.true:return Tr([245]);case S.null:return Tr([246]);case S.bytes:return n.value.length?void 0:Tr([64]);case S.string:return n.value===""?Tr([96]):void 0;case S.array:return n.value===0?Tr([128]):void 0;case S.map:return n.value===0?Tr([160]):void 0;case S.uint:return n.value<24?Tr([Number(n.value)]):void 0;case S.negint:if(n.value>=-24)return Tr([31-Number(n.value)])}}const lI={float64:!1,mapSorter:dI,quickEncodeToken:cI};function uI(){const n=[];return n[S.uint.major]=as,n[S.negint.major]=Hh,n[S.bytes.major]=vc,n[S.string.major]=Lk,n[S.array.major]=zh,n[S.map.major]=qh,n[S.tag.major]=Kh,n[S.float.major]=Gh,n}const Yg=uI(),El=new zg;class Oa{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do if(t.obj===e)return!0;while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${On} object contains circular references`);return new Oa(t,e)}}const qr={null:new F(S.null,null),undefined:new F(S.undefined,void 0),true:new F(S.true,!0),false:new F(S.false,!1),emptyArray:new F(S.array,0),emptyMap:new F(S.map,0)},mn={number(n,e,t,r){return!Number.isInteger(n)||!Number.isSafeInteger(n)?new F(S.float,n):n>=0?new F(S.uint,n):new F(S.negint,n)},bigint(n,e,t,r){return n>=BigInt(0)?new F(S.uint,n):new F(S.negint,n)},Uint8Array(n,e,t,r){return new F(S.bytes,n)},string(n,e,t,r){return new F(S.string,n)},boolean(n,e,t,r){return n?qr.true:qr.false},null(n,e,t,r){return qr.null},undefined(n,e,t,r){return qr.undefined},ArrayBuffer(n,e,t,r){return new F(S.bytes,new Uint8Array(n))},DataView(n,e,t,r){return new F(S.bytes,new Uint8Array(n.buffer,n.byteOffset,n.byteLength))},Array(n,e,t,r){if(!n.length)return t.addBreakTokens===!0?[qr.emptyArray,new F(S.break)]:qr.emptyArray;r=Oa.createCheck(r,n);const s=[];let i=0;for(const o of n)s[i++]=Ko(o,t,r);return t.addBreakTokens?[new F(S.array,n.length),s,new F(S.break)]:[new F(S.array,n.length),s]},Object(n,e,t,r){const s=e!=="Object",i=s?n.keys():Object.keys(n),o=s?n.size:i.length;if(!o)return t.addBreakTokens===!0?[qr.emptyMap,new F(S.break)]:qr.emptyMap;r=Oa.createCheck(r,n);const a=[];let c=0;for(const l of i)a[c++]=[Ko(l,t,r),Ko(s?n.get(l):n[l],t,r)];return hI(a,t),t.addBreakTokens?[new F(S.map,o),a,new F(S.break)]:[new F(S.map,o),a]}};mn.Map=mn.Object;mn.Buffer=mn.Uint8Array;for(const n of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))mn[`${n}Array`]=mn.DataView;function Ko(n,e={},t){const r=ik(n),s=e&&e.typeEncoders&&e.typeEncoders[r]||mn[r];if(typeof s=="function"){const o=s(n,r,e,t);if(o!=null)return o}const i=mn[r];if(!i)throw new Error(`${On} unsupported type: ${r}`);return i(n,r,e,t)}function hI(n,e){e.mapSorter&&n.sort(e.mapSorter)}function dI(n,e){const t=Array.isArray(n[0])?n[0][0]:n[0],r=Array.isArray(e[0])?e[0][0]:e[0];if(t.type!==r.type)return t.type.compare(r.type);const s=t.type.major,i=Yg[s].compareTokens(t,r);return i===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i}function Xg(n,e,t,r){if(Array.isArray(e))for(const s of e)Xg(n,s,t,r);else t[e.type.major](n,e,r)}function Zg(n,e,t){const r=Ko(n,t);if(!Array.isArray(r)&&t.quickEncodeToken){const s=t.quickEncodeToken(r);if(s)return s;const i=e[r.type.major];if(i.encodedSize){const o=i.encodedSize(r,t),a=new zg(o);if(i(a,r,t),a.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${r} was wrong`);return Uh(a.chunks[0])}}return El.reset(),Xg(El,r,e,t),El.toBytes(!0)}function Wo(n,e){return e=Object.assign({},lI,e),Zg(n,Yg,e)}const fI={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class pI{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=xr[e];if(t===void 0){const r=$[e];if(!r)throw new Error(`${G} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const s=e&31;t=r(this.data,this._pos,s,this.options)}return this._pos+=t.encodedLength,t}}const Yi=Symbol.for("DONE"),Sc=Symbol.for("BREAK");function gI(n,e,t){const r=[];for(let s=0;s<n.value;s++){const i=Xi(e,t);if(i===Sc){if(n.value===1/0)break;throw new Error(`${G} got unexpected break to lengthed array`)}if(i===Yi)throw new Error(`${G} found array but not enough entries (got ${s}, expected ${n.value})`);r[s]=i}return r}function mI(n,e,t){const r=t.useMaps===!0,s=r?void 0:{},i=r?new Map:void 0;for(let o=0;o<n.value;o++){const a=Xi(e,t);if(a===Sc){if(n.value===1/0)break;throw new Error(`${G} got unexpected break to lengthed map`)}if(a===Yi)throw new Error(`${G} found map but not enough entries (got ${o} [no key], expected ${n.value})`);if(r!==!0&&typeof a!="string")throw new Error(`${G} non-string keys not supported (got ${typeof a})`);if(t.rejectDuplicateMapKeys===!0&&(r&&i.has(a)||!r&&a in s))throw new Error(`${G} found repeat map key "${a}"`);const c=Xi(e,t);if(c===Yi)throw new Error(`${G} found map but not enough entries (got ${o} [no value], expected ${n.value})`);r?i.set(a,c):s[a]=c}return r?i:s}function Xi(n,e){if(n.done())return Yi;const t=n.next();if(t.type===S.break)return Sc;if(t.type.terminal)return t.value;if(t.type===S.array)return gI(t,n,e);if(t.type===S.map)return mI(t,n,e);if(t.type===S.tag){if(e.tags&&typeof e.tags[t.value]=="function"){const r=Xi(n,e);return e.tags[t.value](r)}throw new Error(`${G} tag not supported (${t.value})`)}throw new Error("unsupported")}function yI(n,e){if(!(n instanceof Uint8Array))throw new Error(`${G} data to decode must be a Uint8Array`);e=Object.assign({},fI,e);const t=e.tokenizer||new pI(n,e),r=Xi(t,e);if(r===Yi)throw new Error(`${G} did not find any content to decode`);if(r===Sc)throw new Error(`${G} got unexpected break`);return[r,n.subarray(t.pos())]}function Yr(n,e){const[t,r]=yI(n,e);if(r.length>0)throw new Error(`${G} too many terminals, data makes no sense`);return t}function No({enumerable:n=!0,configurable:e=!1}={}){return{enumerable:n,configurable:e,writable:!1}}function*wI(n,e){if(e!=null&&typeof e=="object")if(Array.isArray(e))for(const[t,r]of e.entries()){const s=[...n,t],i=Y.asCID(r);i!=null?yield[s.join("/"),i]:typeof r=="object"&&(yield*mu(r,s))}else{const t=Y.asCID(e);t!=null?yield[n.join("/"),t]:yield*mu(e,n)}}function*mu(n,e){if(n==null||n instanceof Uint8Array)return;const t=Y.asCID(n);t!=null&&(yield[e.join("/"),t]);for(const[r,s]of Object.entries(n)){const i=[...e,r];yield*wI(i,s)}}function*bI(n,e){if(Array.isArray(e))for(const[t,r]of e.entries()){const s=[...n,t];yield s.join("/"),typeof r=="object"&&Y.asCID(r)==null&&(yield*yu(r,s))}else yield*yu(e,n)}function*yu(n,e){if(!(n==null||typeof n!="object"))for(const[t,r]of Object.entries(n)){const s=[...e,t];yield s.join("/"),r!=null&&!(r instanceof Uint8Array)&&typeof r=="object"&&Y.asCID(r)==null&&(yield*bI(s,r))}}function vI(n,e){let t=n;for(const[r,s]of e.entries()){if(t=t[s],t==null)throw new Error(`Object has no property at ${e.slice(0,r+1).map(o=>`[${JSON.stringify(o)}]`).join("")}`);const i=Y.asCID(t);if(i!=null)return{value:i,remaining:e.slice(r+1).join("/")}}return{value:t}}class EI{cid;bytes;value;asBlock;constructor({cid:e,bytes:t,value:r}){if(e==null||t==null||typeof r>"u")throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:No(),bytes:No(),value:No(),asBlock:No()})}links(){return mu(this.value,[])}tree(){return yu(this.value,[])}get(e="/"){return vI(this.value,e.split("/").filter(Boolean))}}function SI({bytes:n,cid:e,value:t,codec:r}){const s=t!==void 0?t:r?.decode(n);if(s===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new EI({cid:e,bytes:n,value:s})}const jg="/pin/",Nf="/pinned-block/",wu=Mn,Bf=1;function Bo(n){return n.version===0&&(n=n.toV1()),new Te(`${jg}${n.toString(wu)}`)}class _I{datastore;blockstore;getCodec;constructor(e,t,r){this.datastore=e,this.blockstore=t,this.getCodec=r}async*add(e,t={}){const r=Bo(e);if(await this.datastore.has(r))throw new Error("Already pinned");const s=Math.round(t.depth??1/0);if(s<0)throw new Error("Depth must be greater than or equal to 0");const i=new Gn({concurrency:Bf});for await(const a of this.#e(e,i,{...t,depth:s}))await this.#t(a,c=>c.pinnedBy.find(l=>pe(l,e.bytes))!=null?!1:(c.pinCount++,c.pinnedBy.push(e.bytes),!0),t),yield a;const o={depth:s,metadata:t.metadata??{}};await this.datastore.put(r,Wo(o),t)}async*#e(e,t,r){if(r.depth===-1)return;const s=await this.getCodec(e.code),i=await this.blockstore.get(e,r),o=SI({bytes:i,cid:e,codec:s});yield e;for await(const[,a]of o.links())yield*await t.add(async()=>this.#e(a,t,{...r,depth:r.depth-1}))}async#t(e,t,r){const s=new Te(`${Nf}${wu.encode(e.multihash.bytes)}`);let i={pinCount:0,pinnedBy:[]};try{i=Yr(await this.datastore.get(s,r))}catch(a){if(a.name!=="NotFoundError")throw a}if(t(i)){if(i.pinCount===0&&await this.datastore.has(s)){await this.datastore.delete(s);return}await this.datastore.put(s,Wo(i),r),r.onProgress?.(new Q("helia:pin:add",e))}}async*rm(e,t={}){const r=Bo(e),s=await this.datastore.get(r,t),i=Yr(s);await this.datastore.delete(r,t);const o=new Gn({concurrency:Bf});for await(const a of this.#e(e,o,{...t,depth:i.depth}))await this.#t(a,c=>(c.pinCount--,c.pinnedBy=c.pinnedBy.filter(l=>pe(l,e.bytes)),!0),{...t,depth:i.depth}),yield a}async*ls(e={}){for await(const{key:t,value:r}of this.datastore.query({prefix:jg+(e.cid!=null?`${e.cid.toString(Mn)}`:"")},e)){const s=Y.parse(t.toString().substring(5),Mn),i=Yr(r);yield{cid:s,...i}}}async isPinned(e,t={}){const r=new Te(`${Nf}${wu.encode(e.multihash.bytes)}`);return this.datastore.has(r,t)}async get(e,t){const r=Bo(e),s=await this.datastore.get(r,t);return Yr(s)}async setMetadata(e,t,r){const s=Bo(e),i=await this.datastore.get(s,r),o=Yr(i);o.metadata=t??{},await this.datastore.put(s,Wo(o),r)}}const xI=1,kI=5;class II extends Error{static name="InsufficientProvidersError";constructor(e="Insufficient providers found"){super(e),this.name="InsufficientProvidersError"}}class Oo extends Error{static name="NoRoutersAvailableError";constructor(e="No routers available"){super(e),this.name="NoRoutersAvailableError"}}class AI extends Error{static name="UnknownHashAlgorithmError";constructor(e="Unknown hash algorithm"){super(e),this.name="UnknownHashAlgorithmError"}}class TI extends Error{static name="UnknownCodecError";constructor(e="Unknown codec"){super(e),this.name="UnknownCodecError"}}const PI=5;class CI{log;routers;providerLookupConcurrency;constructor(e,t){this.log=e.logger.forComponent("helia:routing"),this.routers=t.routers??[],this.providerLookupConcurrency=t.providerLookupConcurrency??PI,this.findProviders=e.metrics?.traceFunction("helia.routing.findProviders",this.findProviders.bind(this),{optionsIndex:1})??this.findProviders,this.provide=e.metrics?.traceFunction("helia.routing.provide",this.provide.bind(this),{optionsIndex:1})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("helia.routing.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1})??this.cancelReprovide,this.put=e.metrics?.traceFunction("helia.routing.put",this.put.bind(this),{optionsIndex:2})??this.put,this.get=e.metrics?.traceFunction("helia.routing.get",this.get.bind(this),{optionsIndex:1})??this.get,this.findPeer=e.metrics?.traceFunction("helia.routing.findPeer",this.findPeer.bind(this),{optionsIndex:1})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("helia.routing.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1})??this.getClosestPeers}async start(){await Nr(...this.routers)}async stop(){await wn(...this.routers)}async*findProviders(e,t={}){if(this.routers.length===0)throw new Oo("No content routers available");const r=new fn({concurrency:this.providerLookupConcurrency});r.addEventListener("error",()=>{});for await(const s of sn(r.toGenerator(),...Sn(this.routers,"findProviders").map(i=>i.findProviders(e,t))))if(s!=null){if(s.multiaddrs.length===0){if(r.find(s.id)!=null)continue;r.add(async()=>{try{const i=await this.findPeer(s.id,t);return i.multiaddrs.length===0?null:i}catch(i){return this.log.error("could not load multiaddrs for peer %p",s.id,i),null}},{peerId:s.id,signal:t.signal}).catch(i=>{this.log.error("could not load multiaddrs for peer %p",s.id,i)})}yield s}}async provide(e,t={}){if(this.routers.length===0)throw new Oo("No content routers available");await Promise.all(Sn(this.routers,"provide").map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){await Promise.all(Sn(this.routers,"cancelReprovide").map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){await Promise.all(Sn(this.routers,"put").map(async s=>{await s.put(e,t,r)}))}async get(e,t){return Promise.any(Sn(this.routers,"get").map(async r=>r.get(e,t)))}async findPeer(e,t){if(this.routers.length===0)throw new Oo("No peer routers available");const r=this,s=sn(...Sn(this.routers,"findPeer").map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i;throw new It("Could not find peer in routing")}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new Oo("No peer routers available");for await(const r of sn(...Sn(this.routers,"getClosestPeers").map(s=>s.getClosestPeers(e,t))))r!=null&&(yield r)}}function Sn(n,e){return n.filter(t=>t[e]!=null)}class DI{lock;child;pins;started;constructor(e,t,r={}){this.child=e,this.pins=t,this.lock=Bh({singleProcess:r.holdGcLock}),this.started=!1}isStarted(){return this.started}async start(){await Nr(this.child),this.started=!0}async stop(){await wn(this.child),this.started=!1}unwrap(){return this.child}async put(e,t,r={}){r?.signal?.throwIfAborted();const s=await this.lock.readLock();try{return await this.child.put(e,t,r)}finally{s()}}async*putMany(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.readLock();try{yield*this.child.putMany(e,t)}finally{r()}}async get(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.readLock();try{return await this.child.get(e,t)}finally{r()}}async*getMany(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.readLock();try{yield*this.child.getMany(e,t)}finally{r()}}async delete(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.writeLock();try{if(await this.pins.isPinned(e))throw new Error("CID was pinned");await this.child.delete(e,t)}finally{r()}}async*deleteMany(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.writeLock();try{const s=this;yield*this.child.deleteMany(async function*(){for await(const i of e){if(await s.pins.isPinned(i))throw new Error("CID was pinned");yield i}}(),t)}finally{r()}}async has(e,t={}){t?.signal?.throwIfAborted();const r=await this.lock.readLock();try{return await this.child.has(e,t)}finally{r()}}async*getAll(e={}){e?.signal?.throwIfAborted();const t=await this.lock.readLock();try{yield*this.child.getAll(e)}finally{t()}}createSession(e,t){return t?.signal?.throwIfAborted(),this.child.createSession(e,t)}}const Sl=new Te("/version"),Of=1;async function RI(n){if(!await n.has(Sl)){await n.put(Sl,V(`${Of}`));return}const e=await n.get(Sl),t=K(e);if(parseInt(t,10)!==Of)throw new Error("Unknown datastore version, a datastore migration may be required")}const Jg=42;function e4(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}function MI(n){if(n.asCID!==n&&n["/"]!==n.bytes)return null;const e=Y.asCID(n);if(!e)return null;const t=new Uint8Array(e.bytes.byteLength+1);return t.set(e.bytes,1),[new F(S.tag,Jg),new F(S.bytes,t)]}function LI(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function NI(n){if(Number.isNaN(n))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(n===1/0||n===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const bu={float64:!0,typeEncoders:{Object:MI,undefined:LI,number:NI}},BI={...bu,typeEncoders:{...bu.typeEncoders}};function OI(n){if(n[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return Y.decode(n.subarray(1))}const Fa={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Fa.tags[Jg]=OI;const FI={...Fa,tags:Fa.tags.slice()},UI="dag-cbor",t4=113,$I=n=>Wo(n,bu),VI=n=>Yr(e4(n),Fa),HI=Object.freeze(Object.defineProperty({__proto__:null,code:t4,decode:VI,decodeOptions:FI,encode:$I,encodeOptions:BI,name:UI,toByteView:e4},Symbol.toStringTag,{value:"Module"}));class zI extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const t=this.inRecursive[this.inRecursive.length-1];t&&(t.type===S.array&&(t.elements++,t.elements!==1&&e.push([44])),t.type===S.map&&(t.elements++,t.elements!==1&&(t.elements%2===1?e.push([44]):e.push([58]))))}[S.uint.major](e,t){this.prefix(e);const r=String(t.value),s=[];for(let i=0;i<r.length;i++)s[i]=r.charCodeAt(i);e.push(s)}[S.negint.major](e,t){this[S.uint.major](e,t)}[S.bytes.major](e,t){throw new Error(`${On} unsupported type: Uint8Array`)}[S.string.major](e,t){this.prefix(e);const r=Vg(JSON.stringify(t.value));e.push(r.length>32?Uh(r):r)}[S.array.major](e,t){this.prefix(e),this.inRecursive.push({type:S.array,elements:0}),e.push([91])}[S.map.major](e,t){this.prefix(e),this.inRecursive.push({type:S.map,elements:0}),e.push([123])}[S.tag.major](e,t){}[S.float.major](e,t){if(t.type.name==="break"){const o=this.inRecursive.pop();if(o){if(o.type===S.array)e.push([93]);else if(o.type===S.map)e.push([125]);else throw new Error("Unexpected recursive type; this should not happen!");return}throw new Error("Unexpected break; this should not happen!")}if(t.value===void 0)throw new Error(`${On} unsupported type: undefined`);if(this.prefix(e),t.type.name==="true"){e.push([116,114,117,101]);return}else if(t.type.name==="false"){e.push([102,97,108,115,101]);return}else if(t.type.name==="null"){e.push([110,117,108,108]);return}const r=String(t.value),s=[];let i=!1;for(let o=0;o<r.length;o++)s[o]=r.charCodeAt(o),!i&&(s[o]===46||s[o]===101||s[o]===69)&&(i=!0);i||(s.push(46),s.push(48)),e.push(s)}}function qI(n,e){if(Array.isArray(n[0])||Array.isArray(e[0]))throw new Error(`${On} complex map keys are not supported`);const t=n[0],r=e[0];if(t.type!==S.string||r.type!==S.string)throw new Error(`${On} non-string map keys are not supported`);if(t<r)return-1;if(t>r)return 1;throw new Error(`${On} unexpected duplicate map keys, this is not supported`)}const KI={addBreakTokens:!0,mapSorter:qI};function WI(n,e){return e=Object.assign({},KI,e),Zg(n,new zI,e)}class r4{constructor(e,t={}){this._pos=0,this.data=e,this.options=t,this.modeStack=["value"],this.lastToken=""}pos(){return this._pos}done(){return this._pos>=this.data.length}ch(){return this.data[this._pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;e===32||e===9||e===13||e===10;)e=this.data[++this._pos]}expect(e){if(this.data.length-this._pos<e.length)throw new Error(`${G} unexpected end of input at position ${this._pos}`);for(let t=0;t<e.length;t++)if(this.data[this._pos++]!==e[t])throw new Error(`${G} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...e)}'`)}parseNumber(){const e=this._pos;let t=!1,r=!1;const s=a=>{for(;!this.done();){const c=this.ch();if(a.includes(c))this._pos++;else break}};if(this.ch()===45&&(t=!0,this._pos++),this.ch()===48)if(this._pos++,this.ch()===46)this._pos++,r=!0;else return new F(S.uint,0,this._pos-e);if(s([48,49,50,51,52,53,54,55,56,57]),t&&this._pos===e+1)throw new Error(`${G} unexpected token at position ${this._pos}`);if(!this.done()&&this.ch()===46){if(r)throw new Error(`${G} unexpected token at position ${this._pos}`);r=!0,this._pos++,s([48,49,50,51,52,53,54,55,56,57])}!this.done()&&(this.ch()===101||this.ch()===69)&&(r=!0,this._pos++,!this.done()&&(this.ch()===43||this.ch()===45)&&this._pos++,s([48,49,50,51,52,53,54,55,56,57]));const i=String.fromCharCode.apply(null,this.data.subarray(e,this._pos)),o=parseFloat(i);return r?new F(S.float,o,this._pos-e):this.options.allowBigInt!==!0||Number.isSafeInteger(o)?new F(o>=0?S.uint:S.negint,o,this._pos-e):new F(o>=0?S.uint:S.negint,BigInt(i),this._pos-e)}parseString(){if(this.ch()!==34)throw new Error(`${G} unexpected character at position ${this._pos}; this shouldn't happen`);this._pos++;for(let i=this._pos,o=0;i<this.data.length&&o<65536;i++,o++){const a=this.data[i];if(a===92||a<32||a>=128)break;if(a===34){const c=String.fromCharCode.apply(null,this.data.subarray(this._pos,i));return this._pos=i+1,new F(S.string,c,o)}}const e=this._pos,t=[],r=()=>{if(this._pos+4>=this.data.length)throw new Error(`${G} unexpected end of unicode escape sequence at position ${this._pos}`);let i=0;for(let o=0;o<4;o++){let a=this.ch();if(a>=48&&a<=57)a-=48;else if(a>=97&&a<=102)a=a-97+10;else if(a>=65&&a<=70)a=a-65+10;else throw new Error(`${G} unexpected unicode escape character at position ${this._pos}`);i=i*16+a,this._pos++}return i},s=()=>{const i=this.ch();let o=null,a=i>239?4:i>223?3:i>191?2:1;if(this._pos+a>this.data.length)throw new Error(`${G} unexpected unicode sequence at position ${this._pos}`);let c,l,u,h;switch(a){case 1:i<128&&(o=i);break;case 2:c=this.data[this._pos+1],(c&192)===128&&(h=(i&31)<<6|c&63,h>127&&(o=h));break;case 3:c=this.data[this._pos+1],l=this.data[this._pos+2],(c&192)===128&&(l&192)===128&&(h=(i&15)<<12|(c&63)<<6|l&63,h>2047&&(h<55296||h>57343)&&(o=h));break;case 4:c=this.data[this._pos+1],l=this.data[this._pos+2],u=this.data[this._pos+3],(c&192)===128&&(l&192)===128&&(u&192)===128&&(h=(i&15)<<18|(c&63)<<12|(l&63)<<6|u&63,h>65535&&h<1114112&&(o=h))}o===null?(o=65533,a=1):o>65535&&(o-=65536,t.push(o>>>10&1023|55296),o=56320|o&1023),t.push(o),this._pos+=a};for(;!this.done();){const i=this.ch();let o;switch(i){case 92:if(this._pos++,this.done())throw new Error(`${G} unexpected string termination at position ${this._pos}`);switch(o=this.ch(),this._pos++,o){case 34:case 39:case 92:case 47:t.push(o);break;case 98:t.push(8);break;case 116:t.push(9);break;case 110:t.push(10);break;case 102:t.push(12);break;case 114:t.push(13);break;case 117:t.push(r());break;default:throw new Error(`${G} unexpected string escape character at position ${this._pos}`)}break;case 34:return this._pos++,new F(S.string,Hg(t),this._pos-e);default:if(i<32)throw new Error(`${G} invalid control character at position ${this._pos}`);i<128?(t.push(i),this._pos++):s()}}throw new Error(`${G} unexpected end of string at position ${this._pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this._pos++,new F(S.map,1/0,1);case 91:return this.modeStack.push("array-start"),this._pos++,new F(S.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new F(S.null,null,4);case 102:return this.expect([102,97,108,115,101]),new F(S.false,!1,5);case 116:return this.expect([116,114,117,101]),new F(S.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${G} unexpected character at position ${this._pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":{if(this.modeStack.pop(),this.ch()===93)return this._pos++,this.skipWhitespace(),new F(S.break,void 0,1);if(this.ch()!==44)throw new Error(`${G} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue()}case"array-start":return this.modeStack.pop(),this.ch()===93?(this._pos++,this.skipWhitespace(),new F(S.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(this.ch()===125)return this.modeStack.pop(),this._pos++,this.skipWhitespace(),new F(S.break,void 0,1);if(this.ch()!==44)throw new Error(`${G} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this._pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),this.ch()===125)return this._pos++,this.skipWhitespace(),new F(S.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),this.ch()!==58)throw new Error(`${G} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${G} unexpected parse state at position ${this._pos}; this shouldn't happen`)}}}function GI(n,e){return e=Object.assign({tokenizer:new r4(n,e)},e),Yr(n,e)}function QI(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}function YI(n){if(n.asCID!==n&&n["/"]!==n.bytes)return null;const e=Y.asCID(n);if(!e)return null;const t=e.toString();return[new F(S.map,1/0,1),new F(S.string,"/",1),new F(S.string,t,t.length),new F(S.break,void 0,1)]}function Ua(n){const e=qt.encode(n).slice(1);return[new F(S.map,1/0,1),new F(S.string,"/",1),new F(S.map,1/0,1),new F(S.string,"bytes",5),new F(S.string,e,e.length),new F(S.break,void 0,1),new F(S.break,void 0,1)]}function Zt(n){return Ua(new Uint8Array(n.buffer,n.byteOffset,n.byteLength))}function XI(n){return Ua(new Uint8Array(n))}function ZI(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function jI(n){if(Number.isNaN(n))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(n===1/0||n===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const JI={typeEncoders:{Object:YI,Buffer:Ua,Uint8Array:Ua,Int8Array:Zt,Uint16Array:Zt,Int16Array:Zt,Uint32Array:Zt,Int32Array:Zt,Float32Array:Zt,Float64Array:Zt,Uint8ClampedArray:Zt,BigInt64Array:Zt,BigUint64Array:Zt,DataView:Zt,ArrayBuffer:XI,undefined:ZI,number:jI}};class eA extends r4{constructor(e,t){super(e,t),this.tokenBuffer=[]}done(){return this.tokenBuffer.length===0&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===S.map){const t=this._next();if(t.type===S.string&&t.value==="/"){const r=this._next();if(r.type===S.string){if(this._next().type!==S.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(r),new F(S.tag,42,0)}if(r.type===S.map){const s=this._next();if(s.type===S.string&&s.value==="bytes"){const i=this._next();if(i.type===S.string){for(let a=0;a<2;a++)if(this._next().type!==S.break)throw new Error("Invalid encoded Bytes form");const o=qt.decode(`m${i.value}`);return new F(S.bytes,o,i.value.length)}this.tokenBuffer.push(i)}this.tokenBuffer.push(s)}this.tokenBuffer.push(r)}this.tokenBuffer.push(t)}return e}}const vu={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};vu.tags[42]=Y.parse;const tA="dag-json",n4=297,s4=n=>WI(n,JI),i4=n=>{const e=QI(n),t=Object.assign(vu,{tokenizer:new eA(e,vu)});return GI(e,t)},Ff=n=>rA.decode(s4(n)),rA=new TextDecoder,nA=n=>i4(sA.encode(n)),sA=new TextEncoder,iA=Object.freeze(Object.defineProperty({__proto__:null,code:n4,decode:i4,encode:s4,format:Ff,name:tA,parse:nA,stringify:Ff},Symbol.toStringTag,{value:"Module"})),oA=new TextDecoder;function Xh(n,e){let t=0;for(let r=0;;r+=7){if(r>=64)throw new Error("protobuf: varint overflow");if(e>=n.length)throw new Error("protobuf: unexpected end of data");const s=n[e++];if(t+=r<28?(s&127)<<r:(s&127)*2**r,s<128)break}return[t,e]}function $a(n,e){let t;[t,e]=Xh(n,e);const r=e+t;if(t<0||r<0)throw new Error("protobuf: invalid length");if(r>n.length)throw new Error("protobuf: unexpected end of data");return[n.subarray(e,r),r]}function o4(n,e){let t;return[t,e]=Xh(n,e),[t&7,t>>3,e]}function aA(n){const e={},t=n.length;let r=0;for(;r<t;){let s,i;if([s,i,r]=o4(n,r),i===1){if(e.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(s!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Hash`);if(e.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[e.Hash,r]=$a(n,r)}else if(i===2){if(e.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(s!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Name`);if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,r]=$a(n,r),e.Name=oA.decode(o)}else if(i===3){if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(s!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Tsize`);[e.Tsize,r]=Xh(n,r)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${i}`)}if(r>t)throw new Error("protobuf: (PBLink) unexpected end of data");return e}function cA(n){const e=n.length;let t=0,r,s=!1,i;for(;t<e;){let a,c;if([a,c,t]=o4(n,t),a!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${a}`);if(c===1){if(i)throw new Error("protobuf: (PBNode) duplicate Data section");[i,t]=$a(n,t),r&&(s=!0)}else if(c===2){if(s)throw new Error("protobuf: (PBNode) duplicate Links section");r||(r=[]);let l;[l,t]=$a(n,t),r.push(aA(l))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${c}`)}if(t>e)throw new Error("protobuf: (PBNode) unexpected end of data");const o={};return i&&(o.Data=i),o.Links=r||[],o}const a4=new TextEncoder,Uf=2**32,lA=2**31;function uA(n,e){let t=e.length;if(typeof n.Tsize=="number"){if(n.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(n.Tsize))throw new Error("Tsize too large for encoding");t=Pi(e,t,n.Tsize)-1,e[t]=24}if(typeof n.Name=="string"){const r=a4.encode(n.Name);t-=r.length,e.set(r,t),t=Pi(e,t,r.length)-1,e[t]=18}return n.Hash&&(t-=n.Hash.length,e.set(n.Hash,t),t=Pi(e,t,n.Hash.length)-1,e[t]=10),e.length-t}function hA(n){const e=fA(n),t=new Uint8Array(e);let r=e;if(n.Data&&(r-=n.Data.length,t.set(n.Data,r),r=Pi(t,r,n.Data.length)-1,t[r]=10),n.Links)for(let s=n.Links.length-1;s>=0;s--){const i=uA(n.Links[s],t.subarray(0,r));r-=i,r=Pi(t,r,i)-1,t[r]=18}return t}function dA(n){let e=0;if(n.Hash){const t=n.Hash.length;e+=1+t+Is(t)}if(typeof n.Name=="string"){const t=a4.encode(n.Name).length;e+=1+t+Is(t)}return typeof n.Tsize=="number"&&(e+=1+Is(n.Tsize)),e}function fA(n){let e=0;if(n.Data){const t=n.Data.length;e+=1+t+Is(t)}if(n.Links)for(const t of n.Links){const r=dA(t);e+=1+r+Is(r)}return e}function Pi(n,e,t){e-=Is(t);const r=e;for(;t>=lA;)n[e++]=t&127|128,t/=128;for(;t>=128;)n[e++]=t&127|128,t>>>=7;return n[e]=t,r}function Is(n){return n%2===0&&n++,Math.floor((pA(n)+6)/7)}function pA(n){let e=0;return n>=Uf&&(n=Math.floor(n/Uf),e=32),n>=65536&&(n>>>=16,e+=16),n>=256&&(n>>>=8,e+=8),e+gA[n]}const gA=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],mA=["Data","Links"],yA=["Hash","Name","Tsize"],Eu=new TextEncoder;function c4(n,e){if(n===e)return 0;const t=n.Name?Eu.encode(n.Name):[],r=e.Name?Eu.encode(e.Name):[];let s=t.length,i=r.length;for(let o=0,a=Math.min(s,i);o<a;++o)if(t[o]!==r[o]){s=t[o],i=r[o];break}return s<i?-1:i<s?1:0}function $f(n,e){return!Object.keys(n).some(t=>!e.includes(t))}function l4(n){if(typeof n.asCID=="object"){const t=Y.asCID(n);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if(typeof n!="object"||Array.isArray(n))throw new TypeError("Invalid DAG-PB form");const e={};if(n.Hash){let t=Y.asCID(n.Hash);try{t||(typeof n.Hash=="string"?t=Y.parse(n.Hash):n.Hash instanceof Uint8Array&&(t=Y.decode(n.Hash)))}catch(r){throw new TypeError(`Invalid DAG-PB form: ${r.message}`)}t&&(e.Hash=t)}if(!e.Hash)throw new TypeError("Invalid DAG-PB form");return typeof n.Name=="string"&&(e.Name=n.Name),typeof n.Tsize=="number"&&(e.Tsize=n.Tsize),e}function u4(n){if((n instanceof Uint8Array||typeof n=="string")&&(n={Data:n}),typeof n!="object"||Array.isArray(n))throw new TypeError("Invalid DAG-PB form");const e={};if(n.Data!==void 0)if(typeof n.Data=="string")e.Data=Eu.encode(n.Data);else if(n.Data instanceof Uint8Array)e.Data=n.Data;else throw new TypeError("Invalid DAG-PB form");if(n.Links!==void 0)if(Array.isArray(n.Links))e.Links=n.Links.map(l4),e.Links.sort(c4);else throw new TypeError("Invalid DAG-PB form");else e.Links=[];return e}function h4(n){if(!n||typeof n!="object"||Array.isArray(n)||n instanceof Uint8Array||n["/"]&&n["/"]===n.bytes)throw new TypeError("Invalid DAG-PB form");if(!$f(n,mA))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(n.Data!==void 0&&!(n.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be bytes)");if(!Array.isArray(n.Links))throw new TypeError("Invalid DAG-PB form (Links must be a list)");for(let e=0;e<n.Links.length;e++){const t=n.Links[e];if(!t||typeof t!="object"||Array.isArray(t)||t instanceof Uint8Array||t["/"]&&t["/"]===t.bytes)throw new TypeError("Invalid DAG-PB form (bad link)");if(!$f(t,yA))throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");if(t.Hash===void 0)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(t.Hash==null||!t.Hash["/"]||t.Hash["/"]!==t.Hash.bytes)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(t.Name!==void 0&&typeof t.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(t.Tsize!==void 0){if(typeof t.Tsize!="number"||t.Tsize%1!==0)throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(t.Tsize<0)throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)")}if(e>0&&c4(t,n.Links[e-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function wA(n,e=[]){return u4({Data:n,Links:e})}function bA(n,e,t){return l4({Hash:t,Name:n,Tsize:e})}function vA(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}const EA="dag-pb",d4=112;function SA(n){h4(n);const e={};return n.Links&&(e.Links=n.Links.map(t=>{const r={};return t.Hash&&(r.Hash=t.Hash.bytes),t.Name!==void 0&&(r.Name=t.Name),t.Tsize!==void 0&&(r.Tsize=t.Tsize),r})),n.Data&&(e.Data=n.Data),hA(e)}function _A(n){const e=vA(n),t=cA(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map(s=>{const i={};try{i.Hash=Y.decode(s.Hash)}catch{}if(!i.Hash)throw new Error("Invalid Hash field found in link, expected CID");return s.Name!==void 0&&(i.Name=s.Name),s.Tsize!==void 0&&(i.Tsize=s.Tsize),i})),r}const xA=Object.freeze(Object.defineProperty({__proto__:null,code:d4,createLink:bA,createNode:wA,decode:_A,encode:SA,name:EA,prepare:u4,validate:h4},Symbol.toStringTag,{value:"Module"}));function Zh(n){return n?.then!=null}function kA(n=[],e){const t={[d4]:xA,[ic]:h7,[t4]:HI,[n4]:iA,[J0]:a7};return n.forEach(r=>{t[r.code]=r}),async r=>{let s=t[r];if(s==null&&e!=null){const i=e(r);Zh(i)?s=await i:s=i,t[s.code]=s}if(s!=null)return s;throw new TI(`Could not load codec for ${r}`)}}function IA(n=[],e){const t={[Nt.code]:Nt,[Id.code]:Id,[$n.code]:$n};return n.forEach(r=>{t[r.code]=r}),async r=>{let s=t[r];if(s==null&&e!=null){const i=e(r);Zh(i)?s=await i:s=i,t[s.code]=s}if(s!=null)return s;throw new AI(`No hasher configured for multihash code 0x${r.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`)}}class f4{has(e,t){return Promise.reject(new Error(".has is not implemented"))}put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}async*putMany(e,t){for await(const{cid:r,block:s}of e)await this.put(r,s,t),yield r}get(e,t){return Promise.reject(new Error(".get is not implemented"))}async*getMany(e,t){for await(const r of e)yield{cid:r,block:await this.get(r,t)}}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*deleteMany(e,t){for await(const r of e)await this.delete(r,t),yield r}async*getAll(e){throw new Error(".getAll is not implemented")}}const Fo=0;class AA extends f4{child;constructor(e){super(),this.child=e}put(e,t){return e.multihash.code===Fo||this.child==null?e:this.child.put(e,t)}get(e){if(e.multihash.code===Fo)return e.multihash.digest;if(this.child==null)throw new Ws;return this.child.get(e)}has(e){return e.multihash.code===Fo?!0:this.child==null?!1:this.child.has(e)}delete(e){if(e.code!==Fo&&this.child!=null)return this.child.delete(e)}getAll(e){return this.child!=null?this.child.getAll(e):[]}}class p4{child;getHasher;log;logger;components;constructor(e){this.log=e.logger.forComponent("helia:networked-storage"),this.logger=e.logger,this.components=e,this.child=new AA(e.blockstore),this.getHasher=e.getHasher}async put(e,t,r={}){return await this.child.has(e,r)?(r.onProgress?.(new Q("blocks:put:duplicate",e)),e):(r.onProgress?.(new Q("blocks:put:providers:notify",e)),await Promise.all(this.components.blockBrokers.map(async s=>s.announce?.(e,t,r))),r.onProgress?.(new Q("blocks:put:blockstore:put",e)),this.child.put(e,t,r))}async*putMany(e,t={}){const r=kn(e,async({cid:i})=>{const o=await this.child.has(i,t);return o&&t.onProgress?.(new Q("blocks:put-many:duplicate",i)),!o}),s=fa(r,async({cid:i,block:o})=>{t.onProgress?.(new Q("blocks:put-many:providers:notify",i)),await Promise.all(this.components.blockBrokers.map(async a=>a.announce?.(i,o,t)))});t.onProgress?.(new Q("blocks:put-many:blockstore:put-many")),yield*this.child.putMany(s,t)}async get(e,t={}){if(t.offline!==!0&&!await this.child.has(e,t)){const r=await this.getHasher(e.multihash.code);t.onProgress?.(new Q("blocks:get:providers:get",e));const s=await Vf(e,this.components.blockBrokers,r,{...t,log:this.log});return t.onProgress?.(new Q("blocks:get:blockstore:put",e)),await this.child.put(e,s,t),t.onProgress?.(new Q("blocks:get:providers:notify",e)),await Promise.all(this.components.blockBrokers.map(async i=>i.announce?.(e,s,t))),s}return t.onProgress?.(new Q("blocks:get:blockstore:get",e)),this.child.get(e,t)}async*getMany(e,t={}){t.onProgress?.(new Q("blocks:get-many:blockstore:get-many")),yield*this.child.getMany(fa(e,async r=>{if(t.offline!==!0&&!await this.child.has(r,t)){const s=await this.getHasher(r.multihash.code);t.onProgress?.(new Q("blocks:get-many:providers:get",r));const i=await Vf(r,this.components.blockBrokers,s,{...t,log:this.log});t.onProgress?.(new Q("blocks:get-many:blockstore:put",r)),await this.child.put(r,i,t),t.onProgress?.(new Q("blocks:get-many:providers:notify",r)),await Promise.all(this.components.blockBrokers.map(async o=>o.announce?.(r,i,t)))}}))}async delete(e,t={}){t.onProgress?.(new Q("blocks:delete:blockstore:delete",e)),await this.child.delete(e,t)}async*deleteMany(e,t={}){t.onProgress?.(new Q("blocks:delete-many:blockstore:delete-many")),yield*this.child.deleteMany(async function*(){for await(const r of e)yield r}(),t)}async has(e,t={}){return this.child.has(e,t)}async*getAll(e={}){e.onProgress?.(new Q("blocks:get-all:blockstore:get-many")),yield*this.child.getAll(e)}}class TA extends p4{started;constructor(e){super(e),this.started=!1}isStarted(){return this.started}async start(){await Nr(this.child,...this.components.blockBrokers),this.started=!0}async stop(){await wn(this.child,...this.components.blockBrokers),this.started=!1}unwrap(){return this.child}createSession(e,t){const r=this.components.blockBrokers.map(s=>s.createSession==null?s:s.createSession(t));return new PA({blockstore:this.child,blockBrokers:r,getHasher:this.getHasher,logger:this.logger},{root:e})}}class PA extends p4{closeController;constructor(e,t){super(e),this.closeController=new AbortController,this.closeController.signal,this.log=e.logger.forComponent(`helia:session-storage:${t.root}`)}close(){this.closeController.abort()}async put(e,t,r={}){const s=be([this.closeController.signal,r.signal]);try{return await super.put(e,t,{...r,signal:s})}finally{s.clear()}}async*putMany(e,t={}){const r=be([this.closeController.signal,t.signal]);try{yield*super.putMany(e,{...t,signal:r})}finally{r.clear()}}async get(e,t={}){const r=be([this.closeController.signal,t.signal]);try{return await super.get(e,{...t,signal:r})}finally{r.clear()}}async*getMany(e,t={}){const r=be([this.closeController.signal,t.signal]);try{yield*super.getMany(e,{...t,signal:r})}finally{r.clear()}}async delete(e,t={}){const r=be([this.closeController.signal,t.signal]);try{await super.delete(e,{...t,signal:r})}finally{r.clear()}}async*deleteMany(e,t={}){const r=be([this.closeController.signal,t.signal]);try{yield*super.deleteMany(e,{...t,signal:r})}finally{r.clear()}}async has(e,t={}){const r=be([this.closeController.signal,t.signal]);try{return await super.has(e,{...t,signal:r})}finally{r.clear()}}async*getAll(e={}){const t=be([this.closeController.signal,e.signal]);try{yield*super.getAll({...e,signal:t})}finally{t.clear()}}}function CA(n){return typeof n.retrieve=="function"}const DA=(n,e)=>{if(e==null)throw new B(`No hasher configured for multihash code 0x${n.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);return async t=>{let r;const s=e.digest(t);if(Zh(s)?r=await s:r=s,!pe(r.digest,n.multihash.digest))throw new $u("Hash of downloaded block did not match multihash from passed CID")}};async function Vf(n,e,t,r){const s=DA(n,t),i=new AbortController,o=be([i.signal,r.signal]);i.signal;const a=[];for(const c of e)CA(c)&&a.push(c);try{return await Promise.any(a.map(async c=>{try{let l=!1;const u=await c.retrieve(n,{...r,signal:o,validateFn:async h=>{await s(h),l=!0}});return l||await s(u),u}catch(l){throw r.log.error("could not retrieve verified block for %c",n,l),l}}))}finally{i.abort(),o.clear()}}class g4 extends Ke{intialPeerSearchComplete;requests;name;log;logger;minProviders;maxProviders;providers;evictionFilter;constructor(e,t){super(),this.name=t.name,this.logger=e.logger,this.log=e.logger.forComponent(this.name),this.requests=new Map,this.minProviders=t.minProviders??xI,this.maxProviders=t.maxProviders??kI,this.providers=[],this.evictionFilter=Wn(this.maxProviders)}async retrieve(e,t={}){const r=qt.encode(e.multihash.bytes),s=this.requests.get(r);if(s!=null)return this.log("join existing request for %c",e),s;const i=ae();if(this.requests.set(r,i.promise),this.providers.length===0){let l=!1;this.intialPeerSearchComplete==null&&(l=!0,this.log=this.logger.forComponent(`${this.name}:${e}`),this.intialPeerSearchComplete=this.findProviders(e,this.minProviders,t)),await this.intialPeerSearchComplete,l&&this.log("found initial session peers for %c",e)}let o=!1;const a=new Gn({concurrency:this.maxProviders});a.addEventListener("error",()=>{}),a.addEventListener("failure",l=>{this.log.error("error querying provider %o, evicting from session",l.detail.job.options.provider,l.detail.error),this.evict(l.detail.job.options.provider)}),a.addEventListener("success",l=>{o=!0,i.resolve(l.detail.result)}),a.addEventListener("idle",()=>{o||t.signal?.aborted===!0||Promise.resolve().then(async()=>{this.log("no session peers had block for for %c, finding new providers",e);for(let l=0;l<this.minProviders&&this.providers.length!==0;l++){const u=this.providers[Math.floor(Math.random()*this.providers.length)];this.evict(u)}await this.findProviders(e,this.minProviders,t),this.log("found new providers re-retrieving %c",e),this.requests.delete(r),i.resolve(await this.retrieve(e,t))}).catch(l=>{this.log.error("could not find new providers for %c",e,l),i.reject(l)})});const c=l=>{a.add(async()=>this.queryProvider(e,l.detail,t),{provider:l.detail}).catch(u=>{t.signal?.aborted!==!0&&this.log.error("error retrieving session block for %c",e,u)})};this.addEventListener("provider",c),Promise.all([...this.providers].map(async l=>a.add(async()=>this.queryProvider(e,l,t),{provider:l}))).catch(l=>{t.signal?.aborted!==!0&&this.log.error("error retrieving session block for %c",e,l)});try{return await i.promise}finally{this.removeEventListener("provider",c),a.clear(),this.requests.delete(r)}}evict(e){this.evictionFilter.add(this.toEvictionKey(e));const t=this.providers.findIndex(r=>this.equals(r,e));t!==-1&&this.providers.splice(t,1)}isEvicted(e){return this.evictionFilter.has(this.toEvictionKey(e))}hasProvider(e){return!!(this.providers.find(t=>this.equals(t,e))!=null||this.isEvicted(e))}async findProviders(e,t,r){const s=ae();let i=0;return Promise.resolve().then(async()=>{this.log("finding %d-%d new provider(s) for %c",t,this.maxProviders,e);for await(const o of this.findNewProviders(e,r)){if(i===this.maxProviders||r.signal?.aborted===!0)break;if(!this.hasProvider(o)&&(this.log("found %d/%d new providers",i,this.maxProviders),this.providers.push(o),this.safeDispatchEvent("provider",{detail:o}),i++,i===t&&(this.log("session is ready"),s.resolve()),this.providers.length===this.maxProviders)){this.log("found max session peers",i);break}}if(this.log("found %d/%d new session peers",i,this.maxProviders),i<t)throw new II(`Found ${i} of ${t} ${this.name} providers for ${e}`)}).catch(o=>{this.log.error("error searching routing for potential session peers for %c",e,o.errors??o),s.reject(o)}),s.promise}}class RA{blockstore;datastore;pins;logger;routing;getCodec;getHasher;dns;metrics;log;constructor(e){this.logger=e.logger??wc(),this.log=this.logger.forComponent("helia"),this.getHasher=IA(e.hashers,e.loadHasher),this.getCodec=kA(e.codecs,e.loadCodec),this.dns=e.dns??wg(),this.metrics=e.metrics;const t={blockstore:e.blockstore,datastore:e.datastore,logger:this.logger,blockBrokers:[],getHasher:this.getHasher,getCodec:this.getCodec,dns:this.dns,metrics:this.metrics,...e.components??{}};this.routing=t.routing=new CI(t,{routers:(e.routers??[]).flatMap(s=>{const i=[s];return s[As]!=null&&i.push(s[As]),s[Ts]!=null&&i.push(s[Ts]),i}),providerLookupConcurrency:e.providerLookupConcurrency});const r=new TA(t);this.pins=new _I(e.datastore,r,this.getCodec),this.blockstore=new DI(r,this.pins,{holdGcLock:e.holdGcLock??!0}),this.datastore=e.datastore,t.blockBrokers=e.blockBrokers.map(s=>s(t))}async start(){await RI(this.datastore),await Nr(this.blockstore,this.datastore,this.routing)}async stop(){await wn(this.blockstore,this.datastore,this.routing)}async gc(e={}){const t=await this.blockstore.lock.writeLock();try{const r=this,s=this.blockstore.unwrap();this.log("gc start"),await pn(s.deleteMany(async function*(){for await(const{cid:i}of s.getAll())try{if(await r.pins.isPinned(i,e))continue;yield i,e.onProgress?.(new Q("helia:gc:deleted",i))}catch(o){r.log.error("Error during gc",o),e.onProgress?.(new Q("helia:gc:error",o))}}()))}finally{t()}this.log("gc finished")}}class MA extends g4{wantList;network;constructor(e,t){super(e,{...t,name:"helia:bitswap:session"}),this.wantList=e.wantList,this.network=e.network}async queryProvider(e,t,r){this.log("sending WANT-BLOCK for %c to %p",e,t);const s=await this.wantList.wantSessionBlock(e,t,r);if(this.log("%p %s %c",t,s.has?"has":"does not have",e),s.has&&s.block!=null)return s.block;throw new Error("Provider did not have block")}async*findNewProviders(e,t={}){for await(const r of this.network.findProviders(e,t))yield r.id}toEvictionKey(e){return e.toMultihash().bytes}equals(e,t){return e.equals(t)}}function LA(n,e){return new MA(n,e)}class NA{blocksReceived;duplicateBlocksReceived;dataReceived;duplicateDataReceived;constructor(e){this.blocksReceived=e.metrics?.registerMetricGroup("helia_bitswap_received_blocks"),this.duplicateBlocksReceived=e.metrics?.registerMetricGroup("helia_bitswap_duplicate_received_blocks"),this.dataReceived=e.metrics?.registerMetricGroup("helia_bitswap_data_received_bytes"),this.duplicateDataReceived=e.metrics?.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes")}updateBlocksReceived(e=1,t){const r={global:e};t!=null&&(r[t.toString()]=e),this.blocksReceived?.increment(r)}updateDuplicateBlocksReceived(e=1,t){const r={global:e};t!=null&&(r[t.toString()]=e),this.duplicateBlocksReceived?.increment(r)}updateDataReceived(e,t){const r={global:e};t!=null&&(r[t.toString()]=e),this.dataReceived?.increment(r)}updateDuplicateDataReceived(e,t){const r={global:e};t!=null&&(r[t.toString()]=e),this.duplicateDataReceived?.increment(r)}}function BA(n){if(!(n instanceof Uint8Array))throw new Error("arg needs to be a Uint8Array");const e=[];for(;n.length>0;){const t=ar(n);e.push(t),n=n.slice(ye(t))}return e}class OA extends Ke{peers;wants;network;log;sendMessagesDelay;sendMessagesTimeout;hashLoader;sendingMessages;constructor(e,t={}){super(),this.peers=zp({name:"helia_bitswap_peers",metrics:e.metrics}),this.wants=Lg({name:"helia_bitswap_wantlist",metrics:e.metrics}),this.network=e.network,this.sendMessagesDelay=t.sendMessagesDelay??$x,this.log=e.logger.forComponent("helia:bitswap:wantlist"),this.hashLoader=t.hashLoader,this.network.addEventListener("bitswap:message",r=>{this.receiveMessage(r.detail.peer,r.detail.message).catch(s=>{this.log.error("error receiving bitswap message from %p",r.detail.peer,s)})}),this.network.addEventListener("peer:connected",r=>{this.peerConnected(r.detail).catch(s=>{this.log.error("error processing newly connected bitswap peer %p",r.detail,s)})}),this.network.addEventListener("peer:disconnected",r=>{this.peerDisconnected(r.detail)})}async addEntry(e,t){const r=K(e.multihash.bytes,"base64");let s=this.wants.get(r);s==null&&(s={cid:e,priority:t.priority??1,wantType:t.wantType??Ye.WantBlock,cancel:!1,sendDontHave:!0},this.wants.set(r,s)),s.wantType===Ye.WantHave&&t.wantType===Ye.WantBlock&&(s.wantType=Ye.WantBlock),await this.sendMessagesDebounced();try{return t.wantType===Ye.WantBlock?(await zt(this,"block",t?.signal,{filter:a=>pe(e.multihash.digest,a.detail.cid.multihash.digest),errorMessage:"Want was aborted"})).detail:(await zt(this,"presence",t?.signal,{filter:o=>pe(e.multihash.digest,o.detail.cid.multihash.digest),errorMessage:"Want was aborted"})).detail}finally{t.signal?.aborted===!0&&(this.log("want for %c was aborted, cancelling want",e),s.cancel=!0,await this.sendMessagesDebounced())}}async sendMessagesDebounced(){await this.sendingMessages?.promise,clearTimeout(this.sendMessagesTimeout),this.sendMessagesTimeout=setTimeout(()=>{this.sendMessages().catch(e=>{this.log("error sending messages to peers",e)})},this.sendMessagesDelay)}async sendMessages(){this.sendingMessages=ae(),await Promise.all([...this.peers.entries()].map(async([e,t])=>{const r=new Set,s=new vi;for(const[i,o]of this.wants.entries())t.has(i)||o.cancel||(r.add(i),s.addWantlistEntry(o.cid,{cid:o.cid.bytes,priority:o.priority,wantType:o.wantType,cancel:o.cancel,sendDontHave:o.sendDontHave}));if(s.wantlist.size!==0)try{await this.network.sendMessage(e,s);for(const i of r)t.add(i)}catch(i){this.log.error("error sending full wantlist to new peer",i)}})).catch(e=>{this.log.error("error sending messages",e)});for(const[e,t]of this.wants)if(t.cancel){this.wants.delete(e);for(const r of this.peers.values())r.delete(e)}this.sendingMessages.resolve()}has(e){const t=K(e.multihash.bytes,"base64");return this.wants.has(t)}async wantSessionPresence(e,t,r={}){const s=new vi;return s.addWantlistEntry(e,{cid:e.bytes,sendDontHave:!0,wantType:Ye.WantHave,priority:1}),await this.network.sendMessage(t,s),(await zt(this,"presence",r.signal,{filter:o=>t.equals(o.detail.sender)&&pe(e.multihash.digest,o.detail.cid.multihash.digest)})).detail}async wantBlock(e,t={}){return this.addEntry(e,{...t,wantType:Ye.WantBlock})}async wantSessionBlock(e,t,r={}){const s=new vi;return s.addWantlistEntry(e,{cid:e.bytes,sendDontHave:!0,wantType:Ye.WantBlock,priority:1}),await this.network.sendMessage(t,s),(await zt(this,"presence",r.signal,{filter:o=>t.equals(o.detail.sender)&&pe(e.multihash.digest,o.detail.cid.multihash.digest)})).detail}async receivedBlock(e,t){const r=K(e.multihash.bytes,"base64"),s=this.wants.get(r);s!=null&&(s.cancel=!0,await this.sendMessagesDebounced())}async receiveMessage(e,t){this.log("received message from %p with %d blocks",e,t.blocks.length);let r=!1;for(const s of t.blocks){if(s.prefix==null||s.data==null)continue;const i=BA(s.prefix),o=i[0],a=i[1],c=i[2],l=c===Nt.code?Nt:await this.hashLoader?.getHasher(c);if(l==null){this.log.error("unknown hash algorithm",c);continue}let u=l.digest(s.data);u.then!=null&&(u=await u);const h=Y.create(o===0?0:1,a,u);this.log("received block from %p for %c",e,h),this.safeDispatchEvent("block",{detail:{sender:e,cid:h,block:s.data}}),this.safeDispatchEvent("presence",{detail:{sender:e,cid:h,has:!0,block:s.data}});const d=K(h.multihash.bytes,"base64"),f=this.wants.get(d);f!=null&&(f.cancel=!0,r=!0)}for(const{cid:s,type:i}of t.blockPresences){const o=Y.decode(s);this.log("received %s from %p for %c",i,e,o),this.safeDispatchEvent("presence",{detail:{sender:e,cid:o,has:i===vr.HaveBlock}})}r&&await this.sendMessagesDebounced()}async peerConnected(e){const t=new Set,r=new vi(!0);for(const[s,i]of this.wants.entries())i.cancel||(t.add(s),r.addWantlistEntry(i.cid,{cid:i.cid.bytes,priority:1,wantType:Ye.WantBlock,cancel:!1,sendDontHave:!1}));if(r.wantlist.size===0){this.peers.set(e,t);return}try{await this.network.sendMessage(e,r),this.peers.set(e,t)}catch(s){this.log.error("error sending full wantlist to new peer %p",e,s)}}peerDisconnected(e){this.peers.delete(e)}start(){}stop(){this.peers.clear(),clearTimeout(this.sendMessagesTimeout)}}class FA{log;logger;stats;network;blockstore;peerWantLists;wantList;constructor(e,t={}){this.logger=e.logger,this.log=e.logger.forComponent("helia:bitswap"),this.blockstore=e.blockstore,this.stats=new NA(e),this.network=new Jx(e,t),this.peerWantLists=new rk({...e,network:this.network},t),this.wantList=new OA({...e,network:this.network},t)}createSession(e={}){return LA({wantList:this.wantList,network:this.network,logger:this.logger},e)}async want(e,t={}){const r=new AbortController,s=be([r.signal,t.signal]);r.signal,this.network.findAndConnect(e,{...t,signal:s}).catch(i=>{r.signal.aborted||this.log.error("error during finding and connect for cid %c",e,i)});try{return(await this.wantList.wantBlock(e,{...t,signal:s})).block}finally{r.abort(),s.clear()}}async notify(e,t,r={}){await Promise.all([this.peerWantLists.receivedBlock(e,r),this.wantList.receivedBlock(e,r)])}getWantlist(){return[...this.wantList.wants.values()].filter(e=>!e.cancel).map(e=>({cid:e.cid,priority:e.priority,wantType:e.wantType}))}getPeerWantlist(e){return this.peerWantLists.wantListForPeer(e)}async start(){this.wantList.start(),await this.network.start()}async stop(){this.wantList.stop(),await this.network.stop()}}const UA=(n,e={})=>new FA(n,e);class $A{bitswap;started;constructor(e,t={}){const{getHasher:r}=e;this.bitswap=UA(e,{hashLoader:{getHasher:async s=>r(s)},...t}),this.started=!1}isStarted(){return this.started}async start(){await this.bitswap.start(),this.started=!0}async stop(){await this.bitswap.stop(),this.started=!1}async announce(e,t,r){await this.bitswap.notify(e,t,r)}async retrieve(e,t={}){return this.bitswap.want(e,t)}createSession(e){const t=this.bitswap.createSession(e);return{announce:async(r,s,i)=>{await this.bitswap.notify(r,s,i)},retrieve:async(r,s)=>t.retrieve(r,s)}}}function VA(n={}){return e=>new $A(e,n)}class HA{url;#e=0;#t=0;#r=0;#s=0;#a=new Map;log;constructor(e,t){this.url=e instanceof URL?e:new URL(e),this.log=t.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`)}#l(e){const t=e.multihash.bytes;return qt.encode(t)}async getRawBlock(e,t){const r=new URL(this.url.toString());if(r.pathname=`/ipfs/${e.toString()}`,r.search="?format=raw",t?.aborted===!0)throw new Error(`Signal to fetch raw block for CID ${e} from gateway ${this.url} was aborted prior to fetch`);const s=this.#l(e),i=new AbortController,o=()=>{i.abort()};t?.addEventListener("abort",o);try{let a=this.#a.get(s);return a==null&&(this.#e++,a=fetch(r.toString(),{signal:i.signal,headers:{Accept:"application/vnd.ipld.raw"},cache:"force-cache"}).then(async c=>{if(this.log("GET %s %d",r,c.status),!c.ok)throw this.#t++,new Error(`unable to fetch raw block for CID ${e} from gateway ${this.url}`);return this.#s++,new Uint8Array(await c.arrayBuffer())}),this.#a.set(s,a)),await a}catch{throw t?.aborted===!0?new Error(`fetching raw block for CID ${e} from gateway ${this.url} was aborted`):(this.#t++,new Error(`unable to fetch raw block for CID ${e}`))}finally{t?.removeEventListener("abort",o),this.#a.delete(s)}}reliability(){return this.#e===0?1:this.#r>0?-1/0:this.#s/(this.#e+this.#t*3)}incrementInvalidBlocks(){this.#r++}getStats(){return{attempts:this.#e,errors:this.#t,invalidBlocks:this.#r,successes:this.#s,pendingResponses:this.#a.size}}}function zA(n,e,t){return n.filter(r=>{if(ob.matches(r)||e&&sb.matches(r))return t||Cp.matches(r)?!0:vn(r.toOptions().host)===!1;if(!e&&t){const{host:s}=r.toOptions();if(s==="127.0.0.1"||s==="localhost"||s.endsWith(".localhost"))return!0}return!1})}async function*m4(n,e,t,r,s,i){for await(const o of e.findProviders(n,i)){const a=zA(o.multiaddrs,r,s);if(a.length===0)continue;const c=dg(a[0]);yield new HA(c,t)}}class qA extends g4{routing;allowInsecure;allowLocal;constructor(e,t){super(e,{...t,name:"helia:trustless-gateway:session"}),this.routing=e.routing,this.allowInsecure=t.allowInsecure??y4,this.allowLocal=t.allowLocal??w4}async queryProvider(e,t,r){this.log("fetching BLOCK for %c from %s",e,t.url);const s=await t.getRawBlock(e,r.signal);return this.log.trace("got block for %c from %s",e,t.url),await r.validateFn?.(s),s}async*findNewProviders(e,t={}){yield*m4(e,this.routing,this.logger,this.allowInsecure,this.allowLocal,t)}toEvictionKey(e){return e.url.toString()}equals(e,t){return e.url.toString()===t.url.toString()}}function KA(n,e){return new qA(n,e)}class WA{allowInsecure;allowLocal;routing;log;logger;constructor(e,t={}){this.log=e.logger.forComponent("helia:trustless-gateway-block-broker"),this.logger=e.logger,this.routing=e.routing,this.allowInsecure=t.allowInsecure??y4,this.allowLocal=t.allowLocal??w4}async retrieve(e,t={}){const r=[];for await(const s of m4(e,this.routing,this.logger,this.allowInsecure,this.allowLocal,t)){this.log("getting block for %c from %s",e,s.url);try{const i=await s.getRawBlock(e,t.signal);this.log.trace("got block for %c from %s",e,s.url);try{await t.validateFn?.(i)}catch(o){this.log.error("failed to validate block for %c from %s",e,s.url,o);continue}return i}catch(i){if(this.log.error("failed to get block for %c from %s",e,s.url,i),i instanceof Error?r.push(i):r.push(new Error(`Unable to fetch raw block for CID ${e} from gateway ${s.url}`)),t.signal?.aborted===!0){this.log.trace("request aborted while fetching raw block for CID %c from gateway %s",e,s.url);break}}}throw r.length>0?new AggregateError(r,`Unable to fetch raw block for CID ${e} from any gateway`):new Error(`Unable to fetch raw block for CID ${e} from any gateway`)}createSession(e={}){return KA({logger:this.logger,routing:this.routing},{...e,allowLocal:this.allowLocal,allowInsecure:this.allowInsecure})}}const y4=!1,w4=!1;function GA(n={}){return e=>new WA(e,n)}async function*Hf(n,e={}){const t=n.getReader();try{for(;;){const r=await t.read();if(r.done)return;yield r.value}}finally{e.preventCancel!==!0&&await t.cancel(),t.releaseLock()}}var _l={exports:{}},zf;function QA(){return zf||(zf=1,function(n){(function(){n.exports=g;var e=86400,t=3200,r=146097*t/400,s=e*r,i=1e3*s,o=864e13,a=4294967296,c=1e6,l="000000000",u=Math.trunc||function(v){var M=v-v%1;return M==0&&(v<0||v===0&&1/v!=1/0)?-0:M},h=g.prototype,d=(g.fromDate=function(v){return new g(+v)},g.fromInt64BE=_(0,1,2,3,0,4),g.fromInt64LE=_(3,2,1,0,4,0),g.fromString=function(N){var M,L=new g,N=(N+="").replace(/^\s*[+\-]?\d+/,function(P){var P=+P,R=1970+(P-1970)%400;return L.year=P-R,R}).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/,function(O,P,R){return P<0&&(R*=-1),M=6e4*(60*+P+ +R),""}).replace(/\.\d+$/,function(O){return L.nano=+(O+l).substr(1,9),""}).split(/\D+/);if(1<N.length?N[1]--:N[1]=0,L.time=M=Date.UTC.apply(Date,N)-(M||0),isNaN(M))throw new TypeError("Invalid Date");return y(L)},g.fromTimeT=function(v){return w(v,0)},h.year=0,h.time=0,h.nano=0,h.addNano=function(v){return this.nano+=+v||0,this},h.getNano=function(){var v=y(this);return(v.time%1e3*c+ +v.nano+1e9)%1e9},h.getTimeT=function(){var M=y(this),v=Math.floor(M.time/1e3),M=M.year;return M&&(v+=M*r*e/t),v},h.getYear=function(){return this.toDate().getUTCFullYear()+this.year},h.toDate=function(){return b(y(this).time)},h.toJSON=function(){return this.toString().replace(/0{1,6}Z$/,"Z")},h.toString=function(v){var M=this,L=M.toDate(),N={H:function(){return I(L.getUTCHours())},L:function(){return D(L.getUTCMilliseconds(),3)},M:function(){return I(L.getUTCMinutes())},N:function(){return D(M.getNano(),9)},S:function(){return I(L.getUTCSeconds())},Y:function(){var O=M.getYear();return 999999<O?"+"+O:9999<O?"+"+D(O,6):0<=O?D(O,4):-999999<=O?"-"+D(-O,6):O},a:function(){return p[L.getUTCDay()]},b:function(){return f[L.getUTCMonth()]},d:function(){return I(L.getUTCDate())},e:function(){return function(O){return(9<O?"":" ")+(0|O)}(L.getUTCDate())},m:function(){return I(L.getUTCMonth()+1)}};return function O(P){return P.replace(/%./g,function(R){var E=R[1],x=m[E],E=N[E];return x?O(x):E?E():R})}(v||d)},h.writeInt64BE=k(0,1,2,3,0,4),h.writeInt64LE=k(3,2,1,0,4,0),"%Y-%m-%dT%H:%M:%S.%NZ"),f=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],p=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],m={"%":"%",F:"%Y-%m-%d",n:`
`,R:"%H:%M",T:"%H:%M:%S",t:"	",X:"%T",Z:"GMT",z:"+0000"};return g;function g(v,M,L){var N=this;if(!(N instanceof g))return new g(v,M,L);N.time=+v||0,N.nano=+M||0,N.year=+L||0,y(N)}function y(v){var M,L,N,O=v.year,P=v.time,R=v.nano,x=((R<0||c<=R)&&(R-=(L=Math.floor(R/c))*c,P+=L,L=1),O%t);return(P<-864e13||o<P||x)&&((M=u(P/i))&&(O+=M*t,P-=M*i),(N=b(P)).setUTCFullYear(x+N.getUTCFullYear()),N=(P=+N)+(M=u((O-=x)/t))*i,M&&-864e13<=N&&N<=o&&(O-=M*t,P=N),L=1),L&&(v.year=O,v.time=P,v.nano=R),v}function b(v){var M=new Date(0);return M.setTime(v),M}function w(O,N){O=+O||0;var L=u((N=(N|0)*a)/s)+u(O/s),N=N%s+O%s,O=u(N/s);return O&&(L+=O,N-=O*s),new g(1e3*N,0,L*t)}function k(v,M,L,N,O,P){return function(x,E){var T=y(this);x=x||new Array(8),A(x,E|=0);var U=Math.floor(T.time/1e3),T=T.year*(r*e/t),C=u(T/a)+u(U/a),T=T%a+U%a,U=Math.floor(T/a);return U&&(C+=U,T-=U*a),R(x,E+O,C),R(x,E+P,T),x};function R(x,E,C){x[E+v]=C>>24&255,x[E+M]=C>>16&255,x[E+L]=C>>8&255,x[E+N]=255&C}}function _(v,M,L,N,O,P){return function(x,E){A(x,E|=0);var C=R(x,E+O);return w(R(x,E+P),C)};function R(x,E){return 16777216*x[E+v]+(x[E+M]<<16|x[E+L]<<8|x[E+N])}}function A(v,M){if(v=v&&v.length,v==null)throw new TypeError("Invalid Buffer");if(v<M+8)throw new RangeError("Out of range")}function I(v){return(9<v?"":"0")+(0|v)}function D(v,M){return(l+(0|v)).substr(-M)}})()}(_l)),_l.exports}var YA=QA();const Su=rs(YA);class Pn extends Error{static name="SignatureVerificationError";constructor(e="Record signature verification failed"){super(e),this.name="SignatureVerificationError"}}class XA extends Error{static name="RecordExpiredError";constructor(e="Record has expired"){super(e),this.name="RecordExpiredError"}}class b4 extends Error{static name="UnsupportedValidityError";constructor(e="The validity type is unsupported"){super(e),this.name="UnsupportedValidityError"}}class ZA extends Error{static name="RecordTooLargeError";constructor(e="The record is too large"){super(e),this.name="RecordTooLargeError"}}class jA extends Error{static name="InvalidValueError";constructor(e="Value must be a valid content path starting with /"){super(e),this.name="InvalidValueError"}}class JA extends Error{static name="InvalidRecordDataError";constructor(e="Invalid record data"){super(e),this.name="InvalidRecordDataError"}}class qf extends Error{static name="InvalidEmbeddedPublicKeyError";constructor(e="Invalid embedded public key"){super(e),this.name="InvalidEmbeddedPublicKeyError"}}var ir;(function(n){(function(r){r.EOL="EOL"})(n.ValidityType||(n.ValidityType={}));let e;(function(r){r[r.EOL=0]="EOL"})(e||(e={})),function(r){r.codec=()=>At(e)}(n.ValidityType||(n.ValidityType={}));let t;n.codec=()=>(t==null&&(t=te((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.value!=null&&(s.uint32(10),s.bytes(r.value)),r.signatureV1!=null&&(s.uint32(18),s.bytes(r.signatureV1)),r.validityType!=null&&(s.uint32(24),n.ValidityType.codec().encode(r.validityType,s)),r.validity!=null&&(s.uint32(34),s.bytes(r.validity)),r.sequence!=null&&(s.uint32(40),s.uint64(r.sequence)),r.ttl!=null&&(s.uint32(48),s.uint64(r.ttl)),r.pubKey!=null&&(s.uint32(58),s.bytes(r.pubKey)),r.signatureV2!=null&&(s.uint32(66),s.bytes(r.signatureV2)),r.data!=null&&(s.uint32(74),s.bytes(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.value=r.bytes();break}case 2:{o.signatureV1=r.bytes();break}case 3:{o.validityType=n.ValidityType.codec().decode(r);break}case 4:{o.validity=r.bytes();break}case 5:{o.sequence=r.uint64();break}case 6:{o.ttl=r.uint64();break}case 7:{o.pubKey=r.bytes();break}case 8:{o.signatureV2=r.bytes();break}case 9:{o.data=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>ee(r,n.codec()),n.decode=(r,s)=>J(r,n.codec(),s)})(ir||(ir={}));const eT=ri("ipns:utils"),v4=V("/ipns/"),tT=0,rT=18;function nT(n){let e;if(n.pubKey!=null)try{e=Tt(n.pubKey)}catch(t){throw eT.error(t),t}if(e!=null)return e}function sT(n){const e=V("ipns-signature:");return We([e,n])}function E4(n){return"signatureV1"in n?ir.encode({value:V(n.value),signatureV1:n.signatureV1,validityType:n.validityType,validity:V(n.validity),sequence:n.sequence,ttl:n.ttl,pubKey:n.pubKey,signatureV2:n.signatureV2,data:n.data}):ir.encode({pubKey:n.pubKey,signatureV2:n.signatureV2,data:n.data})}function ho(n){const e=ir.decode(n);if(e.sequence!=null&&(e.sequence=BigInt(e.sequence)),e.ttl!=null&&(e.ttl=BigInt(e.ttl)),e.signatureV2==null||e.data==null)throw new Pn("Missing data or signatureV2");const t=_4(e.data),r=iT(t.Value),s=K(t.Validity);if(e.value!=null&&e.signatureV1!=null)return oT(e),{value:r,validityType:ir.ValidityType.EOL,validity:s,sequence:t.Sequence,ttl:t.TTL,pubKey:e.pubKey,signatureV1:e.signatureV1,signatureV2:e.signatureV2,data:e.data};if(e.signatureV2!=null)return{value:r,validityType:ir.ValidityType.EOL,validity:s,sequence:t.Sequence,ttl:t.TTL,pubKey:e.pubKey,signatureV2:e.signatureV2,data:e.data};throw new Error("invalid record: does not include signatureV1 or signatureV2")}function S4(n){return We([v4,n.bytes])}function _u(n){const e=je(n.slice(v4.length));if(!xu(e,tT)&&!xu(e,rT))throw new $u("Multihash in IPNS key was not identity or sha2-256");return e}function _4(n){const e=Yr(n);if(e.ValidityType===0)e.ValidityType=ir.ValidityType.EOL;else throw new b4("The validity type is unsupported");return Number.isInteger(e.Sequence)&&(e.Sequence=BigInt(e.Sequence)),Number.isInteger(e.TTL)&&(e.TTL=BigInt(e.TTL)),e}function iT(n){const e=K(n).trim();if(e.startsWith("/"))return e;try{return`/ipfs/${Y.decode(n).toV1().toString()}`}catch{}try{return`/ipfs/${Y.parse(e).toV1().toString()}`}catch{}throw new jA("Value must be a valid content path starting with /")}function oT(n){if(n.data==null)throw new JA("Record data is missing");const e=_4(n.data);if(!pe(e.Value,n.value??new Uint8Array(0)))throw new Pn('Field "value" did not match between protobuf and CBOR');if(!pe(e.Validity,n.validity??new Uint8Array(0)))throw new Pn('Field "validity" did not match between protobuf and CBOR');if(e.ValidityType!==n.validityType)throw new Pn('Field "validityType" did not match between protobuf and CBOR');if(e.Sequence!==n.sequence)throw new Pn('Field "sequence" did not match between protobuf and CBOR');if(e.TTL!==n.ttl)throw new Pn('Field "ttl" did not match between protobuf and CBOR')}function xu(n,e){return n.code===e}const Uo=ri("ipns:validator"),aT=1024*10,cT=async(n,e)=>{const t=ho(e);let r;try{const s=sT(t.data);r=await n.verify(s,t.signatureV2)}catch{r=!1}if(!r)throw Uo.error("record signature verification failed"),new Pn("Record signature verification failed");if(t.validityType===ir.ValidityType.EOL){if(Su.fromString(t.validity).toDate().getTime()<Date.now())throw Uo.error("record has expired"),new XA("record has expired")}else if(t.validityType!=null)throw Uo.error("the validity type is unsupported"),new b4("The validity type is unsupported");Uo("ipns record for %s is valid",t.value)};async function x4(n,e){if(e.byteLength>aT)throw new ZA("The record is too large");const t=_u(n);let r;xu(t,0)&&(r=O3(t));const s=ho(e),i=nT(s)??r;if(i==null)throw new qf("Could not extract public key from IPNS record or routing key");const o=S4(i.toMultihash());if(!pe(o,n))throw new qf("Embedded public key did not match routing key");await cT(i,e)}let lT=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MESSAGE_LENGTH"};async function*Kf(n,e={}){const t=/\r?\n/,r=new TextDecoder("utf8");let s="";for await(let i of n){if(typeof i=="string"&&(i=new TextEncoder().encode(i)),yi(i)&&(i=i.subarray()),s+=r.decode(i,{stream:!0}),s.length>(e?.maxMessageLength??s.length))throw new lT("Incoming message too long");const o=s.split(t);s=o.pop()??"";for(let a=0;a<o.length;a++)yield JSON.parse(o[a])}s+=r.decode(),s!==""&&(yield JSON.parse(s))}class xl extends Error{static name="InvalidRequestError";constructor(e="Invalid request"){super(e),this.name="InvalidRequestError"}}class Kr extends Error{static name="BadResponseError";constructor(e="Bad response"){super(e),this.name="BadResponseError"}}function uT(n){return n[Symbol.asyncIterator]!=null}function hT(n){if(uT(n))return(async()=>{for await(const e of n)return e})();for(const e of n)return e}const Wf=V("/ipns/");function Gf(n){return pe(n.subarray(0,Wf.byteLength),Wf)}class dT{client;constructor(e){this.client=e}async*findProviders(e,t={}){yield*ni(this.client.getProviders(e,t),r=>({id:r.ID,multiaddrs:r.Addrs??[]}))}async provide(){}async cancelReprovide(){}async put(e,t,r){if(!Gf(e))return;const s=_u(e),i=Y.createV1(114,s),o=ho(t);await this.client.putIPNS(i,o,r)}async get(e,t){if(!Gf(e))throw new It("Not found");const r=_u(e),s=Y.createV1(114,r);try{const i=await this.client.getIPNS(s,t);return E4(i)}catch(i){throw i.name==="BadResponseError"?new It("Not found"):i}}}class fT{client;constructor(e){this.client=e}async findPeer(e,t={}){const r=await hT(this.client.getPeers(e,t));if(r!=null)return{id:r.ID,multiaddrs:r.Addrs??[]};throw new It("Not found")}async*getClosestPeers(e,t={}){}}const Ge=ri("delegated-routing-v1-http-api-client"),$o={concurrentRequests:4,timeout:3e4,cacheTTL:5*60*1e3,cacheName:"delegated-routing-v1-cache"};class pT{started;httpQueue;shutDownController;clientUrl;timeout;contentRouting;peerRouting;filterAddrs;filterProtocols;inFlightRequests;cacheName;cache;cacheTTL;constructor(e,t={}){this.started=!1,this.shutDownController=new AbortController,this.shutDownController.signal,this.httpQueue=new Ia({concurrency:t.concurrentRequests??$o.concurrentRequests}),this.inFlightRequests=new Map,this.clientUrl=e instanceof URL?e:new URL(e),this.timeout=t.timeout??$o.timeout,this.filterAddrs=t.filterAddrs,this.filterProtocols=t.filterProtocols,this.contentRouting=new dT(this),this.peerRouting=new fT(this),this.cacheName=t.cacheName??$o.cacheName,this.cacheTTL=t.cacheTTL??$o.cacheTTL}get[As](){return this.contentRouting}get[Ts](){return this.peerRouting}isStarted(){return this.started}async start(){this.started||(this.started=!0,this.cacheTTL>0&&(this.cache=await globalThis.caches?.open(this.cacheName),this.cache!=null&&Ge("cache enabled with ttl %d",this.cacheTTL)))}async stop(){this.httpQueue.clear(),this.shutDownController.abort(),await globalThis.caches?.delete(this.cacheName),this.started=!1}async*getProviders(e,t={}){Ge("getProviders starts: %c",e);const r=AbortSignal.timeout(this.timeout),s=be([this.shutDownController.signal,r,t.signal]),i=ae(),o=ae();this.httpQueue.add(async()=>(i.resolve(),o.promise));try{await i.promise;const a=new URL(`${this.clientUrl}routing/v1/providers/${e.toString()}`);this.#t(a,t.filterAddrs,t.filterProtocols);const c={headers:{Accept:"application/x-ndjson"},signal:s},l=await this.#r(a.toString(),c);if(l==null)throw new Kr("No response received");if(!l.ok)throw l.status===404?new It("No matching records found"):l.status===422?new xl("Request does not conform to schema or semantic constraints"):new Kr(`Unexpected status code: ${l.status}`);if(l.body==null)throw new Kr("Routing response had no body");const u=l.headers.get("Content-Type");if(u==null)throw new Kr("No Content-Type header received");if(u?.startsWith("application/json")){const h=await l.json();for(const d of h.Providers){const f=this.#e(d);f!=null&&(yield f)}}else if(u.includes("application/x-ndjson"))for await(const h of Kf(Hf(l.body))){const d=this.#e(h);d!=null&&(yield d)}else throw new Kr(`Unsupported Content-Type: ${u}`)}catch(a){Ge.error("getProviders errored:",a)}finally{s.clear(),o.resolve(),Ge("getProviders finished: %c",e)}}async*getPeers(e,t={}){Ge("getPeers starts: %c",e);const r=AbortSignal.timeout(this.timeout),s=be([this.shutDownController.signal,r,t.signal]),i=ae(),o=ae();this.httpQueue.add(async()=>(i.resolve(),o.promise));try{await i.promise;const a=new URL(`${this.clientUrl}routing/v1/peers/${e.toCID().toString()}`);this.#t(a,t.filterAddrs,t.filterProtocols);const c={headers:{Accept:"application/x-ndjson"},signal:s},l=await this.#r(a.toString(),c);if(l.status===404)throw new It("No matching records found");if(l.status===422)throw new xl("Request does not conform to schema or semantic constraints");if(l.body==null)throw new Kr("Routing response had no body");if(l.headers.get("Content-Type")==="application/json"){const h=await l.json();for(const d of h.Peers){const f=this.#e(d);f!=null&&(yield f)}}else for await(const h of Kf(Hf(l.body))){const d=this.#e(h);d!=null&&(yield d)}}catch(a){Ge.error("getPeers errored:",a)}finally{s.clear(),o.resolve(),Ge("getPeers finished: %c",e)}}async getIPNS(e,t={}){Ge("getIPNS starts: %s",e);const r=AbortSignal.timeout(this.timeout),s=be([this.shutDownController.signal,r,t.signal]),i=ae(),o=ae();this.httpQueue.add(async()=>(i.resolve(),o.promise));const a=`${this.clientUrl}routing/v1/ipns/${e}`;try{await i.promise;const c={headers:{Accept:"application/vnd.ipfs.ipns-record"},signal:s},l=await this.#r(a,c);if(Ge("getIPNS GET %s %d",a,l.status),l.status===404)throw new It("No matching records found");if(l.status===422)throw new xl("Request does not conform to schema or semantic constraints");if(l.body==null)throw new Kr("GET ipns response had no body");const u=await l.arrayBuffer(),h=new Uint8Array(u,0,u.byteLength);return t.validate!==!1&&await x4(S4(e.multihash),h),ho(h)}catch(c){throw Ge.error("getIPNS GET %s error:",a,c),c}finally{s.clear(),o.resolve(),Ge("getIPNS finished: %s",e)}}async putIPNS(e,t,r={}){Ge("putIPNS starts: %c",e);const s=AbortSignal.timeout(this.timeout),i=be([this.shutDownController.signal,s,r.signal]),o=ae(),a=ae();this.httpQueue.add(async()=>(o.resolve(),a.promise));const c=`${this.clientUrl}routing/v1/ipns/${e}`;try{await o.promise;const l=E4(t),u={method:"PUT",headers:{"Content-Type":"application/vnd.ipfs.ipns-record"},body:l,signal:i},h=await this.#r(c,u);if(Ge("putIPNS PUT %s %d",c,h.status),h.status!==200)throw new Kr("PUT ipns response had status other than 200")}catch(l){throw Ge.error("putIPNS PUT %s error:",c,l.stack),l}finally{i.clear(),a.resolve(),Ge("putIPNS finished: %c",e)}}#e(e){try{const t=[],r=e.Addrs?.map(re)??[];return e.Protocols!=null&&t.push(...e.Protocols),e.Protocol!=null&&(t.push(e.Protocol),delete e.Protocol),{...e,Schema:"peer",ID:Ue(e.ID),Addrs:r,Protocols:t}}catch(t){Ge.error("could not conform record to peer schema",t)}}#t(e,t,r){if(t!=null||this.filterAddrs!=null){const s=t?.join(",")??this.filterAddrs?.join(",")??"";s!==""&&e.searchParams.set("filter-addrs",s)}if(r!=null||this.filterProtocols!=null){const s=r?.join(",")??this.filterProtocols?.join(",")??"";s!==""&&e.searchParams.set("filter-protocols",s)}}async#r(e,t){const r=t.method??"GET",s=`${r}-${e}`;if(r==="GET"){const c=await this.cache?.match(e);if(c!=null){if(parseInt(c.headers.get("x-cache-expires")??"0",10)>Date.now())return Ge("returning cached response for %s",s),c;await this.cache?.delete(e)}}const i=this.inFlightRequests.get(s);if(i!=null){const c=await i;return Ge("deduplicating outgoing request for %s",s),c.clone()}const o=fetch(e,t).then(async c=>{if(this.cache!=null&&c.ok&&r==="GET"){const l=Date.now()+this.cacheTTL,u=new Headers(c.headers);u.set("x-cache-expires",l.toString());const h=new Response(c.clone().body,{status:c.status,statusText:c.statusText,headers:u});await this.cache.put(e,h)}return c}).finally(()=>{this.inFlightRequests.delete(s)});return this.inFlightRequests.set(s,o),await o}}function gT(n,e={}){return new pT(new URL(n),e)}function mT(){return{filterProtocols:["unknown","transport-bitswap","transport-ipfs-gateway-http"],filterAddrs:["https","webtransport","webrtc","webrtc-direct","wss","tls"]}}const Qf="[a-fA-F\\d:]",Jr=n=>n&&n.includeBoundaries?`(?:(?<=\\s|^)(?=${Qf})|(?<=${Qf})(?=\\s|$))`:"",er="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",He="[a-fA-F\\d]{1,4}",_c=`
(?:
(?:${He}:){7}(?:${He}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${He}:){6}(?:${er}|:${He}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${He}:){5}(?::${er}|(?::${He}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${He}:){4}(?:(?::${He}){0,1}:${er}|(?::${He}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${He}:){3}(?:(?::${He}){0,2}:${er}|(?::${He}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${He}:){2}(?:(?::${He}){0,3}:${er}|(?::${He}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${He}:){1}(?:(?::${He}){0,4}:${er}|(?::${He}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${He}){0,5}:${er}|(?::${He}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),yT=new RegExp(`(?:^${er}$)|(?:^${_c}$)`),wT=new RegExp(`^${er}$`),bT=new RegExp(`^${_c}$`),xc=n=>n&&n.exact?yT:new RegExp(`(?:${Jr(n)}${er}${Jr(n)})|(?:${Jr(n)}${_c}${Jr(n)})`,"g");xc.v4=n=>n&&n.exact?wT:new RegExp(`${Jr(n)}${er}${Jr(n)}`,"g");xc.v6=n=>n&&n.exact?bT:new RegExp(`${Jr(n)}${_c}${Jr(n)}`,"g");function vT(n){const e=(...t)=>n(...t);return Object.defineProperty(e,"name",{value:`functionTimeout(${n.name||"<anonymous>"})`,configurable:!0}),e}const{toString:ET}=Object.prototype;function ST(n){return ET.call(n)==="[object RegExp]"}const Yf={global:"g",ignoreCase:"i",multiline:"m",dotAll:"s",sticky:"y",unicode:"u"};function _T(n,e={}){if(!ST(n))throw new TypeError("Expected a RegExp instance");const t=Object.keys(Yf).map(s=>(typeof e[s]=="boolean"?e[s]:n[s])?Yf[s]:"").join(""),r=new RegExp(e.source||n.source,t);return r.lastIndex=typeof e.lastIndex=="number"?e.lastIndex:n.lastIndex,r}function k4(n,e,{timeout:t}={}){try{return vT(()=>_T(n).test(e),{timeout:t})()}catch(r){throw r}}const xT=15,kT=45,I4={timeout:400};function Xf(n){return n.length>kT?!1:k4(xc.v6({exact:!0}),n,I4)}function IT(n){return n.length>xT?!1:k4(xc.v4({exact:!0}),n,I4)}const Zf={http:"80",https:"443",ws:"80",wss:"443"},AT=["http","https","ws","wss"];function TT(n,e){e=e??{};const t=e.defaultDnsType??"dns4",{scheme:r,hostname:s,port:i}=PT(n),a="/"+[CT(s,t),DT(i,r),RT(r)].filter(c=>!!c).reduce((c,l)=>c.concat(l),[]).join("/");return re(a)}function PT(n){const[e]=n.split(":");AT.includes(e)||(n="http"+n.substring(e.length));let{protocol:t,hostname:r,port:s}=new URL(n);if(s==null||s===""){const i=MT(e);i!=null&&(s=i),i==null&&t==="http:"&&(s="80")}return{scheme:e,hostname:r,port:s}}function CT(n,e){if(!(n==null||n==="")){if(IT(n))return["ip4",n];if(Xf(n))return["ip6",n];if(n[0]==="["){const t=n.substring(1,n.length-1);if(Xf(t))return["ip6",t]}return[e,n]}}function DT(n,e){if(!(n==null||n===""))return e==="udp"?["udp",n]:["tcp",n]}function RT(n){if(n.match(/^tcp$|^udp$/)==null)return[n]}function MT(n){if(!(n==null||n===""||Zf[n]==null))return Zf[n]}const LT=["https://trustless-gateway.link","https://4everland.io"],NT=2336;function BT(n){return n=n.toString(),{id:ro(Y.createV1(NT,$n.digest(V(n)))),multiaddrs:[TT(n)]}}class OT{gateways;constructor(e={}){this.gateways=(e.gateways??LT).map(t=>BT(t))}async*findProviders(e,t){yield*this.gateways.toSorted(()=>Math.random()>.5?1:-1).map(r=>({...r,protocols:["transport-ipfs-gateway-http"]}))}}function FT(n={}){return new OT(n)}class UT{libp2p;constructor(e){this.libp2p=e}async provide(e,t){await this.libp2p.contentRouting.provide(e,t)}async cancelReprovide(e,t){await this.libp2p.contentRouting.cancelReprovide(e,t)}async*findProviders(e,t){yield*this.libp2p.contentRouting.findProviders(e,t)}async put(e,t,r){await this.libp2p.contentRouting.put(e,t,r)}async get(e,t){return this.libp2p.contentRouting.get(e,t)}async findPeer(e,t){return this.libp2p.peerRouting.findPeer(e,t)}async*getClosestPeers(e,t){yield*this.libp2p.peerRouting.getClosestPeers(e,t)}}function $T(n){return new UT(n)}class VT extends f4{data;constructor(){super(),this.data=new Map}put(e,t){return this.data.set(xt.encode(e.multihash.bytes),t),e}get(e){const t=this.data.get(xt.encode(e.multihash.bytes));if(t==null)throw new Ws;return t}has(e){return this.data.has(xt.encode(e.multihash.bytes))}async delete(e){this.data.delete(xt.encode(e.multihash.bytes))}async*getAll(){for(const[e,t]of this.data.entries())yield{cid:Y.createV1(ic,je(xt.decode(e))),block:t}}}ri("blockstore:core:tiered");const HT="SHARDING";new Te(HT);ri("datastore:core:tiered");class zT extends RA{libp2p;constructor(e){super({...e,components:{libp2p:e.libp2p}}),this.libp2p=e.libp2p}async start(){await super.start(),await this.libp2p.start()}async stop(){await super.stop(),await this.libp2p.stop()}}function qT(n,e,t){let r,s;function i(){const a={signal:s.signal};if(t?.timeout!=null){const c=be([s.signal,AbortSignal.timeout(t.timeout)]);a.signal=c}Promise.resolve().then(async()=>{await n(a)}).catch(()=>{}).finally(()=>{s.signal.aborted||(r=setTimeout(i,e))})}let o=!1;return{setInterval:a=>{e=a,r!=null&&(clearTimeout(r),r=setTimeout(i,e))},setTimeout:a=>{t==null&&(t={}),t.timeout=a},start:()=>{o||(o=!0,s=new AbortController,s.signal,t?.runImmediately===!0?queueMicrotask(()=>{i()}):r=setTimeout(i,e))},stop:()=>{clearTimeout(r),s?.abort(),o=!1}}}const KT="libp2p",WT="autonat",GT="1.0.0",QT=3e4,YT=2,XT=20,ZT=80,jT=8192;var Re;(function(n){(function(s){s.DIAL="DIAL",s.DIAL_RESPONSE="DIAL_RESPONSE"})(n.MessageType||(n.MessageType={}));let e;(function(s){s[s.DIAL=0]="DIAL",s[s.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(e||(e={})),function(s){s.codec=()=>At(e)}(n.MessageType||(n.MessageType={})),function(s){s.OK="OK",s.E_DIAL_ERROR="E_DIAL_ERROR",s.E_DIAL_REFUSED="E_DIAL_REFUSED",s.E_BAD_REQUEST="E_BAD_REQUEST",s.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(n.ResponseStatus||(n.ResponseStatus={}));let t;(function(s){s[s.OK=0]="OK",s[s.E_DIAL_ERROR=100]="E_DIAL_ERROR",s[s.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",s[s.E_BAD_REQUEST=200]="E_BAD_REQUEST",s[s.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(t||(t={})),function(s){s.codec=()=>At(t)}(n.ResponseStatus||(n.ResponseStatus={})),function(s){let i;s.codec=()=>(i==null&&(i=te((o,a,c={})=>{if(c.lengthDelimited!==!1&&a.fork(),o.id!=null&&(a.uint32(10),a.bytes(o.id)),o.addrs!=null)for(const l of o.addrs)a.uint32(18),a.bytes(l);c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={addrs:[]},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const h=o.uint32();switch(h>>>3){case 1:{l.id=o.bytes();break}case 2:{if(c.limits?.addrs!=null&&l.addrs.length===c.limits.addrs)throw new _e('Decode error - map field "addrs" had too many elements');l.addrs.push(o.bytes());break}default:{o.skipType(h&7);break}}}return l})),i),s.encode=o=>ee(o,s.codec()),s.decode=(o,a)=>J(o,s.codec(),a)}(n.PeerInfo||(n.PeerInfo={})),function(s){let i;s.codec=()=>(i==null&&(i=te((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.peer!=null&&(a.uint32(10),n.PeerInfo.codec().encode(o.peer,a)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const h=o.uint32();switch(h>>>3){case 1:{l.peer=n.PeerInfo.codec().decode(o,o.uint32(),{limits:c.limits?.peer});break}default:{o.skipType(h&7);break}}}return l})),i),s.encode=o=>ee(o,s.codec()),s.decode=(o,a)=>J(o,s.codec(),a)}(n.Dial||(n.Dial={})),function(s){let i;s.codec=()=>(i==null&&(i=te((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.status!=null&&(a.uint32(8),n.ResponseStatus.codec().encode(o.status,a)),o.statusText!=null&&(a.uint32(18),a.string(o.statusText)),o.addr!=null&&(a.uint32(26),a.bytes(o.addr)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const h=o.uint32();switch(h>>>3){case 1:{l.status=n.ResponseStatus.codec().decode(o);break}case 2:{l.statusText=o.string();break}case 3:{l.addr=o.bytes();break}default:{o.skipType(h&7);break}}}return l})),i),s.encode=o=>ee(o,s.codec()),s.decode=(o,a)=>J(o,s.codec(),a)}(n.DialResponse||(n.DialResponse={}));let r;n.codec=()=>(r==null&&(r=te((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.type!=null&&(i.uint32(8),n.MessageType.codec().encode(s.type,i)),s.dial!=null&&(i.uint32(18),n.Dial.codec().encode(s.dial,i)),s.dialResponse!=null&&(i.uint32(26),n.DialResponse.codec().encode(s.dialResponse,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.type=n.MessageType.codec().decode(s);break}case 2:{a.dial=n.Dial.codec().decode(s,s.uint32(),{limits:o.limits?.dial});break}case 3:{a.dialResponse=n.DialResponse.codec().decode(s,s.uint32(),{limits:o.limits?.dialResponse});break}default:{s.skipType(l&7);break}}}return a})),r),n.encode=s=>ee(s,n.codec()),n.decode=(s,i)=>J(s,n.codec(),i)})(Re||(Re={}));const JT=4,eP=8;class tP{components;protocol;timeout;maxInboundStreams;maxOutboundStreams;maxMessageSize;started;log;topologyId;dialResults;findPeers;addressFilter;connectionThreshold;constructor(e,t){this.components=e,this.log=e.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${t.protocolPrefix??KT}/${WT}/${GT}`,this.timeout=t.timeout??QT,this.maxInboundStreams=t.maxInboundStreams??YT,this.maxOutboundStreams=t.maxOutboundStreams??XT,this.connectionThreshold=t.connectionThreshold??ZT,this.maxMessageSize=t.maxMessageSize??jT,this.dialResults=new Map,this.findPeers=qT(this.findRandomPeers.bind(this),6e4),this.addressFilter=Wn(1024)}[Symbol.toStringTag]="@libp2p/autonat";[rt]=["@libp2p/autonat"];get[cn](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,e=>{this.handleIncomingAutonatStream(e).catch(t=>{this.log.error("error handling incoming autonat stream - %e",t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(e,t)=>{this.verifyExternalAddresses(t).catch(r=>{this.log.error("could not verify addresses - %e",r)})}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.topologyId!=null&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every(e=>e.expires>Date.now()?!0:e.verified)}async findRandomPeers(e){if(this.allAddressesAreVerified())return;const t=be([AbortSignal.timeout(1e4),e?.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(const r of this.components.randomWalk.walk({signal:t})){if(!await this.components.connectionManager.isDialable(r.multiaddrs)){this.log.trace("random peer %p was not dialable %s",r.id,r.multiaddrs.map(s=>s.toString()).join(", "));continue}try{this.log.trace("dial random peer %p",r.id),await this.components.connectionManager.openConnection(r.multiaddrs,{signal:t})}catch{}if(this.allAddressesAreVerified()){this.log("stopping random walk, all addresses are verified");return}if(!this.hasConnectionCapacity()){this.log("stopping random walk, too close to max connections");return}}}catch{}}async handleIncomingAutonatStream(e){const t=AbortSignal.timeout(this.timeout),r=pt(e.stream,{maxDataLength:this.maxMessageSize}).pb(Re);try{const s=await r.read({signal:t}),i=await this.handleAutonatMessage(s,e.connection,{signal:t});await r.write(i,{signal:t}),await r.unwrap().unwrap().close({signal:t})}catch(s){this.log.error("error handling incoming autonat stream - %e",s),e.stream.abort(s)}}async handleAutonatMessage(e,t,r){const s=this.components.addressManager.getAddresses().map(h=>h.toOptions().host),i=e.dial;if(i==null)return this.log.error("dial was missing from message"),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let o;const a=i.peer;if(a?.id==null)return this.log.error("PeerId missing from message"),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{const h=je(a.id);o=Ft(h)}catch(h){return this.log.error("invalid PeerId - %e",h),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",o),!t.remotePeer.equals(o))return this.log("target peer %p did not equal sending peer %p",o,t.remotePeer),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};const c=a.addrs.map(h=>re(h)).filter(h=>{const d=h.toOptions();return Qn(h)?!1:d.host!==t.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",h,t.remoteAddr),!1):s.includes(d.host)?!1:this.components.transportManager.dialTransportForMultiaddr(h)==null?(this.log.trace("not dialing %a - transport unsupported",h),!1):!0}).map(h=>(h.getPeerId()==null&&(h=h.encapsulate(`/p2p/${o.toString()}`)),h));if(c.length===0)return this.log("refused to dial all multiaddrs for %p from message",o),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",c.map(h=>h.toString()).join(", "),o);let l="",u=c[0];for await(const h of c){let d;u=h;try{if(d=await this.components.connectionManager.openConnection(h,r),!d.remoteAddr.equals(h))throw this.log.error("tried to dial %a but dialed %a",h,d.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",o,h),{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.OK,addr:d.remoteAddr.decapsulateCode(ne("p2p").code).bytes}}}catch(f){this.log.error("could not dial %p - %e",o,f),l=f.message}finally{d!=null&&await d.close()}}return{type:Re.MessageType.DIAL_RESPONSE,dialResponse:{status:Re.ResponseStatus.E_DIAL_ERROR,statusText:l,addr:u.bytes}}}getFirstUnverifiedMultiaddr(e,t){const r=this.components.addressManager.getAddressesWithMetadata().sort((s,i)=>s.type==="observed"&&i.type!=="observed"?1:i.type==="observed"&&s.type!=="observed"?-1:0).filter(s=>!(!(s.expires<Date.now())||s.multiaddr.toOptions().family===6&&(!t||!Yp(s.multiaddr))||Qn(s.multiaddr)));for(const s of r){const i=s.multiaddr.toString();let o=this.dialResults.get(i);if(o!=null){if(o.networkSegments.includes(e)){this.log.trace("%a already has a network segment result from %s",o.multiaddr,e);continue}if(o.queue.size>10){this.log.trace("%a already has enough peers queued",o.multiaddr);continue}}if(o==null){const a=s.expires<Date.now();if(a&&this.addressFilter.remove?.(i),this.addressFilter.has(i))continue;this.addressFilter.add(i),this.log.trace("creating dial result %s %s",a?"to revalidate":"for",i),o={multiaddr:s.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:ub(),queue:new fn({concurrency:3,maxSize:50}),type:s.type,lastVerified:s.lastVerified},this.dialResults.set(i,o)}return o}}removeOutdatedMultiaddrResults(){const e=new Set(this.components.addressManager.getAddressesWithMetadata().filter(({expires:t})=>t<Date.now()).map(({multiaddr:t})=>t.toString()));for(const t of this.dialResults.keys())e.has(t)||(this.log.trace("remove results for %a",t),this.dialResults.delete(t))}async verifyExternalAddresses(e){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();const r=(await this.components.peerStore.get(e.remotePeer)).addresses.some(({multiaddr:o})=>o.toOptions().family===6),s=this.getNetworkSegment(e.remoteAddr),i=this.getFirstUnverifiedMultiaddr(s,r);if(i==null){this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",e.remotePeer);return}if(!this.hasConnectionCapacity()){i.lastVerified!=null?(this.log("automatically re-verifying %a because we are too close to the connection limit",i.multiaddr),this.confirmAddress(i)):this.log("skipping verifying %a because we are too close to the connection limit",i.multiaddr);return}i.queue.add(async o=>{await this.askPeerToVerify(e,s,o)},{peerId:e.remotePeer,multiaddr:i.multiaddr}).catch(o=>{i?.result==null&&this.log.error("error from %p verifying address %a - %e",e.remotePeer,i?.multiaddr,o)})}async askPeerToVerify(e,t,r){let s=this.dialResults.get(r.multiaddr.toString());if(s==null){this.log("%a was verified while %p was queued",r.multiaddr,e.remotePeer);return}const i=AbortSignal.timeout(this.timeout);this.log.trace("asking %p to verify multiaddr %s",e.remotePeer,r.multiaddr);const o=await e.newStream(this.protocol,{signal:i});try{const a=pt(o).pb(Re),[,c]=await Promise.all([a.write({type:Re.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[r.multiaddr.bytes]}}},{signal:i}),a.read({signal:i})]);if(c.type!==Re.MessageType.DIAL_RESPONSE||c.dialResponse==null){this.log("invalid autonat response from %p - %j",e.remotePeer,c);return}const l=c.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",e.remotePeer,r.multiaddr,l),l!==Re.ResponseStatus.OK&&l!==Re.ResponseStatus.E_DIAL_ERROR)return;if(s=this.dialResults.get(r.multiaddr.toString()),s==null){this.log.trace("peer reported %a as %s but there is no result object",r.multiaddr,c.dialResponse.status);return}if(s.networkSegments.includes(t)){this.log.trace("%a results included network segment %s",r.multiaddr,t);return}if(s.result!=null){this.log.trace("already resolved result for %a, ignoring response from",r.multiaddr,e.remotePeer);return}if(s.verifyingPeers.has(e.remotePeer)){this.log.trace("peer %p has already verified %a, ignoring response",e.remotePeer,r.multiaddr);return}if(s.verifyingPeers.add(e.remotePeer),s.networkSegments.push(t),l===Re.ResponseStatus.OK){if(s.success++,s.type!=="observed"){this.confirmAddress(s);return}}else l===Re.ResponseStatus.E_DIAL_ERROR&&s.failure++;this.log("%a success %d failure %d",s.multiaddr,s.success,s.failure),s.success===JT&&this.confirmAddress(s),s.failure===eP&&this.unconfirmAddress(s)}finally{try{await o.close({signal:i})}catch(a){o.abort(a)}}}hasConnectionCapacity(){const t=this.components.connectionManager.getConnections().length,r=this.components.connectionManager.getMaxConnections();return t/r*100<this.connectionThreshold}confirmAddress(e){this.log("%s address %a is externally dialable",e.type,e.multiaddr),this.components.addressManager.confirmObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!0,e.queue.abort()}unconfirmAddress(e){this.log("%s address %a is not externally dialable",e.type,e.multiaddr),this.components.addressManager.removeObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!1,e.queue.abort()}getNetworkSegment(e){const t=e.toOptions();return t.family===4?t.host.split(".")[0].padStart(3,"0"):t.host.split(":")[0].padStart(4,"0")}}function rP(n={}){return e=>new tP(e,n)}const nP=z("dns4"),sP=z("dns6"),iP=z("dnsaddr"),Zn=Ve(z("dns"),iP,nP,sP),kc=Ve(z("ip4"),z("ip6")),Gs=Ve(X(kc,z("tcp")),X(Zn,z("tcp"))),Ic=X(kc,z("udp")),oP=X(Ic,z("utp")),aP=X(Ic,z("quic")),cP=X(Ic,z("quic-v1")),ku=Ve(X(Gs,z("ws")),X(Zn,z("ws"))),Va=Ve(X(ku,z("p2p")),ku),Iu=Ve(X(Gs,z("wss")),X(Zn,z("wss")),X(Gs,z("tls"),z("ws")),X(Zn,z("tls"),z("ws"))),Ha=Ve(X(Iu,z("p2p")),Iu),Au=Ve(X(Gs,z("http")),X(kc,z("http")),X(Zn,z("http"))),Tu=Ve(X(Gs,z("https")),X(kc,z("https")),X(Zn,z("https"))),jf=X(Ic,z("webrtc-direct"),z("certhash")),A4=Ve(X(jf,z("p2p")),jf),Jf=X(cP,z("webtransport"),z("certhash"),z("certhash")),T4=Ve(X(Jf,z("p2p")),Jf),P4=Ve(X(Va,z("p2p-webrtc-star"),z("p2p")),X(Ha,z("p2p-webrtc-star"),z("p2p")),X(Va,z("p2p-webrtc-star")),X(Ha,z("p2p-webrtc-star")));Ve(X(Va,z("p2p-websocket-star"),z("p2p")),X(Ha,z("p2p-websocket-star"),z("p2p")),X(Va,z("p2p-websocket-star")),X(Ha,z("p2p-websocket-star")));const C4=Ve(X(Au,z("p2p-webrtc-direct"),z("p2p")),X(Tu,z("p2p-webrtc-direct"),z("p2p")),X(Au,z("p2p-webrtc-direct")),X(Tu,z("p2p-webrtc-direct"))),jn=Ve(ku,Iu,Au,Tu,P4,C4,Gs,oP,aP,Zn,A4,T4);Ve(X(jn,z("p2p-stardust"),z("p2p")),X(jn,z("p2p-stardust")));const en=Ve(X(jn,z("p2p")),P4,C4,A4,T4,z("p2p")),e0=Ve(X(en,z("p2p-circuit"),en),X(en,z("p2p-circuit")),X(z("p2p-circuit"),en),X(jn,z("p2p-circuit")),X(z("p2p-circuit"),jn),z("p2p-circuit")),D4=()=>Ve(X(e0,D4),e0),Cn=D4(),lP=Ve(X(Cn,en,Cn),X(en,Cn),X(Cn,en),Cn,en);Ve(X(Cn,z("webrtc"),z("p2p")),X(Cn,z("webrtc")),X(jn,z("webrtc"),z("p2p")),X(jn,z("webrtc")),z("webrtc"));function R4(n){function e(t){let r;try{r=re(t)}catch{return!1}const s=n(r.protoNames());return s===null?!1:s===!0||s===!1?s:s.length===0}return e}function X(...n){function e(t){if(t.length<n.length)return null;let r=t;return n.some(s=>(r=typeof s=="function"?s().partialMatch(t):s.partialMatch(t),Array.isArray(r)&&(t=r),r===null)),r}return{toString:function(){return"{ "+n.join(" ")+" }"},input:n,matches:R4(e),partialMatch:e}}function Ve(...n){function e(r){let s=null;return n.some(i=>{const o=typeof i=="function"?i().partialMatch(r):i.partialMatch(r);return o!=null?(s=o,!0):!1}),s}return{toString:function(){return"{ "+n.join(" ")+" }"},input:n,matches:R4(e),partialMatch:e}}function z(n){const e=n;function t(s){let i;try{i=re(s)}catch{return!1}const o=i.protoNames();return o.length===1&&o[0]===e}function r(s){return s.length===0?null:s[0]===e?s.slice(1):null}return{toString:function(){return e},matches:t,partialMatch:r}}const uP="bootstrap",hP=50,dP=1e3;class fP extends Ke{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(e,t={list:[]}){if(t.list==null||t.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super(),this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=t.timeout??dP,this.list=[];for(const r of t.list){if(!lP.matches(r)){this.log.error("Invalid multiaddr");continue}const s=re(r),i=s.getPeerId();if(i==null){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const o={id:Ue(i),multiaddrs:[s]};this.list.push(o)}this._init=t}[Qo]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[rt]=["@libp2p/peer-discovery"];isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error(e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??uP]:{value:this._init.tagValue??hP,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(t=>{this.log.error("could not dial bootstrap peer %p",e.id,t)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}function pP(n){return e=>new fP(e,n)}const fo=1e3,jh=60*fo,Ac=60*jh,gP=36*Ac,mP="/ipfs/kad/1.0.0",yP=48*Ac,wP=24*Ac,bP=10,vP=16384,EP=Ac,M4=20,Jh=3,SP=5*jh,_P=fo,xP=5*fo,kP=5*jh,IP=30*fo,AP=180*fo,t0=`${Wa}-kad-dht`;var za;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.key!=null&&t.key.byteLength>0&&(r.uint32(10),r.bytes(t.key)),t.value!=null&&t.value.byteLength>0&&(r.uint32(18),r.bytes(t.value)),t.timeReceived!=null&&t.timeReceived!==""&&(r.uint32(42),r.string(t.timeReceived)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={key:oe(0),value:oe(0),timeReceived:""},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.key=t.bytes();break}case 2:{i.value=t.bytes();break}case 5:{i.timeReceived=t.string();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(za||(za={}));function TP(n){const e=n.getUTCFullYear(),t=String(n.getUTCMonth()+1).padStart(2,"0"),r=String(n.getUTCDate()).padStart(2,"0"),s=String(n.getUTCHours()).padStart(2,"0"),i=String(n.getUTCMinutes()).padStart(2,"0"),o=String(n.getUTCSeconds()).padStart(2,"0"),a=n.getUTCMilliseconds(),c=String(a*1e3*1e3).padStart(9,"0");return`${e}-${t}-${r}T${s}:${i}:${o}.${c}Z`}function PP(n){const e=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),t=String(n).trim().match(e);if(t==null)throw new Error("Invalid format");const r=parseInt(t[1],10),s=parseInt(t[2],10)-1,i=parseInt(t[3],10),o=parseInt(t[4],10),a=parseInt(t[5],10),c=parseInt(t[6],10),l=parseInt(t[7].slice(0,-6),10);return new Date(Date.UTC(r,s,i,o,a,c,l))}class Kt{key;value;timeReceived;constructor(e,t,r){if(!(e instanceof Uint8Array))throw new Error("key must be a Uint8Array");if(!(t instanceof Uint8Array))throw new Error("value must be a Uint8Array");this.key=e,this.value=t,this.timeReceived=r}serialize(){return za.encode(this.prepareSerialize())}prepareSerialize(){return{key:this.key,value:this.value,timeReceived:TP(this.timeReceived)}}static deserialize(e){const t=za.decode(e);return new Kt(t.key,t.value,new Date(t.timeReceived))}static fromDeserialized(e){const t=PP(e.timeReceived);if(e.key==null)throw new Error("key missing from deserialized object");if(e.value==null)throw new Error("value missing from deserialized object");return new Kt(e.key,e.value,t)}}class qa extends Error{constructor(e="Query error"){super(e),this.name="QueryError"}}class CP extends Error{constructor(e="Query aborted"){super(e),this.name="QueryAbortedError"}}class DP extends Error{constructor(e="Invalid record"){super(e),this.name="InvalidRecordError"}}class RP extends Error{constructor(e="No selector function configured for prefix"){super(e),this.name="MissingSelectorError"}}var r0;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.key!=null&&(r.uint32(10),r.bytes(t.key)),t.value!=null&&(r.uint32(18),r.bytes(t.value)),t.author!=null&&(r.uint32(26),r.bytes(t.author)),t.signature!=null&&(r.uint32(34),r.bytes(t.signature)),t.timeReceived!=null&&(r.uint32(42),r.string(t.timeReceived)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.key=t.bytes();break}case 2:{i.value=t.bytes();break}case 3:{i.author=t.bytes();break}case 4:{i.signature=t.bytes();break}case 5:{i.timeReceived=t.string();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(r0||(r0={}));var ke;(function(n){n.PUT_VALUE="PUT_VALUE",n.GET_VALUE="GET_VALUE",n.ADD_PROVIDER="ADD_PROVIDER",n.GET_PROVIDERS="GET_PROVIDERS",n.FIND_NODE="FIND_NODE",n.PING="PING"})(ke||(ke={}));var Ka;(function(n){n[n.PUT_VALUE=0]="PUT_VALUE",n[n.GET_VALUE=1]="GET_VALUE",n[n.ADD_PROVIDER=2]="ADD_PROVIDER",n[n.GET_PROVIDERS=3]="GET_PROVIDERS",n[n.FIND_NODE=4]="FIND_NODE",n[n.PING=5]="PING"})(Ka||(Ka={}));(function(n){n.codec=()=>At(Ka)})(ke||(ke={}));var Qs;(function(n){n.NOT_CONNECTED="NOT_CONNECTED",n.CONNECTED="CONNECTED",n.CAN_CONNECT="CAN_CONNECT",n.CANNOT_CONNECT="CANNOT_CONNECT"})(Qs||(Qs={}));var Pu;(function(n){n[n.NOT_CONNECTED=0]="NOT_CONNECTED",n[n.CONNECTED=1]="CONNECTED",n[n.CAN_CONNECT=2]="CAN_CONNECT",n[n.CANNOT_CONNECT=3]="CANNOT_CONNECT"})(Pu||(Pu={}));(function(n){n.codec=()=>At(Pu)})(Qs||(Qs={}));var Es;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.id!=null&&t.id.byteLength>0&&(r.uint32(10),r.bytes(t.id)),t.multiaddrs!=null)for(const i of t.multiaddrs)r.uint32(18),r.bytes(i);t.connection!=null&&(r.uint32(24),Qs.codec().encode(t.connection,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={id:oe(0),multiaddrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.multiaddrs!=null&&i.multiaddrs.length===s.limits.multiaddrs)throw new _e('Decode error - map field "multiaddrs" had too many elements');i.multiaddrs.push(t.bytes());break}case 3:{i.connection=Qs.codec().decode(t);break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Es||(Es={}));var Fn;(function(n){let e;n.codec=()=>(e==null&&(e=te((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.type!=null&&Ka[t.type]!==0&&(r.uint32(8),ke.codec().encode(t.type,r)),t.clusterLevel!=null&&(r.uint32(80),r.int32(t.clusterLevel)),t.key!=null&&(r.uint32(18),r.bytes(t.key)),t.record!=null&&(r.uint32(26),r.bytes(t.record)),t.closer!=null)for(const i of t.closer)r.uint32(66),Es.codec().encode(i,r);if(t.providers!=null)for(const i of t.providers)r.uint32(74),Es.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={type:ke.PUT_VALUE,closer:[],providers:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.type=ke.codec().decode(t);break}case 10:{i.clusterLevel=t.int32();break}case 2:{i.key=t.bytes();break}case 3:{i.record=t.bytes();break}case 8:{if(s.limits?.closer!=null&&i.closer.length===s.limits.closer)throw new _e('Decode error - map field "closer" had too many elements');i.closer.push(Es.codec().decode(t,t.uint32(),{limits:s.limits?.closer$}));break}case 9:{if(s.limits?.providers!=null&&i.providers.length===s.limits.providers)throw new _e('Decode error - map field "providers" had too many elements');i.providers.push(Es.codec().decode(t,t.uint32(),{limits:s.limits?.providers$}));break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>ee(t,n.codec()),n.decode=(t,r)=>J(t,n.codec(),r)})(Fn||(Fn={}));function n0(n,e={}){const t={...n,name:"SEND_QUERY",type:0,messageName:n.type,messageType:n.type};return e.onProgress?.(new CustomEvent("kad-dht:query:send-query",{detail:t})),t}function Cu(n,e={}){const t={...n,name:"PEER_RESPONSE",type:1,messageName:n.messageType,closer:n.closer??[],providers:n.providers??[]};return e.onProgress?.(new CustomEvent("kad-dht:query:peer-response",{detail:t})),t}function kl(n,e={}){const t={...n,name:"FINAL_PEER",type:2};return e.onProgress?.(new CustomEvent("kad-dht:query:final-peer",{detail:t})),t}function yn(n,e={}){const t={...n,name:"QUERY_ERROR",type:3};return e.onProgress?.(new CustomEvent("kad-dht:query:query-error",{detail:t})),t}function s0(n,e={}){const t={...n,name:"PROVIDER",type:4};return e.onProgress?.(new CustomEvent("kad-dht:query:provider",{detail:t})),t}function Du(n,e={}){const t={...n,name:"VALUE",type:5};return e.onProgress?.(new CustomEvent("kad-dht:query:value",{detail:t})),t}function i0(n,e={}){const t={...n,name:"DIAL_PEER",type:7};return e.onProgress?.(new CustomEvent("kad-dht:query:dial-peer",{detail:t})),t}function MP(n,e,t){if(t.length===0)throw new B("No records given");const s=K(e).split("/");if(s.length<3)throw new B("Record key does not have a selector function");const i=n[s[1].toString()];if(i==null)throw new RP(`No selector function configured for key type "${s[1]}"`);return t.length===1?0:i(e,t)}function LP(n,e){return 0}const NP={pk:LP};async function ed(n,e){const t=e.key,s=K(t).split("/");if(s.length<3)return;const i=n[s[1].toString()];if(i==null)throw new B(`No validator available for key type "${s[1]}"`);await i(t,e.value)}const BP=async(n,e)=>{if(!(n instanceof Uint8Array))throw new B('"key" must be a Uint8Array');if(n.byteLength<5)throw new B("Invalid public key record");if(K(n.subarray(0,4))!=="/pk/")throw new B("key was not prefixed with /pk/");const r=Tt(e),s=n.slice(4);if(!pe(s,r.toMultihash().bytes))throw new B("public key does not match passed in key")},OP={pk:BP},FP=V("/pk/");function UP(n){return{...n,multiaddrs:n.multiaddrs.filter(e=>{const[[t,r]]=e.stringTuples();if(t===53||t===54||t===55)return r!=="localhost";if(t!==4&&t!==6||r==null)return!1;const s=vn(r);return s==null?!0:!s})}}async function Zi(n){return(await Nt.digest(n)).digest}async function or(n){return Zi(n.toMultihash().bytes)}function Ci(n,e){return new Te(`${n}/${K(e,"base32")}`,!1)}function $P(n){return We([FP,n.toMultihash().bytes])}function VP(n){return K(n.subarray(0,4))==="/pk/"}function HP(n){const e=je(n.subarray(4));return Ft(e)}function o0(n,e){const t=new Date;return new Kt(n,e,t).serialize()}const zP=290,qP=54,KP=55,WP=56,GP=4,QP=41;function YP(n){const e=n.stringTuples();for(const t of e)if(t[0]===zP)return!1;if(e[0][0]===qP||e[0][0]===KP||e[0][0]===WP)return!0;if(e[0][0]===GP||e[0][0]===QP){const t=vn(`${e[0][1]}`);return t==null||!t}return!1}function L4(n){const e=n.toString().split("/"),t=e.pop(),r=e.pop();if(t==null||r==null)throw new Error(`incorrectly formatted provider entry key in datastore: ${n.toString()}`);return{cid:Y.createV1(ic,je(V(r,"base32"))),peerId:Ue(t)}}function Il(n,e,t){const r=typeof e=="string"?e:K(e.multihash.bytes,"base32"),s=[n,r];return t!=null&&s.push(t.toString()),new Te(s.join("/"))}function N4(n){return new Date(ar(n))}function fs(n,e,t){return async function*(...r){const s=e.queryTime?.timer(t),i=e.errorTime?.timer(t);let o=!1;try{e.queries?.increment({[t]:!0}),yield*n(...r)}catch(a){throw o=!0,i?.(),e.errors?.increment({[t]:!0}),a}finally{e.queries?.decrement({[t]:!0}),o||s?.()}}}function B4(n,e,t){return async function(...r){const s=e?.queryTime?.timer(t),i=e?.errorTime?.timer(t);let o=!1;try{return e.queries?.increment({[t]:!0}),await n(...r)}catch(a){throw o=!0,i?.(),e.errors?.increment({[t]:!0}),a}finally{e.queries?.decrement({[t]:!0}),o||s?.()}}}class XP{log;components;validators;selectors;peerRouting;queryManager;network;datastorePrefix;constructor(e,t){const{validators:r,selectors:s,peerRouting:i,queryManager:o,network:a,logPrefix:c}=t;this.components=e,this.log=e.logger.forComponent(`${c}:content-fetching`),this.datastorePrefix=`${t.datastorePrefix}/record`,this.validators=r,this.selectors=s,this.peerRouting=i,this.queryManager=o,this.network=a,this.get=e.metrics?.traceFunction("libp2p.kadDHT.get",this.get.bind(this),{optionsIndex:1})??this.get,this.put=e.metrics?.traceFunction("libp2p.kadDHT.put",this.put.bind(this),{optionsIndex:2})??this.put}async getLocal(e){this.log("getLocal %b",e);const t=Ci(this.datastorePrefix,e);this.log("fetching record for key %k",t);const r=await this.components.datastore.get(t);this.log("found %k in local datastore",t);const s=Kt.deserialize(r);return await ed(this.validators,s),s}async*sendCorrectionRecord(e,t,r,s={}){this.log("sendCorrection for %b",e);const i=o0(e,r);for(const{value:o,from:a}of t){if(pe(o,r)){this.log("record was ok");continue}if(this.components.peerId.equals(a)){try{const u=Ci(this.datastorePrefix,e);this.log(`Storing corrected record for key ${u.toString()}`),await this.components.datastore.put(u,i.subarray())}catch(u){this.log.error("Failed error correcting self",u)}continue}let c=!1;const l={type:ke.PUT_VALUE,key:e,record:i};for await(const u of this.network.sendRequest(a,l,s))u.name==="PEER_RESPONSE"&&u.record!=null&&pe(u.record.value,Kt.deserialize(i).value)&&(c=!0),yield u;c||(yield yn({from:a,error:new qa("Value not put correctly")},s)),this.log.error("Failed error correcting entry")}}async*put(e,t,r={}){this.log("put key %b value %b",e,t);const s=o0(e,t),i=Ci(this.datastorePrefix,e);this.log(`storing record for key ${i.toString()}`),await this.components.datastore.put(i,s.subarray()),yield*Bt(this.peerRouting.getClosestPeers(e,{...r,signal:r.signal}),o=>ni(o,a=>async()=>{if(a.name!=="FINAL_PEER")return[a];const c=[],l={type:ke.PUT_VALUE,key:e,record:s};this.log("send put to %p",a.peer.id);for await(const u of this.network.sendRequest(a.peer.id,l,r))c.push(u),u.name==="PEER_RESPONSE"&&(u.record!=null&&pe(u.record.value,Kt.deserialize(s).value)||c.push(yn({from:a.peer.id,error:new qa("Value not put correctly")},r)));return c}),o=>oo(o,{ordered:!1,concurrency:Jh}),async function*(o){for await(const a of o)yield*a})}async*get(e,t={}){this.log("get %b",e);const r=[];for await(const a of this.getMany(e,t))a.name==="VALUE"&&r.push(a),yield a;if(r.length===0)return;const s=r.map(a=>a.value);let i=0;try{i=MP(this.selectors,e,s)}catch(a){if(a.name!=="InvalidParametersError")throw a}const o=s[i];if(this.log("GetValue %b %b",e,o),o==null)throw new It("Best value was not found");yield*this.sendCorrectionRecord(e,r,o,t),yield r[i]}async*getMany(e,t={}){this.log("getMany values for %b",e);try{const i=await this.getLocal(e);yield Du({value:i.value,from:this.components.peerId},t)}catch(i){this.log("error getting local value for %b",e,i)}const r=this,s=async function*({peer:i,signal:o}){for await(const a of r.peerRouting.getValueOrPeers(i,e,{...t,signal:o}))yield a,a.name==="PEER_RESPONSE"&&a.record!=null&&(yield Du({from:i,value:a.record.value},t))};yield*this.queryManager.run(e,s,t)}}function ZP(n,e){return{id:n.id.toMultihash().bytes,multiaddrs:(n.multiaddrs??[]).map(r=>r.bytes),connection:e}}function Vo(n){if(n.id==null)throw new Error("Invalid peer in message");const e=je(n.id);return{id:Ft(e),multiaddrs:(n.multiaddrs??[]).map(t=>re(t))}}class jP{log;components;network;peerRouting;queryManager;routingTable;providers;constructor(e,t){const{network:r,peerRouting:s,queryManager:i,routingTable:o,providers:a,logPrefix:c}=t;this.components=e,this.log=e.logger.forComponent(`${c}:content-routing`),this.network=r,this.peerRouting=s,this.queryManager=i,this.routingTable=o,this.providers=a,this.findProviders=e.metrics?.traceFunction("libp2p.kadDHT.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromYieldedValue:(l,u)=>(l.name==="PROVIDER"&&(u.providers??=[],u.providers.push(...l.providers.map(h=>h.id.toString()))),u)})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.kadDHT.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromYieldedValue:(l,u)=>(l.name==="PEER_RESPONSE"&&l.messageName==="ADD_PROVIDER"&&(u.providers??=[],u.providers.push(l.from.toString())),u)})??this.provide}async*provide(e,t,r={}){this.log("provide %s",e);const s=e.multihash.bytes;await this.providers.addProvider(e,this.components.peerId);const i={type:ke.ADD_PROVIDER,key:s,providers:[ZP({id:this.components.peerId,multiaddrs:t})]};let o=0;const a=c=>async()=>{if(c.name!=="FINAL_PEER")return[c];const l=[];this.log("putProvider %s to %p",e,c.peer.id);try{this.log("sending provider record for %s to %p",e,c.peer.id);for await(const u of this.network.sendMessage(c.peer.id,i,r))u.name==="PEER_RESPONSE"&&(this.log("sent provider record for %s to %p",e,c.peer.id),o++),l.push(u)}catch(u){this.log.error("error sending provide record to peer %p",c.peer.id,u),l.push(yn({from:c.peer.id,error:u},r))}return l};yield*Bt(this.peerRouting.getClosestPeers(s,r),c=>ni(c,l=>a(l)),c=>oo(c,{ordered:!1,concurrency:Jh}),async function*(c){for await(const l of c)yield*l}),this.log("sent provider records to %d peers",o)}async*findProviders(e,t){const r=this.routingTable.kBucketSize;let s=0;const i=e.multihash.bytes,o=this;this.log("findProviders %c",e);const a=await this.providers.getProviders(e);if(a.length>0){const u=[];for(const h of a.slice(0,r))try{const d=await this.components.peerStore.get(h);u.push({id:h,multiaddrs:d.addresses.map(({multiaddr:f})=>f)})}catch(d){if(d.name!=="NotFoundError")throw d;this.log("no peer store entry for %p",h)}if(yield Cu({from:this.components.peerId,messageType:ke.GET_PROVIDERS,providers:u},t),yield s0({from:this.components.peerId,providers:u},t),s+=u.length,s>=r)return}const c=async function*({peer:u,signal:h}){const d={type:ke.GET_PROVIDERS,key:i};yield*o.network.sendRequest(u,d,{...t,signal:h})},l=new sr(a);for await(const u of this.queryManager.run(i,c,t))if(yield u,u.name==="PEER_RESPONSE"){this.log("Found %d provider entries for %c and %d closer peers",u.providers.length,e,u.closer.length);const h=[];for(const d of u.providers)l.has(d.id)||(l.add(d.id),h.push(d));if(h.length>0&&(yield s0({from:u.from,providers:h},t),s+=h.length,s>=r))return}}}class JP extends Ke{log;protocol;running;components;timeout;metrics;constructor(e,t){super(),this.components=e,this.log=e.logger.forComponent(`${t.logPrefix}:network`),this.running=!1,this.protocol=t.protocol,this.timeout=new qi({...t.timeout??{},metrics:e.metrics,metricName:`${t.metricsPrefix}_network_message_send_times_milliseconds`}),this.metrics={operations:e.metrics?.registerCounterGroup(`${t.metricsPrefix}_outbound_rpc_requests_total`),errors:e.metrics?.registerCounterGroup(`${t.metricsPrefix}_outbound_rpc_errors_total`)},this.sendRequest=e.metrics?.traceFunction("libp2p.kadDHT.sendRequest",this.sendRequest.bind(this),{optionsIndex:2,getAttributesFromArgs([r,s],i){return{...i,to:r.toString(),"message type":`${s.type}`}},getAttributesFromYieldedValue:(r,s)=>(r.name==="PEER_RESPONSE"&&(r.providers.length>0&&r.providers.forEach((i,o)=>{s[`providers-${o}`]=i.id.toString()}),r.closer.length>0&&r.closer.forEach((i,o)=>{s[`closer-${o}`]=i.id.toString()})),s)})??this.sendRequest,this.sendMessage=e.metrics?.traceFunction("libp2p.kadDHT.sendMessage",this.sendMessage.bind(this),{optionsIndex:2,getAttributesFromArgs([r,s],i){return{...i,to:r.toString(),"message type":`${s.type}`}},getAttributesFromYieldedValue:(r,s)=>(r.name==="PEER_RESPONSE"&&(r.providers.length>0&&r.providers.forEach((i,o)=>{s[`providers-${o}`]=i.id.toString()}),r.closer.length>0&&r.closer.forEach((i,o)=>{s[`closer-${o}`]=i.id.toString()})),s)})??this.sendMessage}async start(){this.running||(this.running=!0)}async stop(){this.running=!1}isStarted(){return this.running}async*sendRequest(e,t,r={}){if(!this.running)return;const s=t.type;if(s==null)throw new B("Message type was missing");this.log("sending %s to %p",t.type,e),yield i0({peer:e},r),yield n0({to:e,type:s},r);let i;const o=this.timeout.getTimeoutSignal(r);r={...r,signal:o};try{this.metrics.operations?.increment({[s]:!0}),i=await(await this.components.connectionManager.openConnection(e,r)).newStream(this.protocol,r);const c=await this._writeReadMessage(i,t,r);i.close(r).catch(l=>{this.log.error("error closing stream to %p",e,l),i?.abort(l)}),yield Cu({from:e,messageType:c.type,closer:c.closer.map(Vo),providers:c.providers.map(Vo),record:c.record==null?void 0:Kt.deserialize(c.record)},r)}catch(a){this.metrics.errors?.increment({[s]:!0}),i?.abort(a),r.signal?.aborted!==!0&&this.log.error("could not send %s to %p - %e",t.type,e,a),yield yn({from:e,error:a},r)}finally{this.timeout.cleanUp(o)}}async*sendMessage(e,t,r={}){if(!this.running)return;const s=t.type;if(s==null)throw new B("Message type was missing");this.log("sending %s to %p",t.type,e),yield i0({peer:e},r),yield n0({to:e,type:s},r);let i;const o=this.timeout.getTimeoutSignal(r);r={...r,signal:o};try{this.metrics.operations?.increment({[s]:!0}),i=await(await this.components.connectionManager.openConnection(e,r)).newStream(this.protocol,r),await this._writeMessage(i,t,r),i.close(r).catch(c=>{this.log.error("error closing stream to %p",e,c),i?.abort(c)}),yield Cu({from:e,messageType:s},r)}catch(a){this.metrics.errors?.increment({[s]:!0}),i?.abort(a),yield yn({from:e,error:a},r)}finally{this.timeout.cleanUp(o)}}async _writeMessage(e,t,r){await pt(e).write(t,Fn,r)}async _writeReadMessage(e,t,r){const s=pt(e);await s.write(t,Fn,r);const i=await s.read(Fn,r);return i.closer.forEach(o=>{this.safeDispatchEvent("peer",{detail:Vo(o)})}),i.providers.forEach(o=>{this.safeDispatchEvent("peer",{detail:Vo(o)})}),i}}function ji(n,e){if(n.byteLength!==e.byteLength)throw new Error("Inputs should have the same length");for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return n[t]<e[t]?-1:1;return 0}class td{originDhtKey;capacity;peerDistances;constructor(e,t){this.originDhtKey=e,this.capacity=t,this.peerDistances=[]}get length(){return this.peerDistances.length}get peers(){return this.peerDistances.map(e=>e.peer)}async add(e){const t=await or(e.id);this.addWitKadId(e,t)}addWitKadId(e,t){if(this.peerDistances.find(s=>s.peer.id.equals(e.id))!=null)return;const r={peer:e,distance:hn(this.originDhtKey,t)};this.peerDistances.push(r),this.peerDistances.sort((s,i)=>ji(s.distance,i.distance)),this.peerDistances=this.peerDistances.slice(0,this.capacity)}async isCloser(e){if(this.length===0)return!0;const t=await or(e),r=hn(t,this.originDhtKey),s=this.peerDistances[this.peerDistances.length-1].distance;return ji(r,s)===-1}async anyCloser(e){return e.length===0?!1:Promise.any(e.map(async t=>this.isCloser(t)))}}class eC{log;routingTable;network;validators;queryManager;peerStore;peerId;constructor(e,t){this.routingTable=t.routingTable,this.network=t.network,this.validators=t.validators,this.queryManager=t.queryManager,this.peerStore=e.peerStore,this.peerId=e.peerId,this.log=e.logger.forComponent(`${t.logPrefix}:peer-routing`),this.findPeer=e.metrics?.traceFunction("libp2p.kadDHT.findPeer",this.findPeer.bind(this),{optionsIndex:1})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.kadDHT.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1})??this.getClosestPeers}async findPeerLocal(e){let t;const r=await this.routingTable.find(e);if(r!=null){this.log("findPeerLocal found %p in routing table",e);try{t=await this.peerStore.get(r)}catch(s){if(s.name!=="NotFoundError")throw s}}if(t==null)try{t=await this.peerStore.get(e)}catch(s){if(s.name!=="NotFoundError")throw s}if(t!=null)return this.log("findPeerLocal found %p in peer store",e),{id:t.id,multiaddrs:t.addresses.map(s=>s.multiaddr)}}async*_getValueSingle(e,t,r={}){const s={type:ke.GET_VALUE,key:t};yield*this.network.sendRequest(e,s,r)}async*getPublicKeyFromNode(e,t={}){const r=$P(e);for await(const s of this._getValueSingle(e,r,t))if(yield s,s.name==="PEER_RESPONSE"&&s.record!=null){const i=Tt(s.record.value),o=Ms(i);if(!o.equals(e))throw new Xo("public key does not match id");if(o.publicKey==null)throw new Xo("public key missing");yield Du({from:e,value:s.record.value},t)}throw new qa(`Node not responding with its public key: ${e.toString()}`)}async*findPeer(e,t={}){if(this.log("findPeer %p",e),t.useCache!==!1){const s=await this.findPeerLocal(e);if(s!=null){this.log("found local"),yield kl({from:this.peerId,peer:s},t);return}}let r=!1;if(t.useNetwork!==!1){const s=this,i=async function*({peer:o,signal:a}){const c={type:ke.FIND_NODE,key:e.toMultihash().bytes};for await(const l of s.network.sendRequest(o,c,{...t,signal:a}))if(yield l,l.name==="PEER_RESPONSE"){const u=l.closer.find(h=>h.id.equals(e));u!=null&&(yield kl({from:l.from,peer:u},t))}};for await(const o of this.queryManager.run(e.toMultihash().bytes,i,t))o.name==="FINAL_PEER"&&(r=!0),yield o}r||(yield yn({from:this.peerId,error:new It("Not found")},t))}async*getClosestPeers(e,t={}){this.log("getClosestPeers to %b",e);const r=await Zi(e),s=this.routingTable.closestPeers(r),i=this,o=new td(r,this.routingTable.kBucketSize);await Promise.all(s.map(async c=>{await o.add({id:c,multiaddrs:[]})}));const a=async function*({peer:c,signal:l}){i.log("closerPeersSingle %s from %p",K(e,"base32"),c);const u={type:ke.FIND_NODE,key:e};yield*i.network.sendRequest(c,u,{...t,signal:l})};for await(const c of this.queryManager.run(e,a,t))c.name==="PEER_RESPONSE"&&await Promise.all(c.closer.map(async l=>{await o.add(l)})),yield c;this.log("found %d peers close to %b",o.length,e);for(const c of o.peers)yield kl({from:this.peerId,peer:c},t)}async*getValueOrPeers(e,t,r={}){for await(const s of this._getValueSingle(e,t,r)){if(s.name==="PEER_RESPONSE"&&s.record!=null)try{await this._verifyRecordOnline(s.record)}catch{const o="invalid record received, discarded";this.log(o),yield yn({from:s.from,error:new qa(o)},r);continue}yield s}}async _verifyRecordOnline(e){if(e.timeReceived==null)throw new DP("invalid record received");await ed(this.validators,new Kt(e.key,e.value,e.timeReceived))}async getCloserPeersOffline(e,t){const r=[];try{const c=je(e),l=Ft(c),u=await this.peerStore.get(l);r.push({id:u.id,multiaddrs:u.addresses.map(({multiaddr:h})=>h)})}catch{}const s=await Zi(e),i=this.routingTable.closestPeers(s),o=await or(t),a=hn(o,s);for(const c of i){const l=await or(c),u=hn(l,s);if(ji(u,a)===-1)try{const h=await this.peerStore.get(c);r.push({id:c,multiaddrs:h.addresses.map(({multiaddr:d})=>d)})}catch(h){if(h.name!=="NotFoundError")throw h}}return r.length>0?this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p",r.length,e,t):this.log("getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table",e,t,this.routingTable.size),r}}class tC{log;datastore;datastorePrefix;lock;constructor(e,t){this.log=e.logger.forComponent(`${t.logPrefix}:providers`),this.datastorePrefix=`${t.datastorePrefix}/provider`,this.datastore=e.datastore,this.lock=t.lock}async addProvider(e,t){const r=await this.lock.readLock();try{this.log("%p provides %s",t,e),await this.writeProviderEntry(e,t)}finally{r()}}async removeProvider(e,t){const r=await this.lock.writeLock();try{const s=Il(this.datastorePrefix,e,t);this.log("%p no longer provides %s",t,e),await this.datastore.delete(s)}finally{r()}}async getProviders(e){const t=await this.lock.readLock();try{this.log("get providers for %c",e);const r=await this.loadProviders(e);return this.log("got %d providers for %c",r.size,e),[...r.keys()]}finally{t()}}async writeProviderEntry(e,t,r=new Date){const s=Il(this.datastorePrefix,e,t),i=Ze(r.getTime());await this.datastore.put(s,i)}async loadProviders(e){const t=new bn,r=Il(this.datastorePrefix,e);for await(const s of this.datastore.query({prefix:r.toString()})){const{peerId:i}=L4(s.key);t.set(i,N4(s.value))}return t}}async function*rC(n){const{key:e,startingPeer:t,ourPeerId:r,signal:s,query:i,alpha:o,pathIndex:a,numPaths:c,queryFuncTimeout:l,log:u,peersSeen:h,connectionManager:d}=n,f=new Gn({concurrency:o,sort:(g,y)=>ji(g.options.distance,y.options.distance)}),p=await Zi(e);function m(g,y){if(g==null)return;h.add(g);const b=hn(y,p);f.add(async()=>{const w=[s];l!=null&&w.push(AbortSignal.timeout(l));const k=be(w);try{for await(const _ of i({...n,key:e,peer:g,signal:k,pathIndex:a,numPaths:c})){if(k.aborted)return;if(_.name==="PEER_RESPONSE")for(const A of _.closer){if(h.has(A.id)){u.trace("already seen %p in query",A.id);continue}if(r.equals(A.id)){u("not querying ourselves");continue}if(!await d.isDialable(A.multiaddrs)){u("not querying undialable peer");continue}const I=await or(A.id),D=hn(I,p);if(ji(D,b)!==-1){u.trace("skipping %p as they are not closer to %b than %p",A.id,e,g);continue}u.trace("querying closer peer %p",A.id),m(A.id,I)}f.safeDispatchEvent("completed",{detail:_})}}catch(_){if(!s.aborted)return yn({from:g,error:_},n)}finally{k.clear()}},{distance:b}).catch(w=>{u.error(w)})}m(t,await or(t));try{for await(const g of f.toGenerator({signal:s}))g!=null&&(yield g)}catch(g){throw s.aborted?new CP("Query aborted"):g}}class nC{disjointPaths;alpha;shutDownController;running;logger;peerId;connectionManager;routingTable;initialQuerySelfHasRun;logPrefix;constructor(e,t){this.logPrefix=t.logPrefix,this.disjointPaths=t.disjointPaths??M4,this.alpha=t.alpha??Jh,this.initialQuerySelfHasRun=t.initialQuerySelfHasRun,this.routingTable=t.routingTable,this.logger=e.logger,this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.shutDownController=new AbortController,this.shutDownController.signal,this.running=!1}isStarted(){return this.running}async start(){this.running||(this.running=!0,this.shutDownController=new AbortController,this.shutDownController.signal,void 0)}async stop(){this.running=!1,this.shutDownController.abort()}async*run(e,t,r={}){if(!this.running)throw new Error("QueryManager not started");if(r.signal==null){const c=AbortSignal.timeout(AP);r={...r,signal:c}}const s=new AbortController,i=be([this.shutDownController.signal,s.signal,r.signal]);s.signal;const o=this.logger.forComponent(`${this.logPrefix}:query:`+K(e,"base58btc"));let a=!1;try{r.isSelfQuery!==!0&&this.initialQuerySelfHasRun!=null&&(o("waiting for initial query-self query before continuing"),await Ht(this.initialQuerySelfHasRun.promise,i),this.initialQuerySelfHasRun=void 0),o("query:start");const c=await Zi(e),l=this.routingTable.closestPeers(c),u=l.slice(0,Math.min(this.disjointPaths,l.length));if(l.length===0){o.error("Running query with no peers");return}const h=new sr,d=u.map((f,p)=>rC({...r,key:e,startingPeer:f,ourPeerId:this.peerId,signal:i,query:t,pathIndex:p,numPaths:u.length,alpha:this.alpha,queryFuncTimeout:r.queryFuncTimeout,log:o,peersSeen:h,onProgress:r.onProgress,connectionManager:this.connectionManager}));for await(const f of sn(...d)){if(f.name==="QUERY_ERROR"&&o.error("query error",f.error),f.name==="PEER_RESPONSE")for(const p of[...f.closer,...f.providers])await this.connectionManager.isDialable(p.multiaddrs)&&await this.routingTable.add(p.id);yield f}a=!0}catch(c){if(!(!this.running&&c.name==="QueryAbortedError"))throw c}finally{a||(o("query exited early"),s.abort()),i.clear(),o("query:done")}}}function sC(n){return n[Symbol.asyncIterator]!=null}function O4(n){if(sC(n))return(async()=>{let e=0;for await(const t of n)e++;return e})();{let e=0;for(const t of n)e++;return e}}const iC=n=>{const e=n.addEventListener||n.on||n.addListener,t=n.removeEventListener||n.off||n.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(n),removeListener:t.bind(n)}};function oC(n,e,t){let r;const s=new Promise((i,o)=>{if(t={rejectionEvents:["error"],multiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");t.signal?.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:u}=iC(n),h=(...f)=>{const p=t.multiArgs?f:f[0];t.filter&&!t.filter(p)||(c.push(p),t.count===c.length&&(r(),i(c)))},d=f=>{r(),o(f)};r=()=>{for(const f of a)u(f,h);for(const f of t.rejectionEvents)u(f,d)};for(const f of a)l(f,h);for(const f of t.rejectionEvents)l(f,d);t.signal&&t.signal.addEventListener("abort",()=>{d(t.signal.reason)},{once:!0}),t.resolveImmediately&&i(c)});if(s.cancel=r,typeof t.timeout=="number"){const i=ao(s,{milliseconds:t.timeout});return i.cancel=r,i}return s}function aC(n,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const r=oC(n,e,t),s=r.then(i=>i[0]);return s.cancel=r.cancel,s}class cC{log;peerId;peerRouting;routingTable;count;interval;initialInterval;queryTimeout;running;timeoutId;controller;initialQuerySelfHasRun;querySelfPromise;constructor(e,t){this.peerId=e.peerId,this.log=e.logger.forComponent(`${t.logPrefix}:query-self`),this.running=!1,this.peerRouting=t.peerRouting,this.routingTable=t.routingTable,this.count=t.count??M4,this.interval=t.interval??SP,this.initialInterval=t.initialInterval??_P,this.queryTimeout=t.queryTimeout??xP,this.initialQuerySelfHasRun=t.initialQuerySelfHasRun,this.querySelf=B4(this.querySelf.bind(this),t.operationMetrics,"SELF_QUERY")}isStarted(){return this.running}start(){this.running||(this.running=!0,clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.querySelf().catch(e=>{this.log.error("error running self-query",e)})},this.initialInterval))}stop(){this.running=!1,this.timeoutId!=null&&clearTimeout(this.timeoutId),this.controller!=null&&this.controller.abort()}async querySelf(){if(!this.running){this.log("skip self-query because we are not started");return}if(this.querySelfPromise!=null)return this.log("joining existing self query"),this.querySelfPromise.promise;if(this.querySelfPromise=ae(),this.running){this.controller=new AbortController;const e=[this.controller.signal];if(this.initialQuerySelfHasRun==null){const r=AbortSignal.timeout(this.queryTimeout);e.push(r)}const t=be(e);this.controller.signal;try{this.routingTable.size===0&&(this.log("routing table was empty, waiting for some peers before running query"),await aC(this.routingTable,"peer:add",{signal:t,filter:i=>!this.peerId.equals(i.detail)}),this.log("routing table has peers, continuing with query")),this.log("run self-query, look for %d peers timing out after %dms",this.count,this.queryTimeout);const r=Date.now(),s=await Bt(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes,{signal:t,isSelfQuery:!0}),i=>Ra(i,this.count),async i=>O4(i));this.log("self-query found %d peers in %dms",s,Date.now()-r)}catch(r){this.log.error("self-query error",r)}finally{t.clear(),this.initialQuerySelfHasRun!=null&&(this.initialQuerySelfHasRun.resolve(),this.initialQuerySelfHasRun=void 0)}}this.querySelfPromise.resolve(),this.querySelfPromise=void 0,this.running&&(this.timeoutId=setTimeout(()=>{this.querySelf().catch(e=>{this.log.error("error running self-query",e)})},this.interval))}}class lC extends Ke{log;reprovideQueue;maxQueueSize;datastore;timeout;reprovideTimeout;running;shutdownController;reprovideThreshold;contentRouting;datastorePrefix;addressManager;validity;interval;lock;peerId;constructor(e,t){super(),this.log=e.logger.forComponent(`${t.logPrefix}:reprovider`),this.peerId=e.peerId,this.reprovideQueue=new Gn({concurrency:t.concurrency??bP,metrics:e.metrics,metricName:`${t.metricsPrefix}_reprovide_queue`}),this.reprovideTimeout=new qi({...t.timeout??{},metrics:e.metrics,metricName:`${t.metricsPrefix}_reprovide_timeout_milliseconds`}),this.datastore=e.datastore,this.addressManager=e.addressManager,this.datastorePrefix=`${t.datastorePrefix}/provider`,this.reprovideThreshold=t.threshold??wP,this.maxQueueSize=t.maxQueueSize??vP,this.validity=t.validity??yP,this.interval=t.interval??EP,this.contentRouting=t.contentRouting,this.lock=t.lock,this.running=!1,this.reprovide=B4(this.reprovide.bind(this),t.operationMetrics,"PROVIDE")}start(){this.running||(this.running=!0,this.shutdownController=new AbortController,this.shutdownController.signal,this.timeout=setTimeout(()=>{this.cleanUp().catch(e=>{this.log.error("error running reprovide/cleanup - %e",e)})},this.interval))}stop(){this.running=!1,this.reprovideQueue.clear(),clearTimeout(this.timeout),this.shutdownController?.abort()}async cleanUp(){const e=await this.lock.writeLock();try{this.safeDispatchEvent("reprovide:start");for await(const t of this.datastore.query({prefix:this.datastorePrefix}))try{const{cid:r,peerId:s}=L4(t.key),i=N4(t.value).getTime(),o=i+this.validity,a=Date.now(),c=a>o;this.log.trace("comparing: %d < %d = %s %s",i,a-this.validity,c,c?"(expired)":""),c&&await this.datastore.delete(t.key),this.peerId.equals(s)&&a-o<this.reprovideThreshold&&this.queueReprovide(r).catch(l=>{this.log.error("could not reprovide %c - %e",r,l)})}catch(r){this.log.error("error processing datastore key %s - %e",t.key,r.message)}this.log("reprovide/cleanup successful")}finally{e(),this.safeDispatchEvent("reprovide:end"),this.running&&(this.timeout=setTimeout(()=>{this.cleanUp().catch(t=>{this.log.error("error running re-provide - %e",t)})},this.interval))}}async queueReprovide(e){if(!this.running)return;this.log.trace("waiting for queue capacity before adding %c to re-provide queue",e),await this.reprovideQueue.onSizeLessThan(this.maxQueueSize);const t=this.reprovideQueue.queue.find(r=>r.options.cid.equals(e));if(t!=null)return this.log.trace("not adding %c to re-provide queue - already in queue",e),t.join();this.log.trace("adding %c to re-provide queue",e),this.reprovideQueue.add(async r=>{if(r.signal?.throwIfAborted(),!this.running)return;this.log.trace("re-providing %c",e);const s=this.reprovideTimeout.getTimeoutSignal(r);try{await this.reprovide(r.cid,r)}finally{this.reprovideTimeout.cleanUp(s)}this.log.trace("re-provided %c",e)},{signal:this.shutdownController?.signal,cid:e}).catch(r=>{this.log.error("could not re-provide key %c - %e",e,r)})}async reprovide(e,t){await pn(this.contentRouting.provide(e,this.addressManager.getAddresses(),t))}}const uC=20,hC=5e3,dC="kad-close",fC=50;class pC{routingTable;components;closestPeers;newPeers;refreshInterval;peerSetSize;timeout;closeTagName;closeTagValue;log;running;constructor(e,t){this.components=e,this.log=e.logger.forComponent(`${t.logPrefix}:routing-table`),this.routingTable=t.routingTable,this.refreshInterval=t.refreshInterval??hC,this.peerSetSize=t.peerSetSize??uC,this.closeTagName=t.closeTagName??dC,this.closeTagValue=t.closeTagValue??fC,this.closestPeers=new sr,this.onPeerPing=this.onPeerPing.bind(this),this.running=!1}async start(){if(this.running)return;this.running=!0;const e=await or(this.components.peerId);this.newPeers=new td(e,this.peerSetSize),this.routingTable.addEventListener("peer:ping",this.onPeerPing),this.timeout=setInterval(()=>{this.updatePeerTags().catch(t=>{this.log.error("error updating peer tags - %e",t)})},this.refreshInterval)}stop(){this.running=!1,this.routingTable.removeEventListener("peer:ping",this.onPeerPing),clearTimeout(this.timeout)}onPeerPing(e){this.newPeers?.add({id:e.detail,multiaddrs:[]}).catch(t=>{this.log.error("error adding peer to distance list - %e",t)})}async updatePeerTags(){const e=new sr(this.newPeers?.peers.map(s=>s.id)),t=e.difference(this.closestPeers),r=this.closestPeers.difference(e);this.closestPeers=e,await Promise.all([...[...t].map(async s=>{await this.components.peerStore.merge(s,{tags:{[this.closeTagName]:{value:this.closeTagValue},[t0]:{value:1}}})}),...[...r].map(async s=>{await this.components.peerStore.merge(s,{tags:{[this.closeTagName]:void 0,[t0]:void 0}})})])}}function Go(n){return Array.isArray(n?.peers)}class gC{root;localPeer;prefixLength;splitThreshold;kBucketSize;numberOfNodesToPing;lastPingThreshold;ping;verify;onAdd;onRemove;onMove;addingPeerMap;constructor(e){this.prefixLength=e.prefixLength??wC,this.kBucketSize=e.kBucketSize??F4,this.splitThreshold=e.splitThreshold??this.kBucketSize,this.numberOfNodesToPing=e.numberOfOldContactsToPing??EC,this.lastPingThreshold=e.lastPingThreshold??kC,this.ping=e.ping,this.verify=e.verify,this.onAdd=e.onAdd,this.onRemove=e.onRemove,this.addingPeerMap=new bn,this.root={prefix:"",depth:0,peers:[]}}async addSelfPeer(e){this.localPeer={peerId:e,kadId:await or(e),lastPing:Date.now()}}async add(e,t){const r={peerId:e,kadId:await or(e),lastPing:0},s=this.addingPeerMap.get(e);if(s!=null)return s;try{const i=this._add(r,t);this.addingPeerMap.set(e,i),await i}finally{this.addingPeerMap.delete(e)}}async _add(e,t){const r=this._determineBucket(e.kadId);if(this._indexOf(r,e.kadId)>-1)return;if(r.peers.length===this.splitThreshold&&r.depth<this.prefixLength){await this._split(r),await this._add(e,t);return}if(r.peers.length<this.kBucketSize){if(!yC(e,this.lastPingThreshold)){r.peers.push(e),await this.onAdd?.(e,r);return}await this.verify(e,t)&&(e.lastPing=Date.now(),await this._add(e,t));return}const s=r.peers.filter(o=>!(o.peerId.equals(this.localPeer?.peerId)||o.lastPing>Date.now()-this.lastPingThreshold)).sort((o,a)=>o.lastPing<a.lastPing?-1:o.lastPing>a.lastPing?1:0).slice(0,this.numberOfNodesToPing);let i=!1;for await(const o of this.ping(s,t))i=!0,await this.remove(o.kadId);i&&await this._add(e,t)}*closest(e,t=this.kBucketSize){const r=new td(e,t);for(const s of this.toIterable())r.addWitKadId({id:s.peerId,multiaddrs:[]},s.kadId);yield*ni(r.peers,s=>s.id)}count(){function e(t){if(Go(t))return t.peers.length;let r=0;return t.left!=null&&(r+=e(t.left)),t.right!=null&&(r+=e(t.right)),r}return e(this.root)}get(e){const t=this._determineBucket(e),r=this._indexOf(t,e);return t.peers[r]}async remove(e){const t=this._determineBucket(e),r=this._indexOf(t,e);if(r>-1){const s=t.peers.splice(r,1)[0];await this.onRemove?.(s,t)}}*toIterable(){function*e(t){if(Go(t)){yield*t.peers;return}yield*e(t.left),yield*e(t.right)}yield*e(this.root)}distance(e,t){return BigInt("0x"+K(hn(e,t),"base16"))}_determineBucket(e){const t=K(e,"base2");function r(s,i=0){return Go(s)?s:t[i]==="0"?r(s.left,i+1):r(s.right,i+1)}return r(this.root)}_indexOf(e,t){return e.peers.findIndex(r=>pe(r.kadId,t))}async _split(e){const t={prefix:"0",depth:e.depth+1,peers:[]},r={prefix:"1",depth:e.depth+1,peers:[]};for(const s of e.peers)K(s.kadId,"base2")[e.depth]==="0"?(t.peers.push(s),await this.onMove?.(s,e,t)):(r.peers.push(s),await this.onMove?.(s,e,r));mC(e,t,r)}}function mC(n,e,t){return delete n.peers,n.left=e,n.right=t,n.prefix===""&&(delete n.depth,delete n.prefix),!0}function yC(n,e){return n.lastPing<Date.now()-e}const F4=20,wC=8,bC=20,vC=100,EC=3,SC=20,_C=100,a0="kad-peer",xC=1,kC=6e5,IC=!0,AC=1e3;class TC extends Ke{kBucketSize;kb;network;closestPeerTagger;log;components;running;pingNewContactTimeout;pingNewContactQueue;pingOldContactTimeout;pingOldContactQueue;populateFromDatastoreOnStart;populateFromDatastoreLimit;protocol;peerTagName;peerTagValue;metrics;constructor(e,t){super(),this.components=e,this.log=e.logger.forComponent(`${t.logPrefix}:routing-table`),this.kBucketSize=t.kBucketSize??F4,this.running=!1,this.protocol=t.protocol,this.network=t.network,this.peerTagName=t.peerTagName??a0,this.peerTagValue=t.peerTagValue??xC,this.pingOldContacts=this.pingOldContacts.bind(this),this.verifyNewContact=this.verifyNewContact.bind(this),this.peerAdded=this.peerAdded.bind(this),this.peerRemoved=this.peerRemoved.bind(this),this.populateFromDatastoreOnStart=t.populateFromDatastoreOnStart??IC,this.populateFromDatastoreLimit=t.populateFromDatastoreLimit??AC,this.pingOldContactQueue=new fn({concurrency:t.pingOldContactConcurrency??SC,metricName:`${t.metricsPrefix}_ping_old_contact_queue`,metrics:this.components.metrics,maxSize:t.pingOldContactMaxQueueSize??_C}),this.pingOldContactTimeout=new qi({...t.pingOldContactTimeout??{},metrics:this.components.metrics,metricName:`${t.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`}),this.pingNewContactQueue=new fn({concurrency:t.pingNewContactConcurrency??bC,metricName:`${t.metricsPrefix}_ping_new_contact_queue`,metrics:this.components.metrics,maxSize:t.pingNewContactMaxQueueSize??vC}),this.pingNewContactTimeout=new qi({...t.pingNewContactTimeout??{},metrics:this.components.metrics,metricName:`${t.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`}),this.kb=new gC({kBucketSize:t.kBucketSize,prefixLength:t.prefixLength,splitThreshold:t.splitThreshold,numberOfOldContactsToPing:t.numberOfOldContactsToPing,lastPingThreshold:t.lastPingThreshold,ping:this.pingOldContacts,verify:this.verifyNewContact,onAdd:this.peerAdded,onRemove:this.peerRemoved}),this.closestPeerTagger=new pC(this.components,{logPrefix:t.logPrefix,routingTable:this,peerSetSize:t.closestPeerSetSize,refreshInterval:t.closestPeerSetRefreshInterval,closeTagName:t.closeTagName,closeTagValue:t.closeTagValue}),this.components.metrics!=null&&(this.metrics={routingTableSize:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_size`),routingTableKadBucketTotal:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_total`),routingTableKadBucketAverageOccupancy:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),routingTableKadBucketMinOccupancy:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),routingTableKadBucketMaxOccupancy:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),routingTableKadBucketMaxDepth:this.components.metrics.registerMetric(`${t.metricsPrefix}_routing_table_kad_bucket_max_depth`),kadBucketEvents:this.components.metrics.registerCounterGroup(`${t.metricsPrefix}_kad_bucket_events_total`)})}isStarted(){return this.running}async start(){this.running||(this.running=!0,await Nr(this.closestPeerTagger),await this.kb.addSelfPeer(this.components.peerId))}async afterStart(){Promise.resolve().then(async()=>{if(!this.populateFromDatastoreOnStart)return;let e=0;for(const t of await this.components.peerStore.all({filters:[r=>r.protocols.includes(this.protocol)&&r.tags.has(a0)],limit:this.populateFromDatastoreLimit})){if(!this.running)return;try{await this.add(t.id),e++}catch{this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e"),await this.components.peerStore.merge(t.id,{tags:{[this.peerTagName]:void 0}})}}this.log("added %d peer store peers to the routing table",e)}).catch(e=>{this.log.error("error adding peer store peers to the routing table %e",e)})}async stop(){this.running=!1,await wn(this.closestPeerTagger),this.pingOldContactQueue.abort(),this.pingNewContactQueue.abort()}async peerAdded(e,t){this.components.peerId.equals(e.peerId)||await this.components.peerStore.merge(e.peerId,{tags:{[this.peerTagName]:{value:this.peerTagValue}}}),this.updateMetrics(),this.metrics?.kadBucketEvents.increment({peer_added:!0}),this.safeDispatchEvent("peer:add",{detail:e.peerId})}async peerRemoved(e,t){this.components.peerId.equals(e.peerId)||await this.components.peerStore.merge(e.peerId,{tags:{[this.peerTagName]:void 0}}),this.updateMetrics(),this.metrics?.kadBucketEvents.increment({peer_removed:!0}),this.safeDispatchEvent("peer:remove",{detail:e.peerId})}async*pingOldContacts(e,t){if(!this.running)return;const r=[];for(const s of e){if(this.kb.get(s.kadId)==null){this.log("asked to ping contact %p that was not in routing table",s.peerId);continue}this.metrics?.kadBucketEvents.increment({ping_old_contact:!0}),r.push(async()=>{const i=this.pingOldContactQueue.find(s.peerId);if(i!=null)return this.log("asked to ping contact %p was already being pinged",s.peerId),await i.join(t)?void 0:s;if(!await this.pingOldContactQueue.add(async a=>{const c=this.pingOldContactTimeout.getTimeoutSignal(),l=be([c,a?.signal]);try{return await this.pingContact(s,a)}catch{return this.metrics?.kadBucketEvents.increment({ping_old_contact_error:!0}),!0}finally{this.pingOldContactTimeout.cleanUp(c),l.clear()}},{peerId:s.peerId,signal:t?.signal}))return s})}for await(const s of oo(r))s!=null&&(yield s)}async verifyNewContact(e,t){const r=this.pingNewContactTimeout.getTimeoutSignal(),s=be([r,t?.signal]);try{const i=this.pingNewContactQueue.find(e.peerId);return i!=null?(this.log("joining existing ping to add new peer %p to routing table",e.peerId),await i.join({signal:s})):await this.pingNewContactQueue.add(async o=>(this.metrics?.kadBucketEvents.increment({ping_new_contact:!0}),this.log("pinging new peer %p before adding to routing table",e.peerId),this.pingContact(e,o)),{peerId:e.peerId,signal:s})}catch{return this.log.trace("tried to add peer %p but they were not online",e.peerId),this.metrics?.kadBucketEvents.increment({ping_new_contact_error:!0}),!1}finally{this.pingNewContactTimeout.cleanUp(r),s.clear()}}async pingContact(e,t){try{this.log("pinging contact %p",e.peerId);for await(const r of this.network.sendRequest(e.peerId,{type:ke.PING},t))if(r.type===Mu.PEER_RESPONSE)return r.messageType===ke.PING?(this.log("contact %p ping ok",e.peerId),this.safeDispatchEvent("peer:ping",{detail:e.peerId}),!0):!1;return!1}catch(r){return this.log("error pinging old contact %p - %e",e.peerId,r),!1}}get size(){return this.kb==null?0:this.kb.count()}async find(e){const t=await or(e);return this.kb.get(t)?.peerId}closestPeer(e){const t=this.closestPeers(e,1);if(t.length>0)return t[0]}closestPeers(e,t=this.kBucketSize){return this.kb==null?[]:[...this.kb.closest(e,t)]}async add(e,t){if(this.kb==null)throw new Error("RoutingTable is not started");await this.kb.add(e,t)}async remove(e){if(this.kb==null)throw new Error("RoutingTable is not started");const t=await or(e);await this.kb.remove(t)}updateMetrics(){if(this.metrics==null||this.kb==null)return;let e=0,t=0,r=0,s=20,i=0;function o(a){if(Go(a)){a.depth>r&&(r=a.depth),t++,e+=a.peers.length,a.peers.length<s&&(s=a.peers.length),a.peers.length>i&&(i=a.peers.length);return}o(a.left),o(a.right)}o(this.kb.root),this.metrics.routingTableSize.update(e),this.metrics.routingTableKadBucketTotal.update(t),this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(e/t)),this.metrics.routingTableKadBucketMinOccupancy.update(s),this.metrics.routingTableKadBucketMaxOccupancy.update(i),this.metrics.routingTableKadBucketMaxDepth.update(r)}}const PC=[77591,22417,43971,28421,740,29829,71467,228973,196661,78537,27689,36431,44415,14362,19456,106025,96308,2882,49509,21149,87173,131409,75844,23676,121838,30291,17492,2953,7564,110620,129477,127283,53113,72417,165166,109690,21200,102125,24049,71504,90342,25307,72039,26812,26715,32264,133800,71161,88956,171987,51779,24425,16671,30251,186294,247761,14202,2121,8465,35024,4876,85917,169730,3638,256836,96184,943,18678,6583,52907,35807,112254,214097,18796,11595,9243,23554,887,268203,382004,24590,111335,11625,16619,29039,102425,69006,97976,92362,32552,63717,41433,128974,137630,59943,10019,13986,35430,33665,108037,43799,43280,38195,29078,58629,18265,14425,46832,235538,40830,77881,110717,58937,3463,325358,51300,47623,117252,19007,10170,20540,91237,294813,4951,79841,56232,36270,128547,69209,66275,100156,32063,73531,34439,80937,28892,44466,88595,216307,32583,49620,16605,82127,45807,21630,78726,20235,40163,111007,96926,5567,72083,21665,58844,39419,179767,48328,42662,51550,5251,37811,49608,81056,50854,55513,20922,18891,197409,164656,32593,71449,220474,58919,85682,67854,13758,35066,3565,61905,214793,119572,141419,21504,10302,27354,67003,46131,32668,15165,64871,34450,17821,2757,11452,34189,5160,12257,85523,560,53385,65887,119549,135620,312353,115979,122356,10867,193231,124537,54783,90675,120791,4715,142253,50943,17271,43358,25331,4917,120566,34580,12878,33786,160528,32523,4869,301307,104817,81491,23276,8832,97911,31265,52065,7998,49622,9715,43998,34091,84587,20664,69041,29419,53205,10838,58288,116145,6185,5154,141795,35924,21307,144738,43730,12085,8279,10002,119,133779,199668,72938,31768,39176,67875,38453,9700,44144,4121,116048,41733,12868,82669,92308,128,34262,11332,7712,90764,36141,13553,71312,77470,117314,96549,49135,23602,54468,28605,6327,62308,17171,67531,21319,14105,894,107722,46157,8503,51069,100472,45138,15246,14577,35609,191464,1757,13364,161349,32067,91705,81144,52339,5408,91066,21983,14157,100545,4372,26630,129112,1423,29676,213626,4397,88436,99190,6877,49958,26122,114348,60661,29818,293118,50042,179738,16400,163423,89627,31040,43973,36638,45952,5153,1894,109322,1898,134021,12402,112077,68309,190269,69866,31938,107383,11522,105232,11248,14868,39852,71707,186525,16530,38162,106212,11700,5130,16608,26998,59586,108399,230033,43683,48135,82179,2073,5015,196684,189293,16378,23452,8301,35640,11632,214551,29240,57644,33137,91949,55157,52384,117313,5090,17717,89668,49363,82238,241035,66216,29066,184088,97206,62820,26595,4241,135635,173672,8202,459,71355,146294,29587,3008,135385,141203,14803,6634,45094,69362,50925,546,51884,62011,83296,234584,44515,56050,89476,87751,19373,12691,149923,19794,13833,35846,87557,58339,2884,19145,25647,12224,11024,77338,64608,122297,53025,7205,36189,36294,170779,21750,7739,173883,75192,35664,224240,113121,30181,26267,27036,117827,92015,106516,55628,203549,67949,60462,60844,35911,20457,1820,920,19773,8738,73173,181993,38521,98254,76257,46008,92796,5384,26868,151566,22124,2411,15919,186872,180021,28099,152961,78811,80237,62352,102653,74259,184890,16792,123702,224945,29940,19512,75283,14059,112691,92811,233329,20411,138569,53341,109802,50600,134528,66747,5529,166531,31578,64732,67189,1596,126357,967,167999,206598,109752,119431,207825,78791,91938,10301,27311,24233,252343,28831,32812,66002,112267,90895,8786,8095,16824,22866,21813,60507,174833,19549,130985,117051,52110,6938,81923,123864,38061,919,18680,53534,46739,112893,161529,85429,26761,11900,81121,91968,15390,217947,56524,1713,6654,37089,85630,138866,61850,16491,75577,16884,98296,73523,6140,44645,6062,36366,29844,57946,37932,42472,5266,20834,19309,33753,127182,134259,35810,41805,45878,312001,14881,47757,49251,120050,44252,3708,25856,107864,120347,1228,36550,41682,34496,47025,8393,173365,246526,12894,161607,35670,90785,126572,2095,124731,157033,58694,554,12786,9642,4817,16136,47864,174698,66992,4639,69284,10625,40710,27763,51738,30404,264105,137904,109882,52487,42824,57514,2740,10479,146799,107390,16586,88038,174951,9410,16185,44158,5568,40658,46108,12763,97385,26175,108859,664,230732,67470,46663,14395,50750,141320,93140,15361,47997,55784,6791,307840,118569,107326,18056,58281,260415,54691,8790,73332,45633,7511,45674,143373,14031,11799,94491,35646,96544,14560,26049,32983,25791,83814,42094,231370,63955,139212,2359,169908,3108,183486,105867,28197,32941,124968,26402,88267,149768,23053,3078,19091,52924,25383,19209,111548,97361,3959,24880,235061,9099,24921,161254,151405,20508,7159,34381,20133,11434,74036,19974,34769,36585,1076,22454,17354,38727,235160,111547,96454,117448,156940,91330,37299,7310,26915,117060,51369,22620,61861,322264,106850,111694,15091,2624,40345,300446,177064,1707,27389,54792,327783,132669,183543,59003,17744,20603,151134,106923,53084,71803,279424,319816,11579,21946,16728,38274,72711,5085,83391,88646,40159,25027,34680,10752,12988,54126,30365,18338,100445,230674,44874,84974,143877,123253,139372,28082,91477,144002,13096,219729,46016,50029,42377,14601,6660,58244,58978,23918,88206,113611,64452,17541,41032,10942,12021,49189,10978,40175,37156,10947,71709,106894,112538,57007,137486,150608,152719,40615,7746,279716,13101,19524,28708,40578,72320,1096,182051,94527,51275,22833,45164,81917,77519,48508,5421,140302,37845,149830,5587,27579,5357,428725,248187,6326,206760,39814,32585,89923,44341,288753,284443,96368,31201,94189,119504,20359,52073,103216,179,27934,32801,96035,34111,34309,101326,18198,20704,210266,37643,27880,141873,106e3,19414,56614,167714,66483,107885,86602,4379,20796,75467,4987,5017,118857,26003,34308,114428,29198,6686,29697,73632,3739,69795,16798,41504,7207,30722,21436,36735,28067,28545,3239,11221,36031,41889,100010,19247,317673,29495,174554,6424,129725,53845,94986,7955,59676,2604,191497,19735,102214,62954,23844,11872,179525,261436,34492,428,78404,142035,16747,17246,27578,37021,33672,57944,26056,135760,2369,61674,122066,31327,19374,157065,40553,130982,69619,71290,38855,72100,92903,95940,51422,165999,65713,57873,50726,7288,20272,2081,42326,22624,81120,57914,79352,19447,1684,72302,11774,302559,161481,96396,13692,414988,3721,79066,56627,46883,21150,11747,12184,5856,113458,176117,84416,52079,27933,3354,59765,141359,2212,216309,2555,23458,196722,142463,45701,44548,28798,19418,215,29916,9396,10574,114226,84475,13520,18694,34056,4524,90302,62930,13539,19407,77209,7728,38088,9535,2263,23875,183945,17750,26274,67172,10585,28042,22199,7478,51331,66030,26774,192929,31434,25850,50197,52926,178158,4679,181256,70184,229600,9959,105594,72158,73974,2726,35085,78087,23284,35568,51713,155676,5401,27254,11966,17569,223253,71993,103357,111477,55722,30504,26034,46774,35392,36285,214814,41143,163465,1051,16094,81044,6636,76489,179102,20712,39178,35683,125177,54219,30617,52994,25324,50123,2543,87529,58995,10688,125199,12388,60158,125481,131646,7642,133350,65874,3438,97277,101450,10075,56344,116821,50778,60547,98016,106135,13859,14255,16300,77373,173521,8285,45932,37426,4054,114295,55947,7703,39114,52,51119,128135,19714,60715,9554,50492,88180,2823,118271,52993,122625,97919,23859,37895,25040,33614,32102,20431,3577,9275,15686,43031,157741,110358,1884,40291,125391,13736,5008,64881,87336,77381,70711,43032,49155,118587,70494,4318,10168,30126,12580,10524,280104,104001,145413,2862,84140,6603,106005,13566,12780,11251,42830,571,179910,82443,13146,469,42714,32591,265217,424024,92553,54721,134100,6007,15242,114681,59030,16718,85465,200214,85982,55174,165013,23493,56964,82529,109150,32706,27568,82442,5350,14976,13165,44890,60021,21343,33978,17264,4655,22328,27819,75730,16567,55483,14510,17926,45827,150609,3704,7385,272531,161543,76904,122163,52405,2039,19165,41623,14423,228354,3369,176360,85491,7122,35789,303724,4465,13628,2233,55311,118771,20713,10006,221519,45115,71021,35650,29775,7337,10864,20665,21142,1746,15080,1624,32449,10905,105743,229797,7701,3940,22997,178467,57208,389057,39683,59403,63344,63125,54847,69691,18336,56448,3362,37202,18282,29648,138224,35867,10495,5911,28814,26653,31514,176702,26550,45621,11734,4525,40543,73944,121080,27858,155561,14887,44670,30742,8796,107455,113472,56369,75581,183777,240095,133699,153299,8768,160464,26058,49078,103971,21875,71486,44888,17156,9678,89541,123019,102337,3972,83930,21245,87852,109660,287918,183019,686,10100,39177,283941,11274,24736,26793,26214,25995,77011,141580,4070,23742,46285,46632,30700,26669,19056,35951,115575,174034,56097,35463,87425,24575,44245,38701,82317,85922,281616,100333,147697,61503,7730,84330,8530,59917,61597,17173,9092,32658,90288,193136,39023,20381,56654,31132,7779,1919,1375,117128,30819,11169,40938,23935,115201,101155,151034,4835,11231,74550,89388,59951,91704,107312,167882,115062,12732,72738,88703,464019,158267,57995,60496,737,14371,123867,4174,243339,159946,7568,16025,134556,110916,38103,191,80226,88794,29688,27230,10454,76308,57647,77409,113483,66864,14745,19808,12023,46583,84805,16015,17102,2231,20611,3547,95740,250131,34559,108894,8498,15853,159169,148920,20942,2813,93160,45188,210613,45531,52587,149062,39782,28194,57849,60965,84954,89766,84453,100927,16501,27658,165311,103841,54192,207341,19558,20084,319622,5672,205467,98462,61849,36279,13609,147177,24726,165015,209489,59591,31157,6551,117580,75060,141146,277310,21072,22023,106474,63041,137443,122965,68371,5383,42146,98961,113467,30863,23794,4843,99630,30392,82679,13699,241612,33601,93146,24319,18643,32155,95669,40440,15333,34089,67799,142144,58245,38633,114531,117400,77861,188726,5507,2568,8853,10987,107222,2663,2421,11530,13345,30075,41785,118661,104786,17459,12490,16281,71936,193555,17431,5944,71758,26485,77317,20803,367167,158,7362,93430,11735,172445,46002,11532,54482,930,62911,2235,23004,179236,4764,101859,208113,22477,55163,95579,14098,67320,162556,90709,156949,3826,57492,4025,34092,87442,104565,6718,186015,28214,14209,10039,107186,233912,58877,81637,55265,39828,6194,145813,50831,105849,4974,88319,122296,10272,197216,95714,51540,72418,23324,91555,8743,140452,250249,51666,34124,7229,38592,129641,78169,174242,22464,149964,51450,14034,10026,95376,26190,120062,14401,8700,265,31386,143573,7203,229889,61567,4227,140981,2466,72052,10787,10062,30958,6099,38471,30103,23202,208101,70847,467,58934,32271,32984,36637,24107,30771,17109,73353,13650,2098,157040,67366,66904,106018,265380,107238,18535,44025,32681,144983,62505,91295,56120,3082,77508,10322,63023,36700,81885,224127,16721,45023,239261,111272,13852,7866,149243,204199,32309,22084,42029,38316,126644,104973,14406,43454,67322,61310,15789,40285,24026,181047,6301,70927,23319,115823,27248,66693,115875,278566,63007,146844,56841,59007,87368,180001,22370,42114,80605,12022,10374,308,25079,14689,12618,63368,7936,264973,212291,136713,95999,105801,18965,32075,48700,52230,35119,96912,32992,8586,16606,101333,101812,14969,39930,759,193090,27387,42914,12937,5058,62646,64528,38624,25743,37502,3716,4435,30352,178687,26461,132611,42002,138442,35833,59582,16345,8048,60319,49349,309,47800,49739,90482,26405,34470,63786,32479,85028,39866,47846,11649,23934,29466,2816,42864,31828,7410,74885,49632,47629,111801,90749,19536,18767,105764,59606,21223,10746,76298,22220,39408,7190,79654,64856,11602,82156,272765,17079,70089,245473,51813,184407,384678,1576,122249,5064,27481,6188,25790,74361,27541,318284,45430,31488,620,93579,45723,192118,22670,51913,4162,70244,35966,26397,16199,50899,209613,121702,287507,2993,36101,132229,67345,33062,76295,118628,78705,52316,34375,107083,107454,44863,127561,33964,3073,154010,190914,55967,39074,6272,31047,5550,41123,26154,98638,47110,19998,148091,50229,31329,59900,195442,19106,61347,73497,70015,682,45850,25776,38022,148951,6288,37411,232526,109277,27286,32342,9262,5220,16651,23175,46740,129438,78614,121925,66914,88710,127952,5563,21500,34521,10739,14863,191006,62956,17359,16749,67027,56284,69134,43301,35039,58883,54466,60823,404451,75743,59856,86979,7923,34273,83785,32142,7693,268986,197428,282681,17049,22346,22990,92245,107180,3357,37104,96724,49153,7683,31197,43267,82231,164276,23696,20848,188364,22309,24821,158707,1018,22514,70922,27792,45589,59709,10765,736,35218,63479,51987,24275,63588,55361,92929,81964,4658,20122,12330,44058,13065,311456,72224,8337,211229,38979,22590,138478,52757,32595,133600,8838,31549,94412,43391,90056,1585,94802,127271,6223,31889,137038,132910,2165,57616,230152,6080,10748,36737,74579,134062,50525,180532,119270,34556,76155,82394,52595,29258,31435,87820,67996,26943,183878,38007,2410,13526,180297,69856,3503,187396,167700,7838,16701,9199,56267,3661,37407,65994,23767,5708,62508,221700,67088,86978,46776,84434,32088,5612,9149,88244,21685,95151,46750,189612,2979,506311,2594,3628,40074,105039,78243,28523,6651,38058,71999,30992,12764,68261,108991,6165,26450,61961,13400,22426,7490,60890,109623,2070,12958,50355,67979,257096,7213,42578,52121,35716,65461,7516,124758,39268,302,64712,14977,1467,219452,2840,34229,11121,21602,19270,63574,8024,1532,17331,79839,78885,52029,180767,57957,6069,91265,61380,55767,8927,32881,287603,22149,35029,68876,6428,199567,46926,13412,104132,21434,366616,45060,110046,81924,128910,45886,52821,130416,29416,77342,21762,67329,121432,79924,11724,38625,81006,102033,28338,13326,3250,82056,82526,38212,21112,12382,111495,3263,7414,86274,93490,40844,30224,45212,24019,48411,71367,24941,76729,57776,3769,38114,202019,197745,31953,237533,33270,201580,255648,100798,44741,32241,98468,106931,10085,15090,170358,33154,66787,18819,69760,25061,234005,82660,6295,131975,16874,9076,4094,25005,17740,40908,19533,220019,44330,99792,50040,19619,13950,55228,24423,31253,95308,103177,184795,28590,82285,5059,3210,75525,49894,70007,56178,10580,36051,139681,21617,98736,3555,106306,164189,37352,63915,47824,24883,145530,61904,28444,11483,19837,145446,30420,112972,85939,11835,191233,2262,20705,58630,1753,148334,1197,144714,6887,11223,107667,60879,77914,4151,57417,81594,96681,169430,1784,20444,95138,254041,27038,596,7117,72808,13759,3353,126776,21074,55322,27081,36942,39547,139830,179275,4453,713,8722,71399,19204,25785,22794,23923,104114,11291,25458,102309,88396,75288,230440,206396,104551,58447,130857,37247,94734,31548,176529,226077,65159,20104,10096,66881,94191,237909,27109,37404,1520,27421,25220,113003,23423,24884,50585,6286,231877,150800,11789,3226,90004,60642,5053,202400,61442,132531,175329,57138,30116,103847,9973,75367,16452,32360,59119,21246,10191,164804,23305,61051,37348,154530,13214,5468,50403,66754,130976,50559,80515,14436,155492,84017,5472,43107,41240,2890,90431,70188,382,76234,48040,50211,281038,237007,32115,142178,1536,22761,96429,1811,31243,1679,49143,55209,17402,235054,61494,7462,77030,34925,87609,78002,9499,9027,73289,201078,101379,63544,27666,5469,10642,30029,49816,132979,95620,58086,351930,116300,2110,2043,30845,6154,11279,16727,4122,2277,27281,4971,3650,39060,61970,65951,39674,75686,38151,11370,130809,177895,32665,63725,122267,7857,39618,118483,44792,157755,178624,136994,24260,41308,22471,12404,21707,12486,30473,52781,50246,20247,39065,909,56825,103158,128603,31542,1089,41935,32744,12428,37963,84420,33134,72921,208449,42622,168151,127335,147107,46699,38216,12591,94342,85814,31423,24944,2605,87542,67473,192551,4496,56321,91819,17630,6300,256183,114569,202090,33209,35289,34897,24967,40520,43470,5344,10199,34810,14283,10381,10017,62923,49924,23233,64539,13051,35686,19698,11570,135555,120868,44924,87065,52318,52335,47586,140906,245885,109834,78668,9065,46990,25258,72022,61243,40838,4545,146387,10537,11557,17470,36930,68104,46711,24264,79401,81043,18225,120488,24746,84338,81652,28266,13776,21878,46973,1047,230465,73357,95777,24973,210160,62210,58404,110633,169651,6937,41870,9909,26822,191062,76553,27519,96256,239070,2478,205678,67955,58532,20601,50120,19148,78501,195724,110740,8249,109665,27446,30568,57631,31425,49752,32820,65504,50079,3663,102256,219898,23849,211315,14645,4359,91767,9528,12449,49366,7941,49763,107848,8930,27086,50686,9744,10447,81935,39513,46514,1670,29229,6172,22312,137280,97759,9806,14445,22976,56458,73391,34983,93760,174219,52573,33149,59747,2429,136277,75123,165263,91040,7446,57632,48633,97140,246081,84766,151684,79918,93268,120346,54059,54875,77858,32996,103590,45276,11968,19600,25849,17159,132907,42828,16817,4913,99462,103303,27395,5737,74184,20749,21160,14377,77062,131403,158735,10999,27799,77785,9320,34366,51593,61070,33746,47048,29268,36675,30262,53297,9832,82e3,20188,122292,39917,7331,18160,68301,185935,134830,15031,4935,10004,165845,185534,46923,30109,44134,122631,18874,22903,112790,26561,18549,348902,82871,140345,255565,135390,63556,103747,145055,179600,145662,296111,61661,211987,23952,52342,126343,48450,32919,44277,82185,9591,62139,205363,376969,394874,108461,18040,120885,14798,39863,16571,16794,58271,81025,55206,14640,118656,6361,44092,85970,6262,153863,108244,180200,72264,79947,38044,10050,5735,61221,80712,5471,115689,11391,11661,184257,20010,60116,30320,19327,134598,45455,27542,18004,125092,452272,1549,91523,46567,180063,156026,2608,11174,58848,37788,65907,80194,30490,5786,40775,119519,106241,11323,156297,8425,61495,2617,29675,2425,59886,112582,49142,59618,4863,50597,86710,50650,168632,27693,85641,83643,18993,25768,84284,28090,93592,36627,312804,43381,9887,9402,100931,97165,3311,173330,66805,28935,4963,184460,3201,78102,19126,21607,37496,24938,22615,16153,32862,134792,153318,61120,6067,2812,12826,12792,23825,37559,64662,202250,102694,155488,85881,149193,46233,65383,15521,106982,11358,176786,25752,39717,34208,24510,32464,77742,39371,72028,138229,60688,71386,102834,132477,2208,11548,63670,271279,28351,30338,38620,32491,99845,143885,152266,13252,2825,178663,108097,1775,78201,14897,113573,163346,62292,171129,22183,96598,38733,64971,166776,117445,9968,146393,44677,74867,20908,97328,12761,25656,26785,9148,112344,26115,99176,110121,22437,49547,6180,79320,5835,31392,43328,33377,75870,119860,69497,80273,7325,155219,43167,111173,28347,20222,3763,71752,55041,47252,14618,28088,15012,97805,194698,54636,2036,41349,6173,96604,61530,51859,43782,13361,24334,22668,24792,7070,23441,16789,3209,36211,208475,26242,32880,122181,182407,21444,31060,88459,29929,77907,12716,10934,97005,20599,31690,8403,58445,30303,22700,10336,86731,103115,337709,72556,46788,112566,47684,67089,53548,36874,56487,41387,125985,26893,40071,106683,73712,18787,40105,72992,67246,137276,50802,36790,70328,138827,22466,39263,183295,29858,50975,9322,57397,10654,24364,30383,55799,41600,23584,127295,296610,129078,143558,244131,86397,36049,1085,80677,3820,108139,5476,34767,24683,7758,13060,7239,131671,250593,59556,103392,29810,4188,252323,39404,116877,7651,43600,40338,13554,157253,39196,25978,144387,61211,234,50104,6129,10449,93777,9240,356378,274148,4439,72970,3724,147770,78680,62570,115877,40027,40547,36817,224392,64609,34795,165027,67440,2477,37206,23431,50754,164797,46018,94995,170982,27051,7957,22767,3674,27900,56419,18930,60701,41302,2692,84749,339721,61996,111094,80221,50129,1045,8153,62945,19202,8250,37208,37418,32560,79477,41106,88569,33963,36693,5892,30570,1581,66471,49647,11922,160717,29442,5643,114865,82962,95982,132098,22633,22838,94726,54556,28566,205039,162340,33216,16849,35847,221339,94851,26533,71469,1805,3804,12935,45483,71020,36310,65381,192960,34240,35165,59773,1248,46954,155332,96864,4246,388800,16129,57133,74592,44807,442014,38203,42574,80818,91592,26377,36424,65760,977,77387,22628,147610,28018,30561,98454,6969,119628,63648,18170,36854,26601,64018,22027,37279,51395,152934,21153,9430,58760,194742,5330,55115,34158,28917,174111,13171,122326,1526,43896,66094,25325,4234,148354,11450,275,18999,112191,44365,22723,68409,8733,57746,96565,75007,14196,108844,29475,88599,177563,100792,106156,86323,93726,14248,135341,194131,40126,47099,14779,8272,39597,95983,171398,65882,28052,10393,47213,40689,22120,72212,106829,34964,109146,753,648,21660,30047,17527,181025,5619,145357,4085,216883,9359,186951,24779,53931,24545,36197,223296,62628,168101,4243,107313,30321,26642,13049,51059,31027,107912,807,73550,26551,84369,122422,165872,49754,74213,234264,33151,52014,33100,87183,22365,52500,40013,23302,5652,72723,21404,26107,48434,587,94049,168493,96418,32871,70860,31709,25128,443,71597,166253,15670,70994,26341,133675,28280,75491,54756,47955,56028,26182,11952,113272,472197,64640,110753,17919,337,50642,22576,142,87371,53391,93210,126694,15285,19642,85667,14148,1506,42092,52962,33243,11970,20734,135843,57044,58880,13002,219134,22876,64754,232519,4257,43120,321573,24799,64526,124728,52579,81472,70831,276848,17403,74359,23021,182101,74597,23744,148267,12055,7976,5349,11772,67540,167347,65318,18720,127832,108238,22828,90233,9987,259080,118185,73209,79270,13775,90100,137742,90799,70569,15699,19961,9087,67475,57872,39731,8810,134897,131868,146849,19898,3334,2281,167061,91073,60356,467742,74712,188,53179,137679,92769,29241,9537,132595,80119,1041,88962,5976,40171,44911,102859,139059,104558,98987,47761,19272,71472,113864,175377,73338,10857,23402,23758,1591,139864,5644,4076,118760,16427,134198,18853,20291,100849,37423,22038,36677,19071,195521,57445,11069,31869,55718,66882,148490,44,41296,75242,49704,166810,9906,20943,122258,49112,105667,15969,10344,6408,187694,21399,72742,58970,14867,14376,81889,41856,23225,15042,56993,16074,131389,74276,72407,53875,383108,53597,37363,68993,44854,122548,430927,198279,38430,80409,12245,2981,628,2818,17760,37437,238229,7968,46892,2200,3730,34190,65983,37959,112291,87850,70827,6522,20750,73913,111621,41652,19587,2780,58668,25916,85259,18200,168962,95781,42445,102050,7776,57662,103313,47742,96358,41964,66174,100396,29069,204735,19679,27978,7479,40264,22534,61183,36081,107436,58223,14680,23002,101311,24716,124108,12908,5646,31750,40380,14215,232799,102772,14122,96775,61398,50917,12096,149880,67833,598749,124194,155871,49216,790,14677,65319,56917,7440,145744,95701,12206,49405,129269,76199,45732,9767,11058,9047,210885,11051,7392,26307,2130,8132,147526,20802,232698,115660,50060,59789,57344,107623,80343,112676,23291,9866,160971,34032,118291,15719,59730,164911,28975,2659,58046,78480,21854,66209,53863,109085,116045,29021,46481,107552,22130,18764,70254,31272,11300,52460,43933,84738,20721,53869,190840,79673,105300,7561,321817,66924,13940,33281,101046,183181,32176,71878,5678,62924,79535,56646,40303,19559,27703,93042,73368,42187,3670,37376,46440,7023,36816,109628,20680,5940,276440,275233,170848,112093,136996,14984,20226,111441,77693,112960,48577,39370,55707,50314,123404,26570,54281,61372,123391,4857,35928,246740,132507,106646,44241,7196,92258,9825,37688,51197,303141,5590,15476,132986,10955,85782,34486,26696,7991,28813,18858,39546,11703,11365,38185,5716,93555,11925,40121,60002,6985,10976,171384,3887,43394,13337,56346,6381,252336,39573,75042,53711,1028,31781,44295,95925,131713,7214,68125,43571,70954,213234,1628,8760,13391,65485,17320,56038,1710,25248,60803,57399,19839,3870,326,281556,50945,72400,21460,316244,75619,56246,98775,481,13513,55765,50427,7388,123519,32929,57908,27124,61316,101097,57467,30228,48792,10788,20402,37318,50526,155730,34456,158065,145305,17832,43733,64052,4506,35072,205355,177028,184004,187081,68616,35938,83703,10367,36892,93186,260137,51934,89970,4985,23445,26755,21558,7948,78741,23376,124405,85594,68596,57536,49351,12619,56593,132668,99924,109728,71844,71935,196018,65464,17617,14987,89701,143773,33997,8687,22701,33258,2914,4436,72108,85610,9671,49067,2327,82988,1361,1672,44033,35777,30269,24057,10605,82236,616,15793,13919,47249,112086,116698,9484,80207,90574,33304,68624,93127,56101,42210,160929,4827,38995,38095,4701,125119,5027,33680,9236,231236,14135,87837,23318,70261,78893,30151,81482,14332,1084,74256,27532,46644,79185,3148,62615,6981,55672,31668,36825,1849,14536,37446,14738,23779,43058,162749,72199,1168,21346,5592,85932,85302,9668,18351,57135,150360,2080,228015,77953,34670,119302,151751,31009,106725,84265,45214,59289,74178,113071,263206,111009,4021,44449,188119,192629,123592,392506,292847,114487,12831,205858,9852,20780,79648,75767,357014,97721,18166,21005,67950,33226,204009,16536,2987,11335,66717,144910,47950,17262,55060,15063,2934,51038,26775,178497,66008,3427,49433,128592,20036,157553,63861,3089,23015,51210,28696,35933,49942,71135,231518,99620,17248,21835,176536,20676,16944,38700,165831,233253,295625,36723,13023,52745,10907,19423,67972,125868,95473,82875,1183,108455,52685,33417,64095,21433,52438,33191,127809,44505,211823,7810,2752,95548,162031,7185,91196,47563,61721,33359,17897,23682,42806,178101,22874,49707,199897,75419,82456,8618,11171,79712,116847,18783,44190,46564,5346,59046,95032,7893,14916,3214,26800,24172,121453,34362,10250,17408,18888,4840,68696,22831,13162,36005,32512,14800,62357,41723,45046,27247,37486,5372,2564,34261,298500,66509,133920,89138,31305,117697,19097,108304,81386,84106,23802,46411,63304,946,51417,41777,41041,19501,115864,60743,294354,37955,94165,18116,1156,17937,20645,57114,90804,58042,48643,92288,9861,2557,88546,61333,101008,12853,5148,87856,4152,144503,73841,18718,9789,147565,10846,42085,12789,30223,8993,56352,67203,2448,28215,6052,23540,126319,75933,36689,80235,23231,23561,21383,38800,77548,102798,21234,31468,158608,46188,63960,191679,8051,67014,11185,170078,42186,28827,34777,41930,212079,12421,34750,24111,110344,73918,45171,70826,141949,40063,23979,24254,37309,26724,27179,24718,83648,54938,14591,17425,29525,102675,48975,48654,12316,8929,60640,41709,50168,63264,89812,50716,48632,38755,138583,160123,55579,71829,24230,233277,46322,39650,166388,34718,24108,98252,7031,106695,62498,18258,35062,217827,78731,34824,33354,19520,60852,2432,60224,8587,2836,62955,702,20227,42285,40560,95592,62486,11094,53035,143291,18842,46177,77994,1770,9657,107422,172915,32655,128716,25886,25164,156740,119928,165875,85817,11007,89110,33956,12652,65156,180266,8494,36889,19958,20955,96,1264,118288,135769,44754,86671,5632,19026,168220,289120,33569,93821,66144,70635,7687,5642,2714,55445,56636,71545,184182,93133,7332,37389,12643,52315,22729,11014,158742,17050,152889,50178,34601,41945,52136,9948,26914,63548,95721,115951,40759,8960,158258,38938,49232,48325,42234,81523,253019,66128,40978,20048,238048,38760,62928,122560,118532,43687,137472,163689,26680,9878,17448,51035,16211,60834,36749,29178,14241,59868,150086,2305,26477,42422,34342,165341,83279,33894,14257,29928,12743,13957,125571,89134,66712,10952,16507,147839,30146,7249,16565,45399,39874,114565,215780,31990,230881,171477,102,196546,44538,10880,84948,281705,86651,10617,31395,2342,453658,43569,60561,132901,21845,17727,58556,258242,22262,58728,4008,77997,11806,37431,30599,81375,109137,185787,114085,217292,97453,169085,30593,60212,11544,102056,65580,2384,91655,4855,95725,7295,157994,16228,20669,53276,141590,105246,17334,25440,76067,17967,39321,38911,11362,28559,63807,21627,26468,85816,40120,1025,15234,58319,69516,66512,124548,75845,78873,22137,46681,51242,85683,32909,76747,35555,43396,101465,1765,73094,1077,2962,39028,66777,57831,42048,15828,13962,36041,63657,52412,5242,58846,2141,5506,219012,134451,3936,182230,17558,17153,152237,22621,49377,170216,35257,68233,65374,6510,11126,212151,7184,2480,22517,3437,33073,30156,16557,3768,55067,86829,91e3,12350,148650,66017,79424,70885,49066,28250,21369,51213,34533,11510,3258,18176,18465,84413,6315,36411,163765,4346,356,107618,598,13727,285026,162695,8749,14583,7132,63521,184253,32378,25991,5604,30961,53675,4874,84693,5086,34811,26978,56564,7904,33519,51221,113942,69253,6664,125563,22055,220680,102008,742,51930,19494,176108,44424,35123,13025,75685,11759,74335,22250,181453,131147,16984,132115,154311,11991,76452,52609,85351,196,30969,9198,74919,2529,56838,71779,29187,116304,3504,62330,41190,86153,28393,254926,104228,105189,13264,84359,3574,12415,8534,57147,10175,188174,59504,60932,66318,16407,107921,17638,99103,49278,28403,39786,145865,8462,3558,43406,142271,29139,21989,36552,93955,72365,7176,13556,106185,37957,321774,17782,129017,51154,27938,24952,1935,39366,2791,33489,41582,56078,24558,9311,5449,218786,27808,190429,68013,36020,86003,29735,3404,87348,119357,115714,2324,86796,81973,40992,43376,93621,28784,16808,36367,2517,2909,191926,24978,55303,53308,205724,60068,3098,21375,64784,23949,26579,63121,12319,80145,39967,97861,6757,70143,67642,37082,34698,69140,122883,46151,62187,80934,429,19437,135071,137885,222647,13331,154065,327,61778,74257,40116,37493,14855,85079,237641,42342,102164,199965,71204,4662,29368,5042,113914,122214,8955,13149,102503,43173,5659,163787,69003,307084,63392,171080,21390,81918,86666,36622,24126,28887,5736,28054,207170,163428,79891,346467,95363,38980,111806,80828,9200,19288,294896,114468,87405,111715,141705,7015,72754,68463,48738,243147,33397,101210,37051,98801,82847,20397,4940,185559,18716,54718,83491,11725,40803,1128,12128,23060,5174,7745,67007,46701,1571,27807,180186,256996,18975,16837,7877,212758,250379,15440,87954,57755,24719,124057,83461,258,50864,8874,29038,71289,31627,15429,9005,4061,113851,107716,82819,13651,79656,117851,17539,111446,12938,39724,190787,4352,15402,21070,62708,8539,23777,73853,13552,38810,86117,16285,56400,1718,75342,142863,29033,378,110113,180321,32586,23606,26393,160984,207987,23783,8406,16904,24596,47274,11693,46539,60524,78595,48423,31718,20170,9009,146268,15183,191060,172765,1349,138436,37365,10970,40509,225817,20021,70394,152138,21541,66559,66544,89352,2725,17258,91345,7313,3815,115868,8660,40362,4071,103524,39388,118275,21950,6549,38226,32754,209574,29201,43495,18028,20296,40597,18370,47520,202450,24134,2219,8195,69545,38041,136934,46374,19041,159811,84865,58620,846,98749,13569,30714,97246,32186,4479,27355,92973,35214,151491,75963,37631,1561,27200,238083,23182,60756,12291,25766,39355,102333,87362,65741,59906,19538,201575,48772,102938,24438,292580,39964,66366,9004,61379,50548,37622,38732,28379,68180,76622,17488,69849,5963,7219,48143,43413,55358,540,58691,29506,19245,52193,48621,5518,13048,118625,44755,191081,42061,89197,2259,60665,66994,71210,51232,3585,142096,55024,7892,8345,58653,463307,65658,64319,137941,136323,53499,12746,43492,6978,95163,29925,60175,5128,7352,41463,184756,121146,20473,18426,4598,5309,54580,14277,121151,10691,56711,43880,63409,76682,11830,172218,264898,32632,66536,81062,31649,25788,92774,60222,11100,63159,9432,224657,25240,53613,152,138620,163829,2397,85345,12501,37507,64932,38575,43522,65789,80198,78796,35226,3851,108891,73311,3060,28391,93671,39663,46142,30982,66041,37281,68157,26553,71872,81142,211527,39747,118119,22695,2859,11066,20232,168911,7933,197005,17066,111071,44434,133994,120798,12766,227798,45756,132852,29917,36076,55352,65281,129800,41958,18944,84678,18580,168093,132621,39997,54092,27740,32354,3770,114118,103242,43918,15899,18574,145944,3190,123469,219903,24169,100571,62403,16776,92779,14535,17168,16475,14304,37231,1712,28218,242754,61688,28980,1318,51359,222657,99200,67989,31772,23932,35351,201251,49041,27306,19128,40135,3986,77333,19649,120683,151927,21081,7076,78375,77501,101599,8011,89585,96715,58179,5378,102138,106793,26051,217276,4197,16297,27014,46721,13322,22806,5278,29629,70632,9647,71519,58818,40603,128530,8903,36770,56900,31483,26935,43845,34265,34920,87658,6114,84767,64250,47318,50720,19264,162514,33357,13117,6705,46696,75032,71054,87004,42035,69138,11903,99854,102328,19611,34525,69312,6431,49842,101600,133178,108751,41829,89939,225664,48916,99556,9195,130387,5960,36857,116724,53518,94002,39077,53996,6945,22261,64291,8314,152785,57588,16522,9091,5048,87671,35441,39509,1945,12423,158923,178413,37549,14095,1475,73188,62878,4819,24012,68534,42606,4010,120809,57497,59564,101758,103718,32701,80116,12345,95834,46918,21468,53213,15665,31200,3867,5140,96013,250744,21016,10069,13968,35449,180829,27683,39704,59956,22893,3115,26293,32785,75934,62445,141162,62720,2018,83638,19949,114012,95006,3330,99829,130935,309272,9565,55874,121727,37017,23586,319858,40970,27602,8625,112329,61060,100088,118525,25922,16232,1907,60671,51583,44553,80993,5262,94679,8676,940,20736,11823,3020,16476,12340,152600,97416,3703,25744,66826,16245,16876,46446,84798,74227,176020,45192,61955,75496,23946,23626,40372,26036,6149,11822,30582,16541,41914,82385,232823,40921,80773,14930,3631,7517,39619,4348,36180,126106,138939,62611,1477,113512,47321,25052,14546,118881,29060,23589,128322,36795,18401,137921,104699,267929,36194,172791,18113,4766,188215,30083,332586,94089,5805,77909,22194,68234,154976,43220,40660,70001,184893,138095,11128,103010,22663,5108,212615,8485,5565,49222,54614,26530,42639,16319,55062,152662,105595,21114,22216,10294,68158,10436,86950,7206,62115,3977,3657,59874,456,118617,18156,106663,112229,80992,17442,8217,55551,5133,34344,251927,51153,39364,201321,7816,66803,23057,156724,145664,14276,95705,979,2796,6875,13429,212525,50602,26276,28284,3424,19465,52397,46963,31420,51399,206476,92317,48851,637,100820,83349,10317,60227,21972,6908,282439,32857,224767,95629,83882,42106,87338,69757,29840,68709,37665,45244,114577,49188,175943,54009,186746,106158,70168,3358,234002,50555,9221,129338,9562,20118,32923,78479,118280,65752,4977,10474,102174,60947,129006,10570,83451,8598,8078,159367,123785,80438,16742,5905,5281,181513,42402,6977,163136,93179,42191,14968,50421,112401,105440,33456,57347,121611,4221,94954,36517,24046,27796,6255,33394,72990,135408,116627,1233,57874,25654,95419,68156,401399,313338,55208,45573,93124,119251,47200,38196,11909,130667,45391,73904,64964,167846,4137,115606,52036,62214,7969,160925,7187,1132,134835,40309,73195,64494,80472,444841,61111,26500,45323,40743,53625,52797,22659,15631,29739,36706,28841,39147,102836,26794,10536,14845,87305,45874,12241,127587,83833,57183,79722,30844,41304,84655,20825,92500,3722,25655,27811,10157,81634,31362,34088,92487,70123,22190,185100,72658,139035,192523,88241,2078,230490,44528,85638,100198,22088,29982,291233,241062,13865,4445,137791,37835,107218,31726,19718,38234,72528,23046,19177,66695,5109,17251,28077,5617,21554,47839,72425,133825,1486,73065,181275,141508,21768,62971,63082,2512,34200,9904,120309,6392,91243,68416,268253,41199,116757,138551,185526,41246,28986,4093,19057,17295,4148,245766,122360,35356,112075,20301,75441,10998,7977,19769,62922,937,63547,100196,26427,157820,20983,236696,22935,8140,90315,156004,47204,140973,7726,45097,52725,22636,23436,257282,105247,522,88389,216031,202204,46812,211666,19693,68828,81691,45925,11256,30292,372,5236,167826,88328,232776,151611,5360,82104,18841,80393,25465,18285,20320,72377,31730,33160,45803,38715,27705,37379,24163,18360,103586,4015,32305,269494,91252,20080,36567,54650,7797,57073,12650,31164,42209,6375,261663,105528,81661,106002,2800,5375,17247,43151,4442,15727,194619,100855,144898,62320,78465,39929,16454,1967,28311,61363,17219,9395,8745,121445,76939,80385,162380,22009,54191,44248,16299,122830,48151,74429,78291,64755,14238,44966,2511,17712,67954,93583,829,105899,49935,84750,11591,33185,85447,42717,27409,208542,28965,62052,52525,5597,25694,65594,16343,63224,276188,12475,9331,127507,38522,57287,24128,133161,79723,105548,133695,48917,27558,43278,46520,13778,141954,110785,83366,17715,46317,105763,66298,147013,41086,94180,16478,220447,44611,730,19722,78975,117889,125643,26254,16574,18480,65006,15806,38549,246418,46052,36056,8440,34984,30170,3163,59800,4458,115442,4283,41970,33507,104078,1653,22,121158,276486,3655,6338,24048,133421,23641,2161,24422,36006,8086,10675,181474,12307,29514,59143,14729,52509,87128,122470,19446,80852,33314,24573,119864,14237,9652,57779,6612,51851,15284,98871,90581,124466,156831,21190,22015,71380,161906,87247,69201,18392,17908,108470,72962,40719,14338,17911,95260,43339,20610,78916,20710,72451,11315,31448,17263,58853,178878,48111,116002,45497,80506,82605,85880,36300,121755,25215,36118,301929,88728,405223,276136,553,34704,212438,49970,78329,922,20711,25036,257130,38295,145369,18128,15385,30829,55656,48345,8012,3561,28004,122041,192900,58338,112508,41085,29976,87040,47117,23905,4336,92061,138880,97407,42083,172121,6256,25192,172671,5,93568,1420,12677,31605,56743,40620,6015,78415,231077,31298,80026,13902,19048,24924,170586,32955,176119,87859,36731,6773,27711,24658,26475,115216,133207,93250,95820,88522,8317,5714,124047,55219,86860,19677,23961,22928,162209,8904,225992,359835,56084,96201,29392,96558,86071,93643,55114,13347,8183,95129,82012,2017,123336,34219,115554,157159,47747,101684,41008,18735,193781,104151,226906,7552,179874,124113,31159,21162,44010,14771,51268,166128,31382,73124,77438,92830,205709,12113,1292,38937,13114,1334,2118,15597,69581,14449,21934,76618,48728,67038,14967,51495,24243,87736,147249,26720,11119,46063,43749,5843,44147,152629,133428,65703,14269,45604,57982,28672,55616,45957,8438,95433,37698,220862,132034,39456,61870,4161,26501,73560,56418,9845,4654,20916,10456,88920,119358,9015,65931,96507,48029,38534,21676,109081,43078,34943,25089,6131,28766,23665,5477,10255,16695,67,45778,42443,42770,29534,23733,100513,62617,42630,48746,14191,43753,50295,26007,8792,57243,43119,54725,164253,58250,112304,131796,25165,4651,3188,24831,47748,3705,19540,13211,102095,5593,18699,23666,32005,117571,33541,60584,74573,86311,99443,25172,27222,168938,7143,11853,53560,18834,19960,86522,28217,53266,117700,72989,34323,18721,66450,34346,74056,47217,202002,46269,9429,68582,75458,37823,82843,96652,32549,145144,27958,19820,158086,31955,201406,135379,31207,192545,12950,51704,9094,248263,76147,64028,110009,79407,89345,99284,223492,47966,26848,15359,201137,2861,110507,71231,72297,31851,118777,71039,151051,240855,16333,50766,14727,7939,4149,80908,418780,88378,59276,1327,7284,38576,79814,65820,42199,84860,49574,62596,12396,70598,40117,8648,7994,16836,7630,14047,359699,106878,525,29037,28064,13380,11675,50669,74216,103539,180314,27449,56299,172344,19274,7301,246099,32043,19422,36506,129317,6806,30140,4614,46639,66926,932,86600,6322,27847,233103,10541,39025,34887,3517,12972,26220,2031,66561,115015,48658,47596,12714,33845,3893,16165,35237,89983,14769,11962,147224,47018,29977,27979,5552,82338,86023,131368,1218,24853,237840,132193,15455,40873,3668,65351,53388,15229,59889,272245,47934,11858,34347,18038,90853,86981,300602,19343,114181,29362,84921,6095,106059,79472,38015,1206,48741,6208,8e4,21916,17423,6002,108083,24479,34931,56661,9511,26995,100694,163853,35997,81254,58321,18919,171890,86877,91341,74503,70477,53412,7027,59281,39892,131302,5864,15947,61301,67466,162369,47956,27874,35624,282324,21270,111847,102548,41482,30955,116737,28264,8592,55458,22301,75090,29821,30697,51709,3041,19208,8038,24634,30467,87509,126428,19389,18814,152686,20701,83474,45832,80891,105808,11378,153223,120770,98186,150633,49838,9141,12755,30962,5260,74490,21256,31678,65062,33326,289838,187831,20595,89768,2805,58535,10844,70085,12090,2451,138068,98544,24461,4511,6754,41684,28203,3383,65355,82833,30161,83924,234361,128424,28921,222594,33975,125491,34069,11508,67464,144226,41850,98703,34371,7901,21254,38398,65651,23549,53883,213340,123269,12028,71764,177701,28758,2623,68395,11549,15232,68603,9660,63116,36079,57093,31198,20475,48467,89984,35619,186847,107469,31389,43631,73867,41949,68841,114250,1605,30564,63403,17588,27680,99533,12641,70325,50428,73426,78379,11855,91651,72081,91720,60198,15743,12065,83398,140046,6761,46598,45900,5068,886,62448,148968,37347,19405,9680,15819,43496,63370,75667,163700,37639,3633,22774,34341,183131,134335,37200,23915,7054,14194,12970,26438,13350,285521,25594,8219,104410,91039,168804,138480,149734,15907,33818,61132,60082,4622,110187,56736,13551,73571,3945,73463,65498,17758,263266,17593,2710,27585,54469,38200,45367,63754,28881,3473,12791,98287,31895,65787,4463,94536,24951,36332,59901,28803,52130,86403,7668,181822,74831,18977,9850,177206,145485,109798,7292,31421,26280,77211,58511,12507,127004,11113,147,8729,56208,43066,79926,129937,31345,83947,39915,46146,98763,42566,1337,13192,18323,105163,80570,117753,16555,72883,11077,159438,40764,70933,83329,26066,12276,72059,21655,173836,126713,69454,153482,91585,70644,102558,110483,6764,127864,190133,3961,101798,20945,71138,82402,90884,69669,44753,923,16939,59700,164258,25969,27082,31399,43846,6306,246093,51342,6153,151581,202801,182731,56475,162188,89426,141356,14355,121815,27536,28023,65257,77523,106668,127314,24947,12790,38796,169698,23555,10725,44573,183083,42088,62716,43265,105958,32050,44067,50118,1668,3874,6243,318411,16599,1691,94999,52378,28671,216728,123258,2059,34969,69225,5913,136280,171443,141515,91662,22175,135282,80020,92270,1663,4808,4482,3495,34691,5226,109830,108512,17342,107488,11606,123190,100247,29666,146527,113014,15794,30894,13224,39585,243192,22351,9903,7836,47699,11078,25468,122291,48821,26780,122679,75521,81450,630,4895,92900,55074,74293,17441,3563,111657,103102,51613,12318,52370,36191,68245,34269,40445,41354,122901,168604,182500,62012,42557,11259,24428,115113,86345,12362,3909,78430,86852,134602,20459,47853,93879,22577,7659,3688,38555,13349,17381,56715,91639,12493,10895,92438,3142,37057,28928,2004,36427,32268,34222,209974,10432,67436,41989,173518,107930,27079,62729,30908,55558,5828,45031,14902,53546,8204,144263,60255,14520,88212,86582,109589,69356,8064,47449,8505,66558,16886,4844,52817,111260,215129,12941,91118,650,20770,6273,73089,40618,62790,2873,35002,14023,97208,19386,102646,36993,143736,135457,35385,113601,17893,32627,84439,100619,56016,6581,57264,172160,45452,111710,203627,70131,24100,322787,1996,35665,70078,22358,90922,83658,4097,63200,58499,14542,99153,52159,6615,12414,63415,31986,16823,1579,65405,137809,8841,16898,48082,259,33014,42375,12260,179850,73667,91389,98882,29532,17311,326251,41092,5928,20742,44964,48019,43505,9317,49265,6643,192712,48424,163487,19861,20113,70848,31928,105333,23685,78563,14638,54755,7158,24142,44018,20774,125255,20331,24280,10163,1285,2336,39851,4299,117269,46714,63816,87779,159624,11731,9971,990,137317,108831,50994,74554,162680,23640,131597,146962,170620,34829,91205,21184,1913,63616,18427,93136,156592,17519,67565,115882,138220,78622,88535,18115,2711,33554,109492,54298,971,24914,25863,36363,45715,27099,194995,14299,178181,111488,72395,322385,157719,130787,11897,81843,83999,11369,49280,118604,40922,61332,110343,53407,75639,40582,300440,54722,25637,13694,48248,48278,194521,56203,52779,48783,72627,10953,376,16733,280238,26351,230789,15132,25168,137270,3588,63704,73376,94031,74284,19443,159557,9697,39901,13351,119050,15406,146455,3460,29556,75195,37673,102524,92329,47289,98413,15311,100684,56345,7116,95480,11590,7200,167,23610,58426,17730,136656,27944,53151,2701,8824,103124,3017,90744,113588,53216,79736,65940,26931,498,29568,80540,143543,21292,1740,59268,16561,180816,42323,50174,40890,52866,10703,57169,4700,17191,4424,93511,49698,166650,26972,48631,165169,82879,69326,202970,4007,2376,231325,139592,22119,62851,37504,68816,58345,67398,186643,43331,277416,53749,15746,23102,17432,4793,151138,48822,54265,48203,198688,14305,54287,2291,18018,113378,123260,7180,97549,87027,120085,2920,76080,8190,102005,5641,64580,14955,59802,54028,58884,19367,81779,412567,85957,97053,103637,78871,29364,27637,141728,4767,30686,112738,130146,42745,12730,105040,14844,232,210944,36581,152317,135543,29744,3129,55647,58149,46319,27265,17499,28005,59948,7170,34138,5702,293047,110892,408,91760,218674,18469,46095,81403,14389,4610,35672,73060,11006,74848,104820,118143,190357,20043,105358,141735,5115,27093,45924,123073,52599,29433,9616,238350,78610,24851,58858,26769,31969,24613,18294,4982,32735,39639,143563,112073,202205,12567,4873,88601,44897,81503,101648,81362,34662,85277,17574,48173,21435,221188,40215,39576,80786,26544,64668,81841,10731,37733,247986,149188,127703,495,18382,54388,72446,43071,30974,198723,89608,41360,190,33045,8386,31658,19992,237838,119015,137622,50890,100913,6460,116233,267230,26621,104129,65114,14190,41542,14888,85962,23342,23041,26453,43725,71809,45186,4770,46452,53894,56616,221286,18973,9038,109299,55365,19366,26863,18808,60909,69353,41738,83463,12100,68561,72860,3980,13796,49340,12332,31311,27418,4255,53430,18976,45523,510,14224,30477,26581,4530,3651,101663,139840,22709,150861,31996,63923,120623,262522,3076,10528,2929,14672,130238,18087,9816,121894,100308,25085,55111,14565,18952,53293,2042,369988,23674,61789,133529,28783,108293,35477,47119,36448,71049,40015,33055,78598,198442,1833,159937,40654,77444,189245,113153,8621,18599,38553,35223,166072,2375,11659,21786,89523,6032,12116,63046,159398,18454,3678,32521,47626,11411,103527,38896,42946,15696,26370,10185,8413,37080,165583,4331,63555,14907,72220,50056,6623,62236,36565,49783,10049,17503,100581,55951,146244,24724,9626,17969,25524,109300,173965,99994,101056,46459,43647,53737,277968,8347,123521,74858,33829,44762,77574,877,81377,222525,123532,30602,43881,53145,2973,16284,81940,61281,127044,63620,9875,14756,114829,19032,9202,52759,119141,23928,120551,19607,3599,33401,76821,73233,117430,39968,36539,7071,5446,121735,194059,15206,45283,6706,15603,65615,1207,165723,92275,34773,104447,8396,32353,205240,164323,13600,60555,79205,25532,22907,33410,57480,107111,69630,32137,47832,70913,33161,20321,2371,117348,10714,86246,1625,11763,17900,268,78457,99175,97940,101092,86660,32221,14041,128504,125080,53744,124263,31017,13897,403,31859,21964,5633,111630,5547,77329,17961,18241,84995,25984,12983,67491,62168,47262,5241,297,51191,7351,8967,147212,82060,16821,782,11033,82431,62957,5026,43459,77963,203477,53528,6247,191852,87774,74164,215654,13467,1522,219964,28589,244104,16242,117821,67725,72570,156792,17186,15979,26990,44128,193014,35276,57125,16212,166451,68017,6905,77608,16364,53777,75921,76426,37975,26203,269296,64099,84122,12077,38533,830,4407,20139,963,43028,38902,42911,37503,83343,85045,16979,1165,60835,137387,58380,86990,110066,134540,56331,193845,81238,17922,163093,38744,110641,12502,56404,34862,26865,125964,12965,111648,25547,7771,27196,136980,9555,29551,107158,57885,18831,37705,35505,101742,13970,102109,62548,124657,23328,11124,89592,146376,248050,6241,22033,18337,80685,29898,11908,216623,67721,106162,146610,21377,15085,91552,42041,62560,122532,125336,102365,121537,142559,29693,223919,11515,110495,18776,22494,5895,185059,103592,229351,51220,100102,37027,257855,29359,54123,36066,106493,12244,79258,32002,432,56205,94836,90182,6726,14762,29391,48938,26864,38083,60364,3310,60192,14766,205567,57504,110760,22649,24666,46333,21517,3430,13135,28873,27052,158809,11597,20529,6695,23138,22960,37137,45574,6545,305877,43423,26153,24769,59844,14501,10430,134352,56169,13213,103432,49523,35181,13435,12408,129475,64620,230854,77390,51990,15653,83248,33466,44571,117828,51481,2187,10559,68019,18021,54895,48247,18354,33737,4554,108595,37288,39767,116707,9175,3726,108877,21616,83684,49862,1938,8543,276466,20134,108498,48770,102254,31914,131520,185291,100559,51890,209,19526,76471,50544,71814,99351,8172,198526,28816,20419,9109,98389,136777,76479,75596,30635,165417,48216,120220,25955,211071,39314,24308,32164,2559,146280,43403,9233,17947,90585,1786,86920,125662,2457,64741,32152,32918,122882,78538,44001,31723,56426,23375,103172,88177,145697,52506,49319,68016,31664,41488,18486,110400,7030,28241,986,109199,19900,42147,56864,65287,49183,7858,24e3,30453,840,16673,25907,68916,89927,6309,158335,36407,199737,130464,13137,59603,201778,195292,21015,42466,179062,172561,89492,11075,180407,31868,72493,20998,60217,9865,19530,39274,130266,54539,21623,12535,13505,40641,73375,4087,85633,2153,3117,70680,55788,92096,47509,98493,37490,271936,151475,3032,16171,96642,34106,78425,125761,19591,3366,19316,54508,24183,50786,194248,91528,33253,34622,108355,41741,705,3814,3883,108929,13203,67831,10142,59754,68208,29128,84820,56880,38794,24972,48571,40821,40476,18137,164254,24064,236309,79181,11282,395,39169,2013,51587,28551,9645,701,109513,115899,113566,12762,62045,58322,103726,41343,40866,244102,143816,2490,70346,40973,52618,15412,30720,104315,38917,42027,93676,17513,107418,20706,123890,13399,97727,24044,87962,65606,44250,98044,65276,74790,101473,19350,91570,1326,87790,172042,7577,100813,86896,85891,41512,108130,27794,14875,71431,12835,156250,58135,3759,22476,42176,115873,34686,56523,73643,108505,51491,20838,12721,32863,45700,29496,13700,34294,55360,29206,155942,123812,7706,163234,203,132720,49358,144431,8130,175788,35818,3270,76832,25710,54095,97274,28779,94621,74396,19092,128242,58067,20885,14670,93255,15107,63291,23654,126900,129421,59294,262659,9798,3251,67344,28600,44629,50672,29072,26999,31526,23183,49175,165843,175455,17282,175411,32022,45989,30298,90690,78118,83156,23749,35636,31317,7069,80381,94561,133756,14960,97404,6138,41065,78041,32843,16601,34123,9559,146529,123377,96395,54441,42012,84257,123541,10745,22139,106459,11720,150883,172651,154996,110538,4728,53447,25704,2009,71152,119354,21166,66604,1429,216162,8637,122250,63520,27180,29172,36124,276428,107787,77184,4680,14952,104903,24418,14793,51561,52931,8371,26342,48526,7118,92066,67280,40653,8847,34597,105438,14198,50163,61188,146286,50315,41205,170829,161496,585,197359,95056,1687,365794,91349,48507,5804,49263,5146,104902,96365,117343,132222,46084,96919,16875,8073,262381,79982,52663,13928,16056,153908,15145,109256,132308,18763,24904,167644,13618,40750,18686,147124,114709,150038,52849,2938,12568,48617,8778,5459,44202,44591,74914,17183,248689,13878,7822,80060,23116,194037,18487,2067,7798,43077,33678,244028,31320,74273,2794,19466,8218,36280,183997,48124,19416,29656,19280,98734,7715,18311,30701,133602,150307,126956,7378,2933,79903,13178,12593,86571,26604,92446,13574,44205,65699,427599,21118,8245,14407,27877,47936,33542,7916,26460,117762,21596,37818,2249,127359,209394,60044,47677,308089,36791,154971,31417,6998,150042,174360,12255,43009,29335,48739,3912,101398,53340,2580,146939,151295,45360,125275,15273,45383,27456,48761,23314,8750,60801,85823,104759,27894,123685,66968,39480,26917,55290,83305,2696,98390,57569,145853,340733,4919,20024,52268,30884,7413,203685,70989,112855,4129,50536,349518,68205,332641,159581,135361,236026,37563,176404,64899,6578,122033,63871,1850,85234,82089,66124,74145,121098,107351,12687,36881,117334,13136,14698,85933,93866,18047,32620,310,15094,46e3,88451,23632,36645,27940,87618,80520,58892,20976,27702,140090,96075,67841,103292,238964,87778,107338,17019,83427,67522,7302,8261,47570,116787,8730,80484,61772,174422,56005,131193,52875,14588,28471,59817,9586,15720,158155,51307,109734,15196,11025,59331,3884,52626,102602,84797,25158,27314,4437,20488,76214,189248,35023,114952,157376,2827,62439,102878,129749,36405,10329,109339,108633,36662,1254,13267,5470,87105,58004,15397,10434,159667,21864,52022,179464,3013,32147,31496,116832,18494,105502,129227,107267,50033,13481,9954,24267,22141,16257,116154,36185,950,115685,11305,176708,2048,178671,112573,287867,162328,497663,95170,50979,193861,50987,30368,136257,31830,46549,15119,169876,23788,17462,249887,57377,1949,35448,14791,43769,210091,3783,34612,282103,88380,245190,5457,20491,98908,11402,86899,117916,16028,162584,60644,320177,156096,31065,55876,22e3,77655,9992,23397,13757,317623,63978,215255,2443,17648,93231,27388,104529,93807,55505,140477,12046,112040,70887,40152,94365,112353,25063,114679,266061,71248,119555,15589,2244,617,14129,211431,70110,100652,7777,4383,85911,89221,21010,120615,58357,86405,37554,41647,18,15143,69662,60491,14714,186134,148344,42347,5410,168175,44535,42449,343894,129417,99682,20659,27272,140483,63455,222159,17536,13722,42637,62324,11976,114691,148109,2283,32057,182393,4295,147364,33705,2075,44303,30274,28331,63740,69740,29148,10346,44862,33716,73937,153333,12930,38784,247159,2515,41053,20256,83368,256189,54639,115240,5096,24661,175419,153552,26516,141,138176,63885,34115,47222,55709,2765,28479,38875,236608,12229,22921,77291,54426,45388,2860,57787,114579,295139,105782,17826,71066,19119,54364,69385,16568,12323,28057,33346,34919,124763,155533,101386,31644,8627,49001,303600,29868,63213,9103,77280,71333,9696,138789,37059,24823,5057,21352,32368,114208,56803,19424,10445,58514,8661,209508,26187,171838,10460,63454,14016,122504,41328,21329,46618,32493,38225,7855,31763,7945,29876,8734,6438,24205,97490,139977,130740,47323,33195,85390,57194,13813,60600,21313,96251,7699,27584,170521,139271,1363,4402,336738,129223,84983,69150,13147,3590,163929,207225,155260,55916,20288,4503,8398,98490,11773,27512,37113,84976,86558,28365,11756,116005,182148,13733,115313,47644,67208,85069,9347,14995,226141,14704,101835,41159,35314,13113,63526,214039,29978,50446,83339,17440,129441,72522,118641,97816,24907,73844,15717,118884,167255,96509,162793,30847,36849,51297,78974,77793,10427,1873,2972,9999,35074,28190,64297,146836,46298,60038,163007,108919,61219,2403,75022,127339,4233,110389,69022,9833,128097,88016,79390,222936,22570,94657,28462,56956,38803,81536,30474,152794,19566,16481,147408,74574,81895,20731,1918,1366,76367,187321,54494,24366,21690,61696,33283,107477,77499,31112,414383,74362,18463,218441,120929,59848,258629,201924,69269,454,19989,13054,59894,3623,58908,20681,35723,78523,102680,38988,184112,108087,50944,132704,52966,21699,18860,96349,201411,82697,85395,95658,5093,6427,177894,44191,32755,26961,155739,6249,31310,81030,26574,84311,120155,86730,113535,7424,48888,13516,45747,98098,20077,183995,81945,43210,26704,40420,75831,45648,11180,6855,57927,65528,124096,34851,2598,156633,107572,127352,38169,123845,60142,62722,105584,232364,23211,68120,1601,22169,89299,747,258039,80572,7258,152249,11862,101204,8834,121434,33761,19175,133142,46343,40178,48723,3589,41977,30210,38868,62257,10087,82658,87827,90646,16415,47552,351723,28298,72225,91146,272760,1701,11295,1652,109651,300747,51863,198800,29446,11794,32345,37538,22356,33102,37590,113544,37970,11478,179743,25454,103417,59905,221970,105196,145604,7817,164809,102360,16974,75840,255333,56902,6659,1954,645,59400,67769,7689,18675,5215,13793,20536,27852,3387,29523,259718,16860,94625,43143,29245,15848,233581,22685,63631,78557,22836,133302,84513,1348,51826,47129,98836,58284,1830,1749,94642,10933,6145,12506,10975,13879,103781,144434,10268,28409,32346,52968,121567,107374,77268,23686,35097,10501,155275,15303,47136,21102,168741,55332,90385,15996,84817,681,137803,25054,142275,6163,38175,8056,124296,240642,65621,4934,178205,16101,62803,60964,18230,100622,76465,44689,14545,9543,47514,16852,93380,28048,12047,107106,37575,101485,77047,57326,34819,96137,76916,6469,46264,115983,75768,87668,69942,13027,165,8373,114231,26434,52844,42799,182044,23580,146254,38081,43236,33883,146220,382894,14606,46035,36481,166621,35417,95382,2957,59384,60428,36358,66343,75378,22267,22950,83528,17577,56474,25285,4619,179691,75355,95836,53295,34588,171410,4487,14679,84208,44015,18562,109133,54101,11531,86052,174479,303157,28095,9953,35642,14564,39802,16145,77606,117406,53038,121117,53624,22062,1212,7632,127157,237292,189087,10478,127345,102515,181997,86752,87623,10966,121602,68783,68681,83042,114380,138349,191305,67176,50085,39016,1427,42384,1412,67118,122616,72389,25260,2237,13576,137346,19938,20304,2191,68759,5373,61364,238507,75814,23931,69565,38993,131741,38364,12528,87762,5679,129853,5310,186831,32653,90338,260176,389531,108118,26843,43985,50175,30563,25106,56965,18130,140428,4542,165503,117991,24219,229605,1819,129663,1240,3797,76093,18398,71339,51919,93043,27175,47060,216257,6483,35051,1217,16512,80798,129064,13225,69339,8548,237079,72298,2575,34280,51379,117910,55671,53345,247552,29486,39328,140821,34681,57045,60177,5004,90269,78522,2479,322607,48474,61296,13057,31558,4678,59271,6699,27044,31988,35944,12503,83480,4389,136508,3781,114121,70279,4488,155829,42214,2898,68191,75695,305850,45041,74344,106509,30087,17429,93292,12477,290,23080,114802,35714,18751,26554,105424,17775,2144,2412,100610,65192,113975,52975,180272,135050,129815,76238,106483,21440,63186,4260,46189,9711,28249,4169,23429,23390,8324,141585,63809,67668,38457,38063,39226,59972,1189,203916,62368,14403,16949,61767,85801,1739,40147,35049,76757,33124,62102,15780,103593,103009,53484,22952,67973,114645,6566,5245,50462,7601,8288,3513,194571,80276,1908,54592,5124,58571,2513,6800,273997,193904,1119,17991,117245,2508,129156,82366,26278,71465,63341,56943,39662,106116,94966,156875,9736,2204,122308,94418,27134,1280,24539,49022,45314,3764,50904,46424,30699,28087,293839,9400,33646,40165,822,147499,50263,116179,29085,11863,31314,5578,17797,5104,12454,1604,15342,219206,10232,67800,94261,25872,13565,90339,78971,75377,26649,41184,47695,11514,35369,20767,14227,41953,309396,148270,147938,33074,14453,27499,109019,39018,25738,240196,158931,52820,8612,95853,21524,137010,84901,70869,70021,116794,48404,38771,6732,1070,70990,187297,49140,5238,576,3564,253975,16027,16483,2811,37775,19034,25259,4053,2e3,70083,95774,19713,33431,92703,91314,42381,288770,48194,95985,3991,77418,13406,241328,245086,56533,35275,62725,9246,51924,70181,95331,16163,31410,79016,39312,120878,119371,275987,80124,27712,9186,220,23598,146167,85209,68238,282190,57048,31273,30555,80913,17594,75779,59160,135002,101219,189377,29225,96735,60126,62522,104e3,27620,86814,17240,147533,11001,5425,43682,410,49460,87270,69480,46315,59448,1816,76201,9431,11788,87960,29063,65539,47347,11678,33846,7008,196704,9895,6753,8633,120892,59970,572824,115934,6646,202559,892,48351,37611,251282,57823,67263,57750,26527,34485,90747,7685,88370,6144,64182,1709,41969,21458,62327,181657,49247,225330,122600,114574,107124,85361,111833,63243,71420,15655,191178,72430,18063,51425,54002,12364,53225,86557,18193,97580,41232,138398,67821,128724,8944,233212,101353,52099,42127,14006,120107,32789,32132,3498,18123,33758,56058,5779,128760,59888,98869,18445,84702,51911,13234,218379,20093,39031,8074,70195,20708,23462,24355,131384,60189,26390,10403,41060,7140,10781,49410,42261,87202,82566,41663,43105,60276,2768,5733,74176,28329,2297,145430,131632,83615,122915,105441,655,224102,5284,136426,67763,16294,188511,32538,61049,27893,3394,13951,159099,28542,17930,145360,9492,190122,32285,78855,26440,13570,58648,73908,4239,124561,2444,74172,53131,11468,10794,73566,11623,35343,64710,30481,4163,10328,38309,29901,10538,154377,76132,92405,24839,11679,3465,13449,11637,7824,2337,57754,1260,14458,41118,19878,38661,13416,159180,37074,163164,54137,28627,52134,184900,8520,40385,29546,30502,22386,66527,107458,6850,24022,47983,30603,35083,8934,304066,39500,9,28261,33026,77251,9374,44833,116312,34990,29236,63563,125639,135405,165398,159055,55690,88141,69643,236964,31983,25572,20436,36746,60896,31850,16179,11828,5888,3043,66368,9750,31167,7915,53111,36430,1333,64344,93659,20061,60596,180191,51630,6792,30244,43509,101058,22409,420,44210,109783,43223,27030,72477,72831,32679,29235,7675,47556,12258,39907,149412,84926,118247,24692,71717,105038,86009,45941,41189,89453,29856,52543,30627,226798,67303,59230,67415,34408,1367,99685,16867,128419,52147,4111,125381,117881,16173,44093,102224,31575,23234,24870,83790,127407,239098,3200,994,1255,100903,242275,117266,55116,38205,16140,29662,11307,40414,208793,123355,56470,4862,75600,30119,58218,70828,24075,26974,7802,192353,4851,5475,78720,66596,3409,28573,64396,30381,30690,59859,88256,5406,99945,103064,34463,37727,24238,86643,60088,4057,23741,5967,162904,38240,28356,93858,25510,122879,6897,3278,7057,11971,4400,35461,211413,21395,59615,39471,87233,55795,128426,3051,22470,41950,14705,3974,180108,80476,78442,204996,91987,15634,67610,139015,142373,35611,51134,10387,4353,153456,57749,181039,14183,68447,151532,21107,36452,20551,3186,46247,46383,129666,88736,140662,146243,2066,8360,7978,64818,106963,17896,47801,10723,114821,223295,74192,3293,3393,16987,74064,11277,91622,4270,29828,27951,387869,103235,1374,61988,120083,477,145892,128378,11779,211263,61354,18221,17869,46530,83061,108538,157981,90608,67199,95080,49064,195814,12302,66307,10348,231346,160732,112859,63633,146558,21271,31037,198802,47622,12862,95710,3910,77850,73961,85585,34752,61e3,4082,24595,103679,71107,8208,79568,150019,16615,24961,139857,32664,197366,4559,54735,32696,4126,162019,75698,13916,70108,159638,19834,9349,24675,175560,49643,18206,52459,27992,10809,88865,401975,133172,29e3,34558,30915,3658,25834,42430,36562,125265,18182,10155,40149,97082,208980,19575,60853,90529,66545,9600,789,46420,2317,88593,55595,98980,115302,5742,169155,1073,177901,3472,11189,63711,78643,65472,50459,127979,93,42202,67053,21720,157650,11145,141378,42033,22824,85705,79114,35584,15974,1510,54172,28562,12451,104226,19190,97151,73024,20948,5151,81741,21499,29006,84183,198074,54003,45120,170125,26240,35177,28389,64863,79974,60778,176915,232183,45342,2038,80253,41564,40703,32689,5430,100689,5366,23007,134279,14266,26712,73993,24934,64242,52113,102887,61801,46415,201049,54251,62133,122757,164883,30815,139966,2319,30842,766,13362,10287,134518,86111,81665,82440,28333,43019,18963,8804,161944,23439,102144,101145,80029,39052,248708,30350,117340,11878,128467,974,138625,63961,5237,74778,61834,67040,43814,13690,65947,33809,232476,115258,181745,28824,94013,9510,10246,93722,81976,7217,114383,3493,16014,69045,72692,12145,80981,9507,6692,1620,60820,330444,35474,33962,4797,7053,295463,46445,27026,12491,77988,49524,35675,90947,29114,166705,101385,133782,32704,6186,84595,176031,185623,45966,151302,63069,1699,107491,947,15458,74452,196212,6046,10498,12163,10239,35191,243951,9277,9090,29539,54460,22820,26514,112549,60372,51753,48756,21812,70861,260326,41,44222,10441,16961,48148,138771,216194,5914,52153,53400,212036,56519,26245,10117,45888,15294,138019,90913,26368,43842,42111,23348,6082,194845,161089,156206,51546,11647,30759,302912,262094,8635,78876,26535,35283,54183,31183,85484,147873,12989,5197,6356,72894,65347,20150,27370,73787,1493,45918,12366,190217,20724,13858,10981,67449,81213,7553,14115,72242,271517,11842,48310,88743,143726,22177,3290,243231,58452,62937,12592,1654,40066,33477,13751,9921,128442,15868,7106,75236,83773,10775,36938,10482,170465,17368,17469,161508,32752,98340,800,19824,264456,3901,87319,2867,26782,9630,113102,185815,24197,44584,86366,40224,3636,140916,31731,267731,9567,53678,72984,29389,27963,17106,50282,284911,60170,8322,12608,23374,89652,5268,39044,229766,8869,151350,31436,177342,12269,183212,120418,116270,2843,78888,69192,7865,184099,1086,129897,18383,70508,20242,18508,229924,124569,35749,50589,55626,9884,83115,40971,30671,18135,14452,38861,17844,201826,5549,26413,17189,13561,38539,10679,143331,3314,36785,171194,49685,187713,67506,4618,104039,17060,195080,50648,33159,19238,67559,134840,28599,157523,17130,38064,117398,94355,31918,13575,34538,40326,13997,3494,348283,62481,26862,3603,104426,244363,153709,112487,304612,199674,41239,35545,54869,293005,28223,26277,26899,4533,18518,15492,38587,80488,70485,160395,263,60162,11382,222152,4696,250751,51921,182609,10707,48463,46243,1227,49111,111564,46502,33342,56846,68541,63559,858,139927,16654,229375,76759,26478,33205,95828,23399,92945,2637,35630,28470,143992,50214,14174,21456,166191,65665,1711,21594,78019,97599,111701,36,147151,110246,189022,43021,30397,40757,131935,42065,73335,48039,26596,28984,15102,2361,7421,202167,69744,43766,52826,3642,83304,33873,75140,63169,192389,36551,92748,13039,123959,233220,21738,84447,77230,20228,187852,19095,25799,92136,108774,29237,53947,2299,118106,2687,8830,42331,202924,33667,2023,73763,30704,19363,19779,16737,35629,48081,24068,101013,162338,291912,13749,24745,328289,167679,70086,48299,23306,16732,17801,43322,54589,3586,63653,43624,53474,925,109177,251316,43805,13082,19511,86565,142182,92461,17117,101033,103319,64589,4022,4351,235897,5352,82705,107142,46391,156084,5860,61365,10558,13045,7717,18357,33922,12590,33065,6928,46993,783,46937,67846,8952,26295,6107,119656,18799,17458,50747,4229,179559,112727,118080,20683,41464,125468,51560,49749,44231,7359,35339,62988,136487,67015,5208,29150,24956,105186,48858,6143,18097,6972,16404,73489,58742,97196,36357,164616,5834,32267,13746,147733,15113,132091,34127,106298,39729,106426,22294,9780,15602,36213,71502,42808,66802,599,60755,5851,39120,67363,108623,126368,72770,91263,32486,30596,151717,7951,52002,43103,11768,68942,40901,39344,24037,127500,116890,48403,16926,86750,17745,48648,159545,34460,58419,5634,114317,67865,31462,23352,24010,98185,125708,69686,68337,13610,26271,70691,2980,4768,27225,102402,75453,28106,8104,6931,1176,6274,6475,112635,22498,6176,238686,26832,28893,90319,14441,15682,15087,39517,45270,109134,104440,45965,47645,81772,7876,52683,87720,12898,4505,185665,2769,113401,15664,57592,105229,137381,97059,119268,6876,43309,33886,128363,35476,144249,67013,143587,83367,25703,91436,59347,53236,2289,16519,19844,46309,58558,99834,23313,218816,231303,36388,51333,183535,109792,139277,54306,90139,18235,8275,32710,37677,82464,86025,92204,88842,117723,37570,128723,234242,76350,73795,34896,148247,58424,11105,11744,45746,63372,17118,49772,199520,81902,38004,22911,33752,3125,1995,53792,4689,26909,108150,146062,69674,41811,161444,84855,8999,28561,16731,93937,3189,21967,24890,22943,1356,145300,51569,28802,517,118679,31703,40607,48098,108854,25003,10233,73969,177495,5248,24516,215347,146192,48712,60626,69188,40735,5866,586,101541,6509,47590,52129,5969,222045,110933,25733,24223,65339,62812,2414,155418,35819,16022,78423,43138,20995,128255,240673,46745,236093,72176,57085,97841,61248,107,36068,193177,105427,55726,215229,20446,47228,100420,87091,14429,121708,23605,21157,187721,21880,2997,203976,99166,95068,25877,7724,98925,83401,4829,13182,18229,13718,239662,38653,116505,153497,30589,89029,38962,181302,43853,78872,180301,4786,248240,7401,106136,112590,77745,19731,60880,77789,125748,135487,5975,48627,34084,12419,215770,47557,254582,10364,106495,21856,67539,88981,38805,21428,48732,42316,12149,16078,52808,25327,51322,33850,51147,12253,122354,46077,56483,254553,115417,81834,150991,94662,86668,7381,12841,100650,18218,15741,22372,68294,50705,15535,84660,61887,22553,72299,31361,24824,17743,46820,64288,31582,77006,111674,116384,30760,80920,86149,77192,51979,79691,60342,122805,103800,240873,160744,233114,78962,54920,8608,3484,316104,72548,24337,5088,230040,21926,10172,36838,26,86221,83458,102176,12062,17571,41929,41170,28428,68239,41750,103930,2634,18313,53019,34825,97837,63115,24606,73157,152474,14715,91439,37033,109806,140259,30668,174760,380,135597,95673,136073,65073,134249,13829,17279,122305,4420,46444,10237,64848,203623,70728,10349,182885,65075,24519,25783,40318,34139,22222,63394,55266,102764,41422,20126,65100,90408,53640,35128,48932,11192,38935,96839,34782,39492,19396,41332,6250,5511,19492,51304,25936,104466,54099,73771,86115,5080,7669,30891,111700,13931,25276,72289,135447,14820,258641,25265,31005,281179,75286,393,95359,14623,13584,6680,101227,80173,44933,76666,54542,13244,39348,458,25379,109451,134348,81143,6959,65554,12027,51311,8716,57589,140731,28467,23316,17272,30458,25980,55229,77197,83798,28302,114784,7428,34548,26241,14712,39336,103304,18928,54080,12870,334,87722,15208,16895,142098,114262,39820,83913,57817,28682,7721,14900,108672,11250,62246,42849,415188,1724,26555,24549,25505,26443,107450,145899,61035,43528,6901,60726,65906,267741,21338,147590,42079,18924,73017,135236,15393,5206,4026,84185,1531,5988,113890,82647,303391,7386,69844,71611,189865,76523,31877,13315,19314,198575,32821,1928,67641,25913,104475,103489,3297,70391,18406,15446,113347,19295,93790,27856,1792,167471,116449,8541,4408,41757,63233,25765,86680,64501,27034,24816,34975,6079,4486,49693,36229,16917,21581,62426,27862,11612,54284,35702,194034,355,24277,48262,87411,70504,310164,118018,12516,47559,43502,57433,107139,9290,66533,80863,14634,34312,91725,28606,21342,67241,72355,43244,375789,37402,174015,105070,8342,44167,67494,1890,16365,11723,271002,1865,47918,8350,45564,27742,25110,125803,8553,49504,81925,62211,4534,15491,19011,80373,206920,667,102405,128623,245524,5553,113309,192739,65766,19567,22832,261958,29679,21293,71134,20962,105123,24721,860,21752,33448,18372,157167,94822,35770,173224,232737,75729,28937,46828,28062,25453,5207,140366,36665,30652,6169,67920,150458,92040,23186,184604,92330,20891,176492,49427,27828,38305,42495,143982,49560,25503,90043,29747,65328,47830,12932,11068,77721,9003,25213,94205,140426,46090,89945,138173,192691,33329,112232,129905,35709,27514,1841,19957,31411,127476,53572,17497,173549,55063,175135,19841,69314,5192,237921,117660,150697,4060,273045,50414,98940,65348,153665,164423,58804,156695,48994,213928,86036,28608,8355,39574,34540,16927,135680,18374,151587,10830,53805,16878,16623,4282,48030,8537,14986,46102,13062,72897,72,33050,108227,39451,45935,651,113320,40535,95176,57450,48843,5003,19019,10407,211163,3848,1068,4988,32091,30095,41692,15099,43602,107434,50744,7627,171349,16313,150832,352665,207750,33937,38256,51091,156e3,87889,90663,84175,24908,114900,50365,31494,83829,5398,169342,47521,54818,18935,8356,43094,41212,174536,10082,92550,6678,60614,23355,69721,14796,34149,128830,58187,3179,208,40325,28399,225029,401412,51150,31580,207268,6657,10993,69818,64282,289845,23308,12961,38447,6681,52944,31855,2572,47646,120728,179148,37240,45196,218274,4816,3695,21961,50084,35209,18073,51452,27004,6100,33941,1377,84831,171214,85,141510,9078,99227,32610,6417,11718,49868,65579,87902,73018,49062,46280,61742,21512,40862,107733,15941,29168,157765,144919,14487,5767,158014,140070,7241,573,71584,16921,223566,40331,179473,35081,47926,140885,41508,52104,59180,42310,32811,29048,123517,102413,80208,10104,14746,12649,153641,126022,37965,113017,4171,83,142592,2809,6362,50416,71323,116894,260776,16204,1524,5760,30351,12658,20703,54403,36083,45408,74772,4946,14485,50759,111222,10890,2195,167147,92962,130534,16283,177256,35016,15472,210156,151187,73922,117691,43250,52051,37392,24811,24358,30830,5775,818,21969,1476,127322,151783,58392,31021,106913,65215,89407,90802,28531,11690,20234,95249,44602,37256,18707,11928,5161,4410,26571,51903,49768,22008,25252,65780,209499,68769,203726,13249,137363,48845,86823,6658,5674,31881,1083,1823,108676,34518,166752,13791,14287,91576,91429,8665,11529,26401,16191,91972,30964,5254,28486,54697,79613,66520,18447,22870,45203,194466,22822,51703,12278,76716,44595,73455,33546,12235,144843,36154,51247,11116,33040,3180,225753,60864,1972,28469,12891,28879,10338,144157,56294,353058,38302,41447,87532,110616,27065,168438,6557,1213,50804,144643,24817,2390,136531,38174,247513,16190,4059,122791,131994,137430,39506,57650,16305,5188,54309,106128,20628,88071,67394,395446,250285,66176,91254,1399,114196,43915,60230,44853,27206,106353,43013,18733,345105,226453,51202,16607,57106,117175,35492,10476,89598,127439,15187,39624,13688,61570,10615,31111,59370,6238,175252,32143,224492,41388,95408,34384,148238,78307,38959,9340,160091,61443,15737,11216,41244,170,38299,102443,113097,26382,14027,33707,3957,76300,66160,19431,18900,6952,1717,108656,82206,188021,257335,27295,43999,41210,31777,46956,57457,12657,11489,15697,48060,204748,53583,82422,284790,30503,137341,8120,19615,220311,15991,10217,63424,9808,67431,70976,98221,4491,15177,28535,144789,751,13230,2394,1504,33977,132104,30316,22230,931,97193,185240,24826,22687,174322,15307,22988,1390,188745,180325,29580,59068,74903,18994,29195,79,15436,7622,38462,11566,138710,44828,45774,37768,99236,68137,84083,19282,22698,17134,74807,126662,173497,46248,16938,119735,3212,28292,213652,49013,9975,32180,45660,86250,4801,68788,95490,77482,113751,11994,44624,94452,46839,128497,100316,5798,58588,73184,202987,65417,37790,88524,1606,43156,97964,105717,34947,11203,100060,37742,130074,93653,107799,94311,196106,41347,8035,10780,16390,27883,118236,167395,1979,25006,19375,31628,18916,144723,78502,114047,103107,86492,107686,5844,20934,206963,23556,22591,16562,146333,20167,10471,117434,33085,2863,9740,36669,41849,37271,22790,18209,28979,8231,12952,54408,21731,25130,45208,55748,138120,75826,414,29593,9925,292865,25999,683,123149,7036,92159,86055,61827,103680,23176,54918,58466,57578,13305,5709,86479,16697,31064,17660,200919,10770,49793,33423,32370,52047,16488,62555,6459,8426,83493,7763,59725,82812,18628,67760,79405,68557,9612,7673,28102,56517,69620,171797,32458,29541,15870,81109,32080,207644,71495,21202,11039,91036,61230,2810,130800,32260,4613,60590,37112,75214,33979,126402,155062,30642,63875,12810,194463,82799,47664,16725,36685,43367,61099,449,172150,102867,21691,301838,36745,7130,18671,57316,34852,38034,54182,35578,65900,99486,19771,3456,2658,16914,99866,28390,28109,8262,21147,34353,20006,4228,137085,1675,203023,283196,198286,214375,163329,290603,152574,40471,83506,30068,14730,23177,131539,34759,27668,32178,71896,104799,116305,85430,119262,42860,25160,8911,23428,49437,105322,6519,16203,6349,74711,1230,38045,8540,75165,44736,25909,51026,317034,4984,32281,91312,27060,44431,17817,45363,155937,239085,35697,59784,91993,29531,126740,213757,76560,167776,285273,24262,8237,65030,41160,74437,48804,118916,13159,37842,1031,75349,1478,11655,108777,23435,277425,101734,67469,70231,124711,43532,28514,65526,54956,1e3,21882,17728,25302,40952,52214,149632,1999,2111,3259,63362,89961,220561,39777,26335,9063,10572,12416,34551,34623,38604,24723,5947,15588,69927,66252,119177,69173,46629,28714,70715,212408,20521,406913,74380,11716,50659,50862,37009,88460,130101,7210,53853,538,65120,151950,55806,163748,52837,13153,21100,16674,64536,6091,138201,44837,58547,3723,163,2177,32288,85454,34033,8497,14282,25742,10535,10741,79559,117493,243787,49337,100718,79495,40139,42956,7551,55433,15421,31509,23034,45081,547,61176,53434,328001,8470,36263,30145,4519,74173,53935,11845,73774,60211,78025,3,4102,73782,109293,315332,48412,26683,13714,6865,20128,18490,104141,325,39470,171970,115860,15707,7268,73301,74336,31370,2368,111827,107757,136231,142844,97138,96638,84053,38691,23801,1588,10573,122098,77039,240,186135,146101,11996,18143,112963,46171,155836,348769,47795,121213,116266,132515,3344,144804,31286,99187,255838,129694,35894,48779,55235,148582,71967,65282,15174,13920,47080,6147,108242,157593,125025,7136,1286,28957,127956,28402,98813,20805,7532,109417,40610,5041,32958,15142,18408,108596,33543,50517,27748,80114,233434,91447,487,37094,100048,30541,43477,10639,89862,155868,37667,8726,60684,237903,73408,99589,12190,38739,97348,3914,13594,2680,149016,13907,30171,28343,23530,115225,61104,35821,147679,14337,4297,244282,24085,326976,56428,7851,21303,131620,71446,83253,68692,111870,5224,15813,38197,49026,45057,13660,3306,76345,40671,27905,91072,996,68527,62085,91351,122634,55109,168209,2024,27560,112707,17352,8306,167115,169921,166958,5031,46020,11844,67284,19130,76185,6920,32849,5450,14610,22451,21002,17392,31872,66682,84796,13709,40210,59898,12029,8719,53564,21462,91884,21647,88379,194428,12754,37797,132826,160016,22567,54383,53186,77611,31107,8339,4694,19185,90355,23597,17222,140675,28442,23668,55977,9128,61555,28774,155229,17658,9390,24379,69357,15752,127381,239631,62460,93181,55913,45133,140155,18676,25249,33164,29581,82837,67223,22362,29975,7317,52813,1943,29613,20012,207130,49617,49651,5636,15334,36313,29226,28084,95247,72072,19e3,224932,15811,114,32127,38097,37508,88507,37225,27359,91626,12193,69279,20608,11055,88156,92808,2152,57259,55275,72789,24475,104414,1708,9882,3818,48661,66897,1631,34806,227930,85815,87753,18321,250664,72733,25107,206797,50891,8082,196411,92596,96764,152823,65514,22819,387277,62176,51225,40329,15563,189,3659,73670,64357,51793,275136,33482,86653,74615,67058,11318,125720,15388,22388,8267,1730,102663,170910,40784,7144,85373,13040,7088,94309,583,44224,140424,77439,18496,164026,36578,4722,9151,5824,63365,26510,35199,40500,79277,32495,44614,35233,9566,203293,152144,7097,2330,183480,98629,13423,330887,44130,68600,30939,97829,31012,345465,56747,94879,4939,160027,149761,99423,46099,32251,15332,8761,96094,128555,5763,235318,222223,55729,30241,55420,201746,3987,81382,8259,49325,23287,7719,24633,251100,92311,18591,110533,64759,170260,393860,7175,21144,132887,3593,75346,101277,91109,16387,259187,11627,57459,173829,44694,55780,49797,89192,120443,62622,3904,14814,23887,1027,112258,64955,99800,11132,66353,36202,48624,18158,88481,96882,43059,11040,2455,7077,21651,181159,99126,100434,61388,68186,19161,110468,120052,8819,55324,41494,7014,37689,3618,87729,92615,207943,9823,128657,12587,15857,6379,67628,51216,71775,157617,63244,1503,3864,218754,110864,5769,21492,7243,1192,87921,85529,31512,18537,42698,35350,73510,84474,34301,8991,21013,35034,566,38832,19838,35586,37216,39413,55006,12178,59742,856,84563,6900,25632,17437,49786,30723,13847,70845,4044,7843,23944,235976,55530,48942,6518,20939,73769,192653,52936,95207,23895,132542,142982,22632,87452,48042,54018,178468,10728,26230,23559,363,81269,142012,5718,346258,31456,84333,246476,51018,66692,101804,120570,39962,30373,70593,2864,60541,19425,54209,104092,7201,31545,48018,25865,15442,46257,40443,8328,6451,111782,47527,97754,33046,470,245116,31095,39,91934,87208,73470,36708,36521,12801,70624,36272,8892,79768,12427,55454,103756,5908,52390,62962,22720,141138,94634,41689,128402,126390,6628,106394,35527,134394,82727,254651,194502,148064,89549,3202,28359,957,21954,27906,49840,142747,8307,24206,48978,1186,71728,133038,71474,91306,6333,110959,74600,70387,18983,62609,56057,22970,1147,135850,1321,28834,3578,59715,102227,32827,81415,99952,55636,257598,390,22702,35701,85872,402916,39216,189795,14929,19467,10112,144422,61514,5279,63421,134686,41436,8424,51925,10598,132295,124416,4604,194739,210929,57866,31829,51626,50007,9976,91878,61906,56168,81906,60918,61859,40017,23059,16887,40927,62064,12785,32893,32913,21782,93965,20169,44387,79084,38463,11457,93950,27127,157050,2697,337088,5116,54128,48255,33279,8821,27352,25515,124022,65710,28906,38557,33390,1722,104435,72215,38551,12094,30978,25113,6671,37355,175109,42862,98024,65406,221276,59624,118012,64637,78760,86697,21426,1639,40350,12584,67193,84144,31396,7863,143011,69629,63112,9454,28666,65798,46372,134721,6314,51402,30837,151922,2847,38676,38008,92823,136245,17540,5504,109295,205242,37606,5211,214892,1586,20670,208711,137743,19328,40652,16995,20023,14657,154919,34422,12996,13918,38221,47690,16398,2959,37680,89122,6721,198469,91876,172043,83898,101992,26084,94570,3635,76958,22853,76497,38266,176590,168403,44464,142840,79180,184594,1984,41806,83147,11985,6546,366068,59732,24533,271505,8736,39084,222992,93429,28962,58985,86665,8432,30028,14548,32439,54424,165029,55175,27458,69046,121277,46168,33732,20661,24581,135574,123110,37556,79260,72611,16957,12939,46162,58238,44907,72936,253758,41324,32518,96480,11949,124438,65280,43256,34107,53533,43531,37037,28366,45970,32741,173438,6121,194202,62969,26355,30314,58370,28455,1848,50519,82830,90393,21761,295490,10936,256940,133568,44050,20269,4089,27457,21610,219460,36743,14821,101388,52005,13124,30979,140816,167362,26054,18458,60789,34917,40447,26606,33422,9066,3452,83614,5761,20263,137238,25038,91310,101,52322,74548,42572,38084,214054,186568,31802,17665,30620,141936,37730,14420,4265,187218,49640,188208,51441,55388,96452,66659,40869,42039,60967,221027,19234,178581,29105,96050,9165,196118,157335,3738,40354,117436,2965,34136,59659,15570,50843,230035,31444,71260,43886,18316,5387,38500,168508,17406,32174,8828,103373,143806,90367,3560,18719,122310,16508,26719,2541,105429,6645,37998,73190,10591,235916,49737,87112,233941,53188,32193,79154,4544,52905,126477,7580,63501,57314,3216,31337,6541,103083,60846,49,9756,15481,1355,43840,14319,13743,27486,10222,73114,230718,418644,16706,6674,279748,23058,45273,295831,86306,2743,5535,88773,21829,35253,120938,31153,3169,16839,42847,8751,80974,33942,36867,35514,16485,26474,77775,56877,5391,48346,3882,108713,31403,27804,55248,26235,43821,136104,40118,175507,28034,203908,18732,1788,34030,106427,36958,54359,7251,44936,15356,69139,455,157915,22173,140291,50348,43275,82066,49621,54952,15216,36226,96695,66855,6936,1987,8227,196087,4631,68827,99004,47541,110265,17953,147605,110242,58520,31312,38724,329975,642,3155,34497,75937,6207,73843,6120,17249,51429,117746,3218,910,68961,319671,14938,29555,34700,1649,66673,72268,9655,76800,153087,6941,210168,27130,35398,1780,73242,3135,56689,19556,165307,8765,35967,121458,13333,70453,17350,117253,22265,13340,44265,39869,441,3742,135025,23581,33309,16543,17731,13291,157637,283005,21408,101360,63887,52312,83873,5338,233779,23759,186949,34531,177320,38069,156465,91004,19353,59852,68160,14891,1338,1072,29823,1950,28901,81407,313445,73038,84807,162348,240257,37162,138934,16111,58013,41253,102951,16457,96056,19541,56402,67217,41638,94381,89674,29481,37456,80815,151579,13937,13683,132537,19699,134545,67020,29816,222341,141235,427578,48868,129557,233342,23077,87871,16213,18728,16184,9469,37913,19680,2798,171356,178328,13216,50049,72690,71904,124644,55455,7504,29052,41036,266546,19899,30391,188755,8659,59469,16,104298,112943,53865,76203,138226,68857,139953,14125,107625,119795,173133,4398,50273,48808,54390,16466,122086,31835,67035,50971,48859,7508,46427,66477,73021,84615,39985,83076,46779,201569,53336,36443,60865,168164,143810,51393,25548,169307,32896,24485,38424,21837,29087,275813,51674,6714,64883,46169,187369,55186,76192,12852,12018,62134,31067,118303,16542,12125,10579,4928,26291,43854,7091,10946,253716,109062,39283,17261,113012,258512,47764,125126,32646,55892,80279,201623,149872,3192,385,1208,48750,5376,58738,22335,5427,82416,47811,32435,143086,38930,94128,59975,156037,37977,38224,62485,7698,50405,71027,16462,21559,136153,34131,107506,162069,63703,3101,215029,40407,4178,3774,9187,80019,17880,97926,67579,2600,18405,8351,47924,86638,70820,92206,86453,29610,42241,119200,3198,15466,67813,57863,35454,4779,99518,4649,104641,144269,33730,38073,65864,6838,109456,193298,154007,5623,45741,30846,182578,25573,157224,1543,58575,138703,146140,44971,49356,18275,59064,20300,13122,11848,24453,11973,9797,86843,2919,25530,49210,1130,161220,76788,75373,85604,34926,36014,17777,17255,51533,11676,92226,51845,119859,21525,5936,18507,28050,1140,31418,14857,34207,47859,10750,36382,32079,106909,59426,87757,38393,110042,15965,97104,33757,35344,97993,53979,33651,45407,41884,82515,173089,7177,58371,35365,47543,51927,35587,10670,23544,29306,84233,39976,76076,62097,9007,8668,28119,78281,120790,19835,143020,54968,18670,64959,20649,34469,42570,33001,136570,87796,120044,1106,58700,63951,127623,12805,83057,40212,31773,49850,7361,54336,347524,101314,23751,19569,48791,29174,49369,20467,7465,75842,38281,623,112457,60210,28849,51003,94720,6426,90047,85560,43761,3579,85105,34607,90410,118528,7224,42907,111163,18168,6960,161135,191298,5247,100584,127552,171568,20121,91173,12636,54615,20199,63730,98105,2396,40387,14438,125012,4765,33235,12865,45299,37728,82098,77872,114037,59253,19675,24838,398016,102561,11446,17069,57508,178277,65836,99941,26114,2585,271882,136866,50126,11027,155648,118367,14585,8910,123015,335383,40434,41016,53021,14439,87098,176860,201543,121888,2358,9286,5739,22666,54270,37884,169381,33984,93859,16124,89364,72207,51639,76366,99029,65812,2198,12147,174891,194289,6986,30252,88822,21284,11445,288337,160821,33034,100869,43852,25761,52882,1144,103809,1924,84458,86079,43411,13542,139276,18141,34978,41298,7276,26481,173800,33210,17951,142652,33616,33677,2210,19941,98568,2486,192414,80136,12058,235883,50963,249638,29572,27221,47034,6124,72107,63346,97620,158513,299699,40388,23235,37176,224244,198386,121323,67992,23827,63170,17838,106622,158590,26807,5345,23489,91891,55474,74834,37981,13058,5977,72552,34706,26828,145172,19904,21367,34043,960,77092,91381,4733,47446,7680,41697,5170,16960,14741,46101,13656,473,51842,37433,11103,11551,121951,13191,97536,165932,50397,51628,129028,9069,44885,6590,59195,47045,32940,225472,90345,21833,13303,29407,96615,141951,5198,6028,18395,7181,3861,14966,156358,167182,36529,55253,25942,173153,30959,27261,50691,150176,162201,38467,48462,80602,42163,118482,168,108756,26011,17166,54149,456538,22512,91374,13816,90358,131615,18132,226707,1824,28139,26860,42253,93877,77351,65575,8980,80574,22020,27948,40422,91324,76376,13528,39281,91685,82215,122541,144066,1983,193851,17283,26320,2739,194978,4790,26845,42627,61300,65815,174612,55133,4200,191130,79771,158321,52280,166796,221620,62461,11278,4067,88152,83409,31717,121367,13522,47325,37945,10406,174348,249321,154101,64912,29938,51775,17220,15776,166138,78890,84425,54121,42861,16368,24572,291647,10197,32073,22651,11677,97509,26952,35787,18424,41910,71614,94977,72318,41594,70024,275419,37702,60199,7335,39107,61315,18271,18394,33768,87884,104277,123724,7277,56288,71981,189803,49320,3352,6798,14240,8954,69220,94433,57372,28620,68863,193727,85575,42309,41667,67689,42081,22543,44824,12719,28540,114236,101553,27638,27296,4300,5353,4663,19379,94098,3758,95888,95144,80344,87320,28447,259518,12718,71391,152731,37063,24132,31911,104896,15672,103782,1521,4945,72541,23717,122632,15619,87175,206120,29428,189780,61416,28350,44457,972,1175,47233,198738,95789,41907,21953,97034,59341,22864,53713,16873,32971,20693,20954,31336,21477,16169,38370,16412,9019,3841,24599,21938,17085,6484,81198,76413,5849,72514,12320,65247,276175,37234,59796,52642,16312,57349,198507,94148,46134,18958,125552,1747,18725,151873,14901,5490,68287,29470,3689,64794,40814,26018,25692,54450,2703,88278,124886,173087,174e3,24159,179477,24276,46004,201876,209202,445,52876,31948,30206,157610,39180,18439,44124,50469,5774,96278,222758,200216,50290,45486,20435,46986,46276,140133,142326,15569,13363,47522,92583,2182,7135,16853,22998,30272,4952,63263,35623,39096,53789,44864,20053,110392,124213,4630,16087,28221,127787,25839,77481,44693,13464,113146,6983,27069,55717,50102,4760,7107,26186,66507,59145,36032,104182,71328,29425,64317,50781,47465,94298,69706,74899,22754,120756,25108,93077,56834,73286,39928,16218,41699,176763,7555,70819,50083,26895,23315,26014,16773,123079,41712,5719,31516,90427,158540,85051,183128,40864,27505,55392,9058,45224,96857,30901,136622,96557,56304,120061,11501,151448,5773,89743,7769,86069,2935,18471,41628,10114,33660,110170,49479,26745,92846,33221,26731,18795,87076,8550,2100,29972,120289,3077,72490,33784,2630,208722,50861,63483,79029,6419,39467,14302,45286,64207,9686,67513,44170,1050,77246,59266,17055,53801,7150,11111,42432,4278,94579,362117,36175,42902,41933,39002,98489,22913,74161,84773,57036,17556,162288,74485,178760,93867,73635,128860,50362,261,67455,80001,46080,35662,4368,25247,19230,74393,22588,1822,27682,235324,13798,85998,13194,235067,23514,71669,147632,23191,134748,214683,105101,1518,25489,247114,7380,54842,26922,3971,26361,20844,68642,170517,77339,123255,8963,77818,150998,48466,36806,2732,23261,11741,236162,18243,126216,28690,50546,16385,92760,197383,246558,201295,88255,67588,71687,176076,172653,169058,33906,63747,24835,157621,43338,30050,46152,132741,2770,51371,94835,6614,15112,11749,56936,1250,19027,399017,58036,100215,23388,55815,308768,124152,94803,9521,64186,8971,28,30427,62163,7616,103838,35079,29203,131235,7743,17389,10882,37420,61460,228512,85363,41581,131077,62822,119647,10130,54445,26925,19968,29016,24446,74028,24176,61448,67185,9254,8563,119129,9771,99184,37716,39514,10532,221512,258753,218630,55980,23394,32141,61924,66749,32411,3741,36475,26678,77010,44946,91203,128749,116953,20476,49625,53116,13735,102335,29376,51946,83407,67892,59212,34685,21083,1546,112982,32972,74397,1078,190545,16082,86140,58591,89611,101531,10061,105104,76319,20035,17551,52611,169061,190842,100780,23907,90413,115619,9675,34710,193435,49443,129734,11183,258877,16318,136182,126808,44635,27304,192375,2599,125648,47051,12091,23814,721,58800,40137,66726,97930,60877,74487,7942,54326,9841,41428,13762,8211,85383,6950,99177,79806,201786,296464,124087,13144,29741,41721,47634,55088,254286,106408,17041,99064,12942,64086,45233,14005,2612,55827,255,7984,13980,38574,12776,46654,73499,249951,2101,26676,25996,132326,116415,119062,50449,31033,23038,11589,179252,20007,14860,129270,21143,17796,144715,60106,70758,69842,34674,282133,44014,16774,57268,38528,24053,46373,201667,28327,471023,51889,102667,21193,114909,84132,69317,96723,67969,16134,68145,15058,28765,32035,2524,101089,98664,25045,76571,14957,86040,118506,262428,154764,81573,39681,283900,73287,127825,544,80448,52347,38512,175971,15180,45467,33086,46552,48894,81107,43213,36672,54025,76703,8053,7608,13299,56619,20752,238099,54164,105133,1444,32942,953,37564,8e3,66316,119463,106817,404,13667,149108,128597,31267,10269,49836,106150,1484,52330,76965,160486,171648,38456,31263,22424,37738,66245,67467,143369,60471,75610,20895,115528,86070,60854,40796,49347,18989,15030,11371,37578,15779,79867,10187,86462,46402,155626,93200,40229,7090,57547,108053,99598,11088,47505,41218,206017,2173,20988,30219,22919,80563,57566,42369,93141,41675,2407,182519,120495,27154,16702,29456,14349,7958,16688,117177,140375,42467,261919,74916,153569,10836,34742,49526,7621,105997,12212,2270,392377,7755,17959,25086,232152,138791,33847,13860,35316,5811,1344,71259,50452,207539,92635,50359,5821,33674,30255,2086,2587,96264,17543,42,6029,9580,43007,139248,82831,12917,29607,25786,51467,42137,85161,100698,31561,88989,121990,278500,3602,109344,37982,15279,116442,28936,30880,87894,58079,128661,126731,67392,28051,146885,4861,16216,97344,42827,147561,153948,22684,21335,47685,1853,43349,15185,59642,10229,25520,187921,108972,5579,98037,24945,6697,19193,63734,137934,75056,89740,19767,224268,56138,63643,151661,39313,70618,84031,89723,84074,13703,85626,35460,8867,64845,3439,57906,99776,63968,49270,81130,34356,16210,23547,36446,34090,140028,72439,2221,22163,57058,363492,113754,18913,95451,48663,54464,54037,176097,68425,3023,34906,29482,117389,341780,80431,58330,16753,92616,60907,94846,147486,4498,48646,7773,46801,7778,18946,464978,47558,33223,177444,7328,15626,63337,94700,11743,9351,255024,39098,16447,42647,96230,39769,58840,10068,63439,35800,65843,58823,413844,9156,51258,7434,61791,85018,6872,3692,28096,7121,33024,6009,75532,31997,192535,9661,3304,9547,14753,31987,25314,55689,15896,20430,39472,31340,99744,25398,115569,54883,28719,205423,23071,57855,64638,149867,25671,82403,37616,20668,39989,77996,74948,140555,175248,64810,36515,46595,4958,248773,24045,28728,136673,168704,20804,114833,100325,27135,21205,96151,153134,45992,7093,13992,76047,1980,19432,145001,75159,87462,17710,1013,45556,34297,144882,20648,26061,11319,129567,108555,18872,464580,33386,22717,65948,167189,5603,135042,79542,8801,202632,18114,91882,5973,5239,67315,4431,60916,47819,71693,32597,32606,18183,45072,80329,76385,24749,51305,40314,156514,14693,130345,13168,66214,18029,12858,34801,27628,14544,10823,40522,40185,33739,148694,23548,9923,61012,28859,17933,19442,34364,99849,164107,141167,30629,21054,6744,36491,8096,42474,41706,155060,30650,10600,163442,1143,96655,61390,52359,7559,51568,64256,203854,4467,22453,14504,436398,7878,6980,8293,63610,293747,16167,35763,19627,147603,15419,18032,110744,51346,33681,54571,40472,48615,39073,21604,13754,173027,92560,11083,47299,63062,11813,52007,29883,9734,139722,15953,1550,20651,13616,49306,16113,90089,92326,7584,30712,72424,164858,6831,152871,55746,197721,34167,196442,6022,112107,55215,7538,123381,4920,43539,77165,8939,50392,34192,20225,79762,22505,58667,40770,29788,97180,82835,4568,8579,13273,363569,35898,49983,436,36598,3237,131691,62418,35591,8101,4073,379438,65218,76072,33887,2968,27573,212619,288680,68278,72851,150504,217896,6913,121339,22017,35340,51072,43616,75043,31437,10833,81487,4364,22968,41454,106687,85446,19863,109625,149241,524,141850,214404,54376,657,237023,9401,108137,53800,32474,49712,53334,126876,27337,45552,177696,8269,15036,12097,42240,2328,125374,119295,99715,2500,19624,39441,27220,102691,60957,94543,39101,18566,67362,13975,78230,25017,34017,239007,90027,39351,41681,35354,43822,1043,916,58587,141983,94818,38799,75459,41114,67432,16195,36606,59568,22272,126769,31424,68659,12287,134302,257977,5756,207285,95637,47248,117689,19583,77451,22373,12200,54993,117118,34244,29386,34562,53819,71267,64172,77665,49368,7716,59301,25749,45426,194789,17297,2650,1766,32501,45198,20403,20984,6600,14171,94604,19037,5402,29896,9938,59935,109708,88081,145182,44844,39167,352626,164173,35374,45982,6122,154,73419,220487,53834,53601,17992,8609,229321,5610,68098,66815,71012,95069,140968,27396,8957,134489,24656,86659,56598,134852,17316,123838,255436,6613,41610,138033,81452,32023,32396,123687,63398,8693,29712,30407,19296,121188,3551,36099,20032,111948,56624,16547,27453,35916,15378,52039,56849,13489,22214,73177,53097,277349,2157,14029,187886,10260,141743,246460,91880,50869,3788,49486,133566,54950,33120,129337,53768,18333,9525,26902,312251,10297,9020,70759,16647,112432,59260,84609,9818,82766,73569,468,46001,75780,55028,52106,11498,43645,108069,17150,17753,29417,16705,31799,9606,289,122254,115975,8620,6133,255357,56908,14456,133464,43554,79224,11247,29630,160,12756,25464,65960,350428,62521,321796,100359,67358,35169,46172,113128,48988,88868,31094,33266,6847,60887,98188,49659,69117,92977,220228,13947,80181,35103,62170,97351,13475,2440,199768,19498,36597,46971,25234,67806,62881,84717,73648,181966,10488,94149,21550,26655,63436,48375,14405,165650,9621,24439,28043,42735,4490,29963,56674,45373,1934,262446,50855,67098,26898,5261,52696,40644,33900,9440,180286,87162,22940,19704,26936,69769,10254,101759,27406,12243,48e3,73926,113215,54935,5726,192787,4312,106216,9366,11550,52949,23457,212271,277152,133895,108374,6191,96477,29980,218916,58024,54696,40853,91124,65894,91170,65908,252552,6793,29212,15389,44516,122515,52617,35058,9017,103536,39510,49136,19242,130652,662077,74699,47024,31422,8517,73351,24399,13867,128360,4810,4434,61779,111983,61036,17798,110240,59722,102960,39688,10001,23803,23039,176498,56659,44814,134295,17188,77577,74466,226175,102472,154333,63900,111747,18062,41171,79669,32773,408933,42562,28931,30907,107388,43487,2946,240310,23938,24354,319,184983,7927,6488,1422,10790,68809,68209,64775,4361,202,17123,59634,51200,44391,18188,17843,2619,74278,3230,9540,47187,21702,36274,56894,43907,16310,34790,16866,6150,5561,13587,107545,108873,126867,86986,28640,33427,19017,5762,80637,17430,46903,2047,131055,25958,13558,5444,47152,13900,44563,122857,45348,70863,39593,54332,38068,33637,318,40310,143467,18502,24520,11377,62013,28942,27246,28269,83545,17999,59015,90707,30065,15161,34720,1263,37008,2012,6060,98575,92933,5721,299,199555,24578,29223,2985,743,115825,109523,136657,47454,26378,53586,3733,174945,93340,244456,5693,37386,28782,89767,27545,23573,18798,136425,34320,84778,20041,48453,38215,7477,71958,40621,8773,5874,187927,105965,51100,43533,18083,8443,10180,43597,2003,183999,69689,12216,129696,146188,62389,34044,68410,12765,43273,26949,266807,3345,34477,79197,5688,47539,213110,21634,22257,50092,32222,42346,39530,63668,98,134978,74022,5152,59088,174145,37220,9934,9545,118937,5724,87240,19875,15784,40143,23263,87513,181654,285152,37881,263241,4966,43934,10433,186657,6470,74416,225854,25908,142677,246262,32280,6192,75890,45546,143264,135305,29742,47013,77787,11732,126658,8763,37950,21806,57557,113464,89465,108995,164574,23894,22996,23169,15369,23117,17642,130607,40503,36239,280990,44666,9981,40427,147487,26869,168452,32886,32991,46798,240839,15111,70502,65697,88548,44145,28701,48767,31139,206777,35659,181164,166262,14554,171445,31786,66523,76607,17956,6507,31279,90476,116611,167918,6560,1243,115324,80128,41867,55897,187323,37069,32596,189444,145931,13390,105530,65709,26805,6999,55714,41300,22915,68951,22138,21120,22264,10058,19945,33635,56123,99085,10032,5818,6016,46649,57476,35264,94413,112522,262288,93686,83038,14341,23204,28807,66084,77987,6101,126673,7133,38126,5923,122091,170240,97772,46874,215746,43948,41622,3272,55596,8332,146411,251315,13533,8561,81521,115449,48616,175175,2063,186556,3036,134537,75772,29728,82360,22973,186559,86348,89100,38388,82297,45610,2613,87082,9986,177812,57884,23591,47485,42543,33582,44713,74439,257444,252451,31825,35631,38540,33066,5147,13973,4343,51830,70378,22827,26448,95560,36896,241741,48067,203953,298860,61620,20450,3220,67272,6586,107662,100160,108684,6929,57226,4762,7457,1320,40404,77204,99309,62750,208653,59977,44e3,74315,34332,5819,172217,64904,114077,18147,84012,1791,98456,90930,21446,116669,103938,7422,85140,59713,5768,326211,16239,75411,13229,29398,10758,236107,1539,112472,95979,152154,151294,306,21196,38146,10700,6891,84282,109646,56492,40539,6589,119491,51354,30685,140209,136906,29622,73617,49553,70525,51671,166869,139616,74395,37439,49595,45678,11959,33211,86560,52434,9282,62690,112155,130810,5243,108261,99970,265613,72551,80049,6391,33365,90721,66737,69872,87011,1860,9032,112544,60905,37371,89015,140351,19076,850,373531,2802,36725,218795,72062,28990,16550,24614,7815,6187,26336,33373,32162,42791,73555,32062,23386,10244,56392,49442,27076,136262,12412,14883,1134,33675,97153,199281,15608,100152,74072,47942,254301,36451,16026,10687,65067,56708,254030,30290,50490,13864,57941,259331,35588,23485,43486,24869,21620,92971,22072,88645,1048,182050,13343,32452,14825,19509,3325,216938,45740,99716,189082,53740,78245,25609,24311,176777,47340,308354,40669,66085,14102,125339,9225,128709,97207,1271,200933,78439,113451,88975,18324,46521,11819,18570,141756,72512,170020,52754,63550,118515,103073,93330,32736,50499,14722,31600,68452,398867,29316,172786,18417,104924,2606,5670,84818,16288,67106,59580,82929,607401,291,85829,359,15897,35830,50696,65630,52672,22115,356968,29895,40837,231192,34024,38957,26722,406,23335,124952,72068,68804,13268,147101,164740,276569,162596,66943,11569,26654,66358,4777,23229,102127,5848,978,2921,59666,5371,28212,90108,42938,39320,2499,4271,108792,33510,125072,71653,65239,38250,66357,38577,13964,86251,35708,50755,36010,29448,12209,3844,38222,206337,100876,67827,137088,14167,252225,84163,195270,1306,5703,54198,779,46802,22028,51124,86759,70560,113164,35685,162145,45471,34561,422,2611,6464,47486,19223,38246,9191,18331,89942,243642,212364,15893,17518,22617,6409,30046,126182,59716,36560,104428,18846,26592,19458,50793,147333,30826,1388,27647,10922,14495,33545,19269,135828,39727,41601,46931,233379,49169,131130,182112,16276,82381,118209,142445,128310,19672,28740,82907,33436,3118,102206,28723,24819,41937,38854,5157,3881,111491,1142,9776,421673,152241,29309,14961,87854,6054,15424,3796,82656,54996,2108,55367,239450,154525,9643,118103,106041,64601,68549,48707,30266,25772,18740,9462,229669,91798,112152,191327,14493,72828,8175,66636,236474,25817,87351,129027,76653,20422,22983,71240,27846,44661,12399,46158,77704,53101,35032,11072,17300,109294,33638,24408,1895,11241,760,17584,82479,125877,63150,141075,34259,23274,81698,15732,43577,48340,91584,14688,16379,24481,150280,96420,262050,48635,43727,61819,56268,72003,88178,17281,79912,13218,122519,125295,166396,11811,2171,118930,67746,17636,178278,174656,95661,173039,83845,79689,17473,98555,127696,203415,54730,22925,232239,9309,12136,175026,20740,180188,10747,39816,314017,266131,10040,175732,112550,220651,31974,37393,888,23008,86799,4303,64905,148467,75337,251,3284,370102,50264,9835,5438,23655,4481,29851,329,12855,7162,64931,78141,12804,42372,296771,83547,18624,34874,86271,3360,48665,77735,88767,11463,63527,28889,22258,29140,194315,113924,25499,6406,31334,1845,4802,49184,43455,35469,127594,92970,61038,115005,38840,87761,106838,8811,20572,55637,11162,96721,132425,108925,2948,125457,36356,3502,75270,27622,127192,2561,123095,49394,61155,16897,110064,9699,89448,53356,19628,220310,21622,83036,9885,112214,6087,26713,17901,161912,91492,3440,68594,9266,92238,8087,6866,150194,72175,80701,13459,31836,43243,239700,95846,44749,50647,21945,230538,120612,132371,244604,5193,105637,34661,41341,68775,85393,1874,8771,33718,49672,77403,595452,99507,6490,58895,128742,7704,39239,73217,43816,62824,37804,199976,22361,80005,87514,94832,14089,4574,139975,59142,75523,100268,43906,53442,15152,2547,186002,17011,19513,204282,3343,60568,128318,119250,4298,51871,41336,71759,21921,45074,98169,145889,99427,11350,1237,5520,28799,7803,53702,21026,136352,38293,128690,12158,90132,44600,10184,26957,39459,126025,78904,82999,59373,39301,150198,120529,153042,20177,50089,14764,271571,30530,123161,38975,101562,22941,5648,124654,109243,69817,71675,49162,106884,21241,107795,30258,16572,188262,141456,7688,60718,8271,11044,32440,104608,103419,236109,93156,43293,128929,42107,67180,25201,115254,185488,130954,72813,167547,20537,39969,38432,22582,184022,1139,27199,5655,17767,97412,122606,209377,27070,35871,326617,188954,42680,73512,80911,22629,3011,95021,315242,157737,383,41821,41808,19335,27950,15674,25677,110950,35375,76835,59108,57370,35262,16569,160415,37706,78086,32041,49691,137143,9782,172080,50148,77917,6323,10110,69172,17711,21795,59511,76184,135114,31046,132319,59105,157578,20549,80778,57649,158421,65143,4575,72235,21899,10797,92745,34035,106079,80159,4508,78304,25350,75457,46458,32937,25623,47,8531,104751,84953,8138,36508,187199,66310,115274,13253,32461,38536,1916,42007,187160,35055,26325,84394,35963,94216,45590,97782],Ho=15;class CC{log;peerRouting;routingTable;refreshInterval;refreshQueryTimeout;commonPrefixLengthRefreshedAt;refreshTimeoutId;constructor(e,t){const{peerRouting:r,routingTable:s,refreshInterval:i,refreshQueryTimeout:o,logPrefix:a}=t;this.log=e.logger.forComponent(`${a}:routing-table:refresh`),this.peerRouting=r,this.routingTable=s,this.refreshInterval=i??kP,this.refreshQueryTimeout=o??IP,this.commonPrefixLengthRefreshedAt=[],this.refreshTable=this.refreshTable.bind(this)}async afterStart(){this.log(`refreshing routing table every ${this.refreshInterval}ms`),this.refreshTable(!0)}async stop(){this.refreshTimeoutId!=null&&clearTimeout(this.refreshTimeoutId)}refreshTable(e=!1){this.log("refreshing routing table");const t=this._maxCommonPrefix(),r=this._getTrackedCommonPrefixLengthsForRefresh(t);this.log(`max common prefix length ${t}`),this.log(`tracked CPLs [ ${r.map(s=>s.toISOString()).join(", ")} ]`),Promise.all(r.map(async(s,i)=>{try{if(await this._refreshCommonPrefixLength(i,s,e),this._numPeersForCpl(t)===0){const o=Math.min(2*(i+1),r.length-1);for(let a=i+1;a<o+1;a++)try{await this._refreshCommonPrefixLength(a,s,e)}catch(c){this.log.error(c)}}}catch(o){this.log.error(o)}})).catch(s=>{this.log.error(s)}).then(()=>{this.refreshTimeoutId=setTimeout(this.refreshTable,this.refreshInterval),this.refreshTimeoutId.unref!=null&&this.refreshTimeoutId.unref()}).catch(s=>{this.log.error(s)})}async _refreshCommonPrefixLength(e,t,r){if(!r&&t.getTime()>Date.now()-this.refreshInterval){this.log("not running refresh for cpl %s as time since last refresh not above interval",e);return}const s=await this._generateRandomPeerId(e);this.log("starting refreshing cpl %s with key %p (routing table size was %s)",e,s,this.routingTable.size);const i=AbortSignal.timeout(this.refreshQueryTimeout),o=await O4(this.peerRouting.getClosestPeers(s.toMultihash().bytes,{signal:i}));this.log(`found ${o} peers that were close to imaginary peer %p`,s),this.log("finished refreshing cpl %s with key %p (routing table size is now %s)",e,s,this.routingTable.size)}_getTrackedCommonPrefixLengthsForRefresh(e){e>Ho&&(e=Ho);const t=[];for(let r=0;r<=e;r++)t[r]=this.commonPrefixLengthRefreshedAt[r]??new Date;return t}async _generateRandomPeerId(e){if(this.routingTable.kb==null)throw new Error("Routing table not started");if(this.routingTable.kb.localPeer==null)throw new Error("Local peer not set");const t=un(2),r=(t[1]<<8)+t[0],s=await this._makePeerId(this.routingTable.kb.localPeer.kadId,r,e),i=je(s);return Ft(i)}async _makePeerId(e,t,r){if(r>Ho)throw new Error(`Cannot generate peer ID for common prefix length greater than ${Ho}`);const o=new DataView(e.buffer,e.byteOffset,e.byteLength).getUint16(0,!1)^32768>>r,a=65535<<16-(r+1),c=o&a|t&~a,l=PC[c],u=new ArrayBuffer(34),h=new DataView(u,0,u.byteLength);return h.setUint8(0,Nt.code),h.setUint8(1,32),h.setUint32(2,l,!1),new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}_maxCommonPrefix(){let e=0;for(const t of this._prefixLengths())t>e&&(e=t);return e}_numPeersForCpl(e){let t=0;for(const r of this._prefixLengths())r===e&&t++;return t}*_prefixLengths(){if(this.routingTable.kb?.localPeer!=null)for(const{kadId:e}of this.routingTable.kb.toIterable()){const t=hn(this.routingTable.kb.localPeer.kadId,e);let r=0;for(const s of t)if(s===0)r++;else break;yield r}}}const DC=8,rd=1024*1024*4;class RC extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class U4 extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class MC extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}class c0 extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function $4(n){return n[Symbol.asyncIterator]!=null}function V4(n,e){if(n.byteLength>e)throw new U4("Message length too long")}const Tc=n=>{const e=ye(n),t=ct(e);return Ze(n,t),Tc.bytes=e,t};Tc.bytes=0;function H4(n,e){e=e??{};const t=e.lengthEncoder??Tc,r=e?.maxDataLength??rd;function*s(i){V4(i,r);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return $4(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}H4.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??Tc,r=e?.maxDataLength??rd;return V4(n,r),new ge(t(n.byteLength),n)};var Dn;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Dn||(Dn={}));const nd=n=>{const e=ar(n);return nd.bytes=ye(e),e};nd.bytes=0;function Ru(n,e){const t=new ge;let r=Dn.LENGTH,s=-1;const i=e?.lengthDecoder??nd,o=e?.maxLengthLength??DC,a=e?.maxDataLength??rd;function*c(){for(;t.byteLength>0;){if(r===Dn.LENGTH)try{if(s=i(t),s<0)throw new RC("Invalid message length");if(s>a)throw new U4("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),r=Dn.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new MC("Message length length too long");break}throw l}if(r===Dn.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,r=Dn.LENGTH}}}return $4(n)?async function*(){for await(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new c0("Unexpected end of input")}():function*(){for(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new c0("Unexpected end of input")}()}Ru.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Ru(r,{...e??{},onLength:i=>{t=i}})};class LC{peerId;providers;peerStore;log;constructor(e,t){this.log=e.logger.forComponent(`${t.logPrefix}:rpc:handlers:add-provider`),this.peerId=e.peerId,this.providers=t.providers,this.peerStore=e.peerStore}async handle(e,t){if(t.key==null||t.key.length===0)throw new Pe("Missing key");let r;try{r=Y.decode(t.key)}catch{throw new Pe("Invalid CID")}(t.providers==null||t.providers.length===0)&&this.log.error("no providers found in message"),this.log("%p asked us, %p to store provider record for for %c",e,this.peerId,r),await Promise.all(t.providers.map(async s=>{const i=je(s.id),o=Ft(i),a=s.multiaddrs.map(c=>re(c));if(!e.equals(o)){this.log("invalid provider peer %p from %p",s.id,e);return}if(s.multiaddrs.length<1){this.log("no valid addresses for provider %p. Ignore",e);return}this.log.trace("received provider %p for %s (addrs %s)",e,r,a),await this.providers.addProvider(r,o),await this.peerStore.merge(o,{multiaddrs:a})}))}}class NC{peerRouting;peerInfoMapper;peerId;addressManager;log;constructor(e,t){const{peerRouting:r,logPrefix:s}=t;this.log=e.logger.forComponent(`${s}:rpc:handlers:find-node`),this.peerId=e.peerId,this.addressManager=e.addressManager,this.peerRouting=r,this.peerInfoMapper=t.peerInfoMapper}async handle(e,t){if(this.log("incoming request from %p for peers closer to %b",e,t.key),t.key==null)throw new Pe("Invalid FIND_NODE message received - key was missing");const r=await this.peerRouting.getCloserPeersOffline(t.key,e);pe(this.peerId.toMultihash().bytes,t.key)&&r.push({id:this.peerId,multiaddrs:this.addressManager.getAddresses().map(i=>i.decapsulateCode(ne("p2p").code))});const s={type:ke.FIND_NODE,clusterLevel:t.clusterLevel,closer:r.map(this.peerInfoMapper).filter(({multiaddrs:i})=>i.length).map(i=>({id:i.id.toMultihash().bytes,multiaddrs:i.multiaddrs.map(o=>o.bytes)})),providers:[]};return s.closer.length===0&&this.log("could not find any peers closer to %b than %p",t.key,e),s}}class BC{peerId;peerRouting;providers;peerStore;peerInfoMapper;log;constructor(e,t){const{peerRouting:r,providers:s,logPrefix:i}=t;this.log=e.logger.forComponent(`${i}:rpc:handlers:get-providers`),this.peerId=e.peerId,this.peerStore=e.peerStore,this.peerRouting=r,this.providers=s,this.peerInfoMapper=t.peerInfoMapper}async handle(e,t){if(t.key==null)throw new Pe("Invalid GET_PROVIDERS message received - key was missing");let r;try{r=Y.decode(t.key)}catch{throw new Pe("Invalid CID")}this.log("%p asking for providers for %s",e,r);const[s,i]=await Promise.all([Ta(ni(await this.providers.getProviders(r),async a=>{const c=await this.peerStore.get(a);return{id:c.id,multiaddrs:c.addresses.map(({multiaddr:u})=>u)}})),this.peerRouting.getCloserPeersOffline(t.key,this.peerId)]),o={type:ke.GET_PROVIDERS,key:t.key,clusterLevel:t.clusterLevel,closer:i.map(this.peerInfoMapper).filter(({id:a,multiaddrs:c})=>c.length>0).map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)})),providers:s.map(this.peerInfoMapper).filter(({id:a,multiaddrs:c})=>c.length>0).map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)}))};return this.log("got %s providers %s closerPeers",o.providers.length,o.closer.length),o}async _getAddresses(e){return[]}}class OC{peerStore;datastore;peerRouting;log;datastorePrefix;constructor(e,t){this.log=e.logger.forComponent(`${t.logPrefix}:rpc:handlers:get-value`),this.datastorePrefix=`${t.datastorePrefix}/record`,this.peerStore=e.peerStore,this.datastore=e.datastore,this.peerRouting=t.peerRouting}async handle(e,t){const r=t.key;if(this.log("%p asked for key %b",e,r),r==null||r.length===0)throw new Pe("Invalid key");const s={type:ke.GET_VALUE,key:r,clusterLevel:t.clusterLevel,closer:[],providers:[]};if(VP(r)){this.log("is public key");const a=HP(r);let c;try{const l=await this.peerStore.get(a);if(l.id.publicKey==null)throw new It("No public key found in key book");c=rr(l.id.publicKey)}catch(l){if(l.name!=="NotFoundError")throw l}if(c!=null)return this.log("returning found public key"),s.record=new Kt(r,c,new Date).serialize(),s}const[i,o]=await Promise.all([this._checkLocalDatastore(r),this.peerRouting.getCloserPeersOffline(r,e)]);return i!=null&&(this.log("had record for %b in local datastore",r),s.record=i.serialize()),o.length>0&&(this.log("had %s closer peers in routing table",o.length),s.closer=o.map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)}))),s}async _checkLocalDatastore(e){this.log("checkLocalDatastore looking for %b",e);const t=Ci(this.datastorePrefix,e);let r;try{r=await this.datastore.get(t)}catch(i){if(i.name==="NotFoundError")return;throw i}const s=Kt.deserialize(r);if(s.timeReceived==null||Date.now()-s.timeReceived.getTime()>gP){await this.datastore.delete(t);return}return s}}class FC{log;constructor(e,t){this.log=e.logger.forComponent(`${t.logPrefix}:rpc:handlers:ping`)}async handle(e,t){return this.log("ping from %p",e),t}}class UC{components;validators;log;datastorePrefix;constructor(e,t){const{validators:r}=t;this.components=e,this.log=e.logger.forComponent(`${t.logPrefix}:rpc:handlers:put-value`),this.datastorePrefix=`${t.datastorePrefix}/record`,this.validators=r}async handle(e,t){const r=t.key;if(this.log("%p asked us to store value for key %b",e,r),t.record==null){const s=`Empty record from: ${e.toString()}`;throw this.log.error(s),new Pe(s)}try{const s=Kt.deserialize(t.record);await ed(this.validators,s),s.timeReceived=new Date;const i=Ci(this.datastorePrefix,s.key);await this.components.datastore.put(i,s.serialize().subarray()),this.log("put record for %b into datastore under key %k",r,i)}catch(s){this.log("did not put record for key %b into datastore %o",r,s)}return t}}class $C{handlers;routingTable;log;metrics;constructor(e,t){this.metrics={operations:e.metrics?.registerCounterGroup(`${t.metricsPrefix}_inbound_rpc_requests_total`),errors:e.metrics?.registerCounterGroup(`${t.metricsPrefix}_inbound_rpc_errors_total`)},this.log=e.logger.forComponent(`${t.logPrefix}:rpc`),this.routingTable=t.routingTable,this.handlers={[ke.GET_VALUE.toString()]:new OC(e,t),[ke.PUT_VALUE.toString()]:new UC(e,t),[ke.FIND_NODE.toString()]:new NC(e,t),[ke.ADD_PROVIDER.toString()]:new LC(e,t),[ke.GET_PROVIDERS.toString()]:new BC(e,t),[ke.PING.toString()]:new FC(e,t)}}async handleMessage(e,t){const r=this.handlers[t.type];if(r==null){this.log.error(`no handler found for message type: ${t.type}`);return}try{return this.metrics.operations?.increment({[t.type]:!0}),await r.handle(e,t)}catch{this.metrics.errors?.increment({[t.type]:!0})}}onIncomingStream(e){let t="unknown";Promise.resolve().then(async()=>{const{stream:r,connection:s}=e,i=s.remotePeer,o=this;await Bt(r,a=>Ru(a),async function*(a){for await(const c of a){const l=Fn.decode(c);t=l.type,o.log("incoming %s from %p",l.type,i);const u=await o.handleMessage(i,l);u!=null&&(yield Fn.encode(u))}},a=>H4(a),r)}).catch(r=>{this.log.error("error handling %s RPC message from %p - %e",t,e.connection.remotePeer,r)})}}class VC extends Ke{log;components;protocol;running;registrarId;constructor(e,t){super();const{protocol:r,logPrefix:s}=t;this.components=e,this.log=e.logger.forComponent(`${s}:topology-listener`),this.running=!1,this.protocol=r}isStarted(){return this.running}async start(){this.running||(this.running=!0,this.registrarId=await this.components.registrar.register(this.protocol,{onConnect:e=>{this.log("observed peer %p with protocol %s",e,this.protocol),this.dispatchEvent(new CustomEvent("peer",{detail:e}))}}))}async stop(){this.running=!1,this.registrarId!=null&&(this.components.registrar.unregister(this.registrarId),this.registrarId=void 0)}}class HC{dht;constructor(e){this.dht=e}async provide(e,t={}){await pn(this.dht.provide(e,t))}async cancelReprovide(e){await this.dht.cancelReprovide(e)}async*findProviders(e,t={}){for await(const r of this.dht.findProviders(e,t))r.name==="PROVIDER"&&(yield*r.providers)}async put(e,t,r){await pn(this.dht.put(e,t,r))}async get(e,t){for await(const r of this.dht.get(e,t))if(r.name==="VALUE")return r.value;throw new It("Could not find value for key")}}class zC{dht;constructor(e){this.dht=e}async findPeer(e,t={}){for await(const r of this.dht.findPeer(e,t))if(r.name==="FINAL_PEER")return r.peer;throw new It("Peer not found")}async*getClosestPeers(e,t={}){for await(const r of this.dht.getClosestPeers(e,t))r.name==="FINAL_PEER"&&(yield r.peer)}}const qC=32,KC=64;class WC extends Ke{protocol;routingTable;providers;network;peerRouting;components;log;running;kBucketSize;clientMode;validators;selectors;queryManager;contentFetching;contentRouting;routingTableRefresh;rpc;topologyListener;querySelf;maxInboundStreams;maxOutboundStreams;dhtContentRouting;dhtPeerRouting;peerInfoMapper;reprovider;constructor(e,t={}){super();const r=t.logPrefix??"libp2p:kad-dht",s=t.datastorePrefix??"/dht",i=t.metricsPrefix??"libp2p_kad_dht",o={queries:e.metrics?.registerMetricGroup(`${i}_operations_total`,{label:"operation"}),errors:e.metrics?.registerCounterGroup(`${i}_operation_errors_total`,{label:"operation"}),queryTime:e.metrics?.registerMetricGroup(`${i}_operation_time_seconds`,{label:"operation"}),errorTime:e.metrics?.registerMetricGroup(`${i}_operation_error_time_seconds`,{label:"operation"})};this.running=!1,this.components=e,this.log=e.logger.forComponent(r),this.protocol=t.protocol??mP,this.kBucketSize=t.kBucketSize??20,this.clientMode=t.clientMode??!0,this.maxInboundStreams=t.maxInboundStreams??qC,this.maxOutboundStreams=t.maxOutboundStreams??KC,this.peerInfoMapper=t.peerInfoMapper??UP;const a=Bh();this.providers=new tC(e,{...t.providers,logPrefix:r,datastorePrefix:s,lock:a}),this.validators={...OP,...t.validators},this.selectors={...NP,...t.selectors},this.network=new JP(e,{protocol:this.protocol,logPrefix:r,metricsPrefix:i}),this.routingTable=new TC(e,{kBucketSize:t.kBucketSize,pingOldContactTimeout:t.pingOldContactTimeout,pingOldContactConcurrency:t.pingOldContactConcurrency,pingOldContactMaxQueueSize:t.pingOldContactMaxQueueSize,pingNewContactTimeout:t.pingNewContactTimeout,pingNewContactConcurrency:t.pingNewContactConcurrency,pingNewContactMaxQueueSize:t.pingNewContactMaxQueueSize,protocol:this.protocol,logPrefix:r,metricsPrefix:i,prefixLength:t.prefixLength,splitThreshold:t.kBucketSplitThreshold,network:this.network});const c=ae();t.allowQueryWithZeroPeers===!0&&c.resolve(),this.queryManager=new nC(e,{disjointPaths:Math.ceil(this.kBucketSize/2),logPrefix:r,metricsPrefix:i,initialQuerySelfHasRun:c,routingTable:this.routingTable}),this.peerRouting=new eC(e,{routingTable:this.routingTable,network:this.network,validators:this.validators,queryManager:this.queryManager,logPrefix:r}),this.contentFetching=new XP(e,{validators:this.validators,selectors:this.selectors,peerRouting:this.peerRouting,queryManager:this.queryManager,network:this.network,logPrefix:r,datastorePrefix:s}),this.contentRouting=new jP(e,{network:this.network,peerRouting:this.peerRouting,queryManager:this.queryManager,routingTable:this.routingTable,providers:this.providers,logPrefix:r}),this.routingTableRefresh=new CC(e,{peerRouting:this.peerRouting,routingTable:this.routingTable,logPrefix:r}),this.rpc=new $C(e,{routingTable:this.routingTable,providers:this.providers,peerRouting:this.peerRouting,validators:this.validators,logPrefix:r,metricsPrefix:i,datastorePrefix:s,peerInfoMapper:this.peerInfoMapper}),this.topologyListener=new VC(e,{protocol:this.protocol,logPrefix:r}),this.querySelf=new cC(e,{peerRouting:this.peerRouting,interval:t.querySelfInterval,initialInterval:t.initialQuerySelfInterval,logPrefix:r,initialQuerySelfHasRun:c,routingTable:this.routingTable,operationMetrics:o}),this.reprovider=new lC(e,{...t.reprovide,logPrefix:r,metricsPrefix:i,datastorePrefix:s,contentRouting:this.contentRouting,lock:a,operationMetrics:o}),this.network.addEventListener("peer",l=>{const u=l.detail;this.onPeerConnect(u).catch(h=>{this.log.error("could not add %p to routing table",u.id,h)}),this.dispatchEvent(new CustomEvent("peer",{detail:u}))}),this.topologyListener.addEventListener("peer",l=>{const u=l.detail;Promise.resolve().then(async()=>{const h=await this.components.peerStore.get(u),d={id:u,multiaddrs:h.addresses.map(({multiaddr:f})=>f),protocols:h.protocols};await this.onPeerConnect(d)}).catch(h=>{this.log.error("could not add %p to routing table - %e",u,h)})}),this.dhtPeerRouting=new zC(this),this.dhtContentRouting=new HC(this),t.clientMode==null&&e.events.addEventListener("self:peer:update",l=>{this.log("received update of self-peer info"),Promise.resolve().then(async()=>{const u=l.detail.peer.addresses.some(({multiaddr:d})=>YP(d)),h=this.getMode();u&&h==="client"?await this.setMode("server"):h==="server"&&!u&&await this.setMode("client")}).catch(u=>{this.log.error("error setting dht server mode",u)})}),this.get=fs(this.get.bind(this),o,"GET_VALUE"),this.findProviders=fs(this.findProviders.bind(this),o,"FIND_PROVIDERS"),this.findPeer=fs(this.findPeer.bind(this),o,"FIND_PEER"),this.getClosestPeers=fs(this.getClosestPeers.bind(this),o,"GET_CLOSEST_PEERS"),this.provide=fs(this.provide.bind(this),o,"PROVIDE"),this.put=fs(this.put.bind(this),o,"PUT_VALUE")}[Symbol.toStringTag]="@libp2p/kad-dht";[rt]=["@libp2p/content-routing","@libp2p/peer-routing","@libp2p/peer-discovery"];[cn]=["@libp2p/identify"];get[As](){return this.dhtContentRouting}get[Ts](){return this.dhtPeerRouting}get[Qo](){return this}async onPeerConnect(e){if(this.log.trace("peer %p connected",e.id),e=this.peerInfoMapper(e),e.multiaddrs.length===0){this.log.trace("ignoring %p as there were no valid addresses in %s after filtering",e.id,e.multiaddrs.map(t=>t.toString()));return}try{await this.routingTable.add(e.id)}catch(t){this.log.error("could not add %p to routing table",e.id,t)}}isStarted(){return this.running}getMode(){return this.clientMode?"client":"server"}async setMode(e,t=!1){if(e===this.getMode()&&!t){this.log("already in %s mode",e);return}if(await this.components.registrar.unhandle(this.protocol),e===this.getMode()&&!t){this.log("already in %s mode",e);return}e==="client"?(this.log("enabling client mode while in %s mode",this.getMode()),this.clientMode=!0):(this.log("enabling server mode while in %s mode",this.getMode()),this.clientMode=!1,await this.components.registrar.handle(this.protocol,this.rpc.onIncomingStream.bind(this.rpc),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}))}async start(){this.running||(this.running=!0,await this.setMode(this.clientMode?"client":"server",!0),await Nr(this.routingTable,this.queryManager,this.network,this.topologyListener,this.routingTableRefresh,this.reprovider),await Nr(this.querySelf))}async stop(){this.running=!1,await wn(this.querySelf,this.queryManager,this.network,this.routingTable,this.routingTableRefresh,this.topologyListener,this.reprovider)}async*put(e,t,r={}){yield*this.contentFetching.put(e,t,r)}async*get(e,t={}){yield*this.contentFetching.get(e,t)}async*provide(e,t={}){yield*this.contentRouting.provide(e,this.components.addressManager.getAddresses(),t)}async cancelReprovide(e){await this.providers.removeProvider(e,this.components.peerId)}async*findProviders(e,t={}){yield*this.contentRouting.findProviders(e,t)}async*findPeer(e,t={}){yield*this.peerRouting.findPeer(e,t)}async*getClosestPeers(e,t={}){yield*this.peerRouting.getClosestPeers(e,t)}async refreshRoutingTable(){this.routingTableRefresh.refreshTable(!0)}}var Mu;(function(n){n[n.SEND_QUERY=0]="SEND_QUERY",n[n.PEER_RESPONSE=1]="PEER_RESPONSE",n[n.FINAL_PEER=2]="FINAL_PEER",n[n.QUERY_ERROR=3]="QUERY_ERROR",n[n.PROVIDER=4]="PROVIDER",n[n.VALUE=5]="VALUE",n[n.ADD_PEER=6]="ADD_PEER",n[n.DIAL_PEER=7]="DIAL_PEER"})(Mu||(Mu={}));function GC(n={}){return e=>new WC(e,n)}var Al,l0;function QC(){if(l0)return Al;l0=1;function n(t){return t>=55296&&t<=56319}function e(t){return t>=56320&&t<=57343}return Al=function(r,s,i){if(typeof s!="string")throw new Error("Input must be string");for(var o=s.length,a=0,c,l,u=0;u<o;u+=1){if(c=s.charCodeAt(u),l=s[u],n(c)&&e(s.charCodeAt(u+1))&&(u+=1,l+=s[u]),a+=r(l),a===i)return s.slice(0,u+1);if(a>i)return s.slice(0,u-l.length+1)}return s},Al}var Tl,u0;function YC(){if(u0)return Tl;u0=1;function n(t){return t>=55296&&t<=56319}function e(t){return t>=56320&&t<=57343}return Tl=function(r){if(typeof r!="string")throw new Error("Input must be string");for(var s=r.length,i=0,o=null,a=null,c=0;c<s;c++)o=r.charCodeAt(c),e(o)?a!=null&&n(a)?i+=1:i+=3:o<=127?i+=1:o>=128&&o<=2047?i+=2:o>=2048&&o<=65535&&(i+=3),a=o;return i},Tl}var Pl,h0;function XC(){if(h0)return Pl;h0=1;var n=QC(),e=YC();return Pl=n.bind(null,e),Pl}var Cl,d0;function ZC(){if(d0)return Cl;d0=1;var n=XC(),e=/[\/\?<>\\:\*\|"]/g,t=/[\x00-\x1f\x80-\x9f]/g,r=/^\.+$/,s=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,i=/[\. ]+$/;function o(a,c){if(typeof a!="string")throw new Error("Input must be string");var l=a.replace(e,c).replace(t,c).replace(r,c).replace(s,c).replace(i,c);return n(l,255)}return Cl=function(a,c){var l=c&&c.replacement||"",u=o(a,l);return l===""?u:o(u,"")},Cl}var jC=ZC();const JC=rs(jC),Dl={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function z4(n){const e="AES-GCM";let t=16;const r=12,s="SHA-256",i=16,o=32767,a=Er.get();t*=8;async function c(h,d){const f=a.getRandomValues(new Uint8Array(i)),p=a.getRandomValues(new Uint8Array(r)),m={name:e,iv:p};typeof d=="string"&&(d=V(d));let g;if(d.length===0){g=await a.subtle.importKey("jwk",Dl,{name:"AES-GCM"},!0,["encrypt"]);try{const b={name:"PBKDF2",salt:f,iterations:o,hash:{name:s}},w=await a.subtle.importKey("raw",d,{name:"PBKDF2"},!1,["deriveKey"]);g=await a.subtle.deriveKey(b,w,{name:e,length:t},!0,["encrypt"])}catch{g=await a.subtle.importKey("jwk",Dl,{name:"AES-GCM"},!0,["encrypt"])}}else{const b={name:"PBKDF2",salt:f,iterations:o,hash:{name:s}},w=await a.subtle.importKey("raw",d,{name:"PBKDF2"},!1,["deriveKey"]);g=await a.subtle.deriveKey(b,w,{name:e,length:t},!0,["encrypt"])}const y=await a.subtle.encrypt(m,g,h);return We([f,m.iv,new Uint8Array(y)])}async function l(h,d){const f=h.subarray(0,i),p=h.subarray(i,i+r),m=h.subarray(i+r),g={name:e,iv:p};typeof d=="string"&&(d=V(d));let y;if(d.length===0)try{const w={name:"PBKDF2",salt:f,iterations:o,hash:{name:s}},k=await a.subtle.importKey("raw",d,{name:"PBKDF2"},!1,["deriveKey"]);y=await a.subtle.deriveKey(w,k,{name:e,length:t},!0,["decrypt"])}catch{y=await a.subtle.importKey("jwk",Dl,{name:"AES-GCM"},!0,["decrypt"])}else{const w={name:"PBKDF2",salt:f,iterations:o,hash:{name:s}},k=await a.subtle.importKey("raw",d,{name:"PBKDF2"},!1,["deriveKey"]);y=await a.subtle.deriveKey(w,k,{name:e,length:t},!0,["decrypt"])}const b=await a.subtle.decrypt(g,y,m);return new Uint8Array(b)}return{encrypt:c,decrypt:l}}const eD=16,Lu=32,Nu=1e4;async function sd(n,e){const r=await z4().encrypt(n,e);return qt.encode(r)}async function f0(n,e,t){if(n.type==="RSA")return nD(n,e,t);if(n.type==="Ed25519")return tD(n,e,t);if(n.type==="secp256k1")return rD(n,e,t);throw new Xs}async function tD(n,e,t="libp2p-key"){if(t==="libp2p-key")return sd(ac(n),e);throw new B(`export format '${t}' is not supported`)}async function rD(n,e,t="libp2p-key"){if(t==="libp2p-key")return sd(ac(n),e);throw new B("Export format is not supported")}async function nD(n,e,t="pkcs-8"){if(t==="pkcs-8")return sD(n,e);if(t==="libp2p-key")return sd(ac(n),e);throw new B("Export format is not supported")}async function sD(n,e){const t=Er.get(),s=new ut({value:[new Fe({value:0}),new ut({value:[new Gr({value:"1.2.840.113549.1.1.1"}),new Oi]}),new Zr({valueHex:n.raw})]}).toBER(),i=new Uint8Array(s,0,s.byteLength),o=un(eD),a=await Y3(ec,e,o,{c:Nu,dkLen:Lu}),c=un(16),l=await t.subtle.importKey("raw",a,"AES-CBC",!1,["encrypt"]),u=await t.subtle.encrypt({name:"AES-CBC",iv:c},l,i),h=new ut({value:[new Zr({valueHex:o}),new Fe({value:Nu}),new Fe({value:Lu}),new ut({value:[new Gr({value:"1.2.840.113549.2.11"}),new Oi]})]}),d=new ut({value:[new Gr({value:"1.2.840.113549.1.5.13"}),new ut({value:[new ut({value:[new Gr({value:"1.2.840.113549.1.5.12"}),h]}),new ut({value:[new Gr({value:"2.16.840.1.101.3.4.1.42"}),new Zr({valueHex:c})]})]})]}),p=new ut({value:[d,new Zr({valueHex:u})]}).toBER(),m=new Uint8Array(p,0,p.byteLength);return["-----BEGIN ENCRYPTED PRIVATE KEY-----",...K(m,"base64pad").split(/(.{64})/).filter(Boolean),"-----END ENCRYPTED PRIVATE KEY-----"].join(`
`)}async function p0(n,e){try{const t=await iD(n,e);return dm(t)}catch{}if(!n.includes("BEGIN"))throw new B("Encrypted key was not a libp2p-key or a PEM file");return oD(n,e)}async function iD(n,e){const t=qt.decode(n);return z4().decrypt(t,e)}async function oD(n,e){const t=Er.get();let r;if(n.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")){const i=V(n.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","").replace("-----END ENCRYPTED PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=_i(i),{iv:a,salt:c,iterations:l,keySize:u,cipherText:h}=aD(o),d=await Y3(ec,e,c,{c:l,dkLen:u}),f=await t.subtle.importKey("raw",d,"AES-CBC",!1,["decrypt"]),p=Di(await t.subtle.decrypt({name:"AES-CBC",iv:a},f,h)),{result:m}=_i(p);r=g0(m)}else if(n.includes("-----BEGIN PRIVATE KEY-----")){const i=V(n.replace("-----BEGIN PRIVATE KEY-----","").replace("-----END PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=_i(i);r=g0(o)}else throw new B("Could not parse private key from PEM data");const s=fm(r);if(s.type!=="RSA")throw new B("Could not parse RSA private key from PEM data");return s}function aD(n){const e=n.valueBlock.value[0];if(e.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.13")throw new B("Only pkcs5PBES2 encrypted private keys are supported");const r=e.valueBlock.value[1].valueBlock.value[0];if(r.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.12")throw new B("Only pkcs5PBKDF2 key derivation functions are supported");const i=r.valueBlock.value[1],o=Di(i.valueBlock.value[0].getValue());let a=Nu,c=Lu;if(i.valueBlock.value.length===3)a=Number(i.valueBlock.value[1].toBigInt()),c=Number(i.valueBlock.value[2].toBigInt());else if(i.valueBlock.value.length===2)throw new B("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");const l=e.valueBlock.value[1].valueBlock.value[1],u=l.valueBlock.value[0].toString();if(u!=="OBJECT IDENTIFIER : 1.2.840.113549.3.7"){if(u!=="OBJECT IDENTIFIER : 1.3.14.3.2.7"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42")throw new B("Only AES-CBC encryption schemes are supported")}}}}const h=Di(l.valueBlock.value[1].getValue());return{cipherText:Di(n.valueBlock.value[1].getValue()),salt:o,iterations:a,keySize:c,iv:h}}function g0(n){return Di(n.valueBlock.value[2].getValue())}function Di(n){return new Uint8Array(n,0,n.byteLength)}const cD="/pkcs8/",Bu="/info/",gi=new WeakMap,_n={minKeyLength:112/8,minSaltLength:128/8,minIterationCount:1e3},Rl={dek:{keyLength:512/8,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function ps(n){return n==null||typeof n!="string"?!1:n===JC(n.trim())&&n.length>0}async function et(){const t=Math.random()*800+200;await new Promise(r=>setTimeout(r,t))}function xn(n){return new Te(cD+n)}function gs(n){return new Te(Bu+n)}async function lD(n){const e=ac(n),t=await Nt.digest(e);return ze.encode(t.bytes).substring(1)}class uD{components;init;log;constructor(e,t){if(this.components=e,this.log=e.logger.forComponent("libp2p:keychain"),this.init=Nh(Rl,t),this.init.pass!=null&&this.init.pass?.length<20)throw new Error("pass must be least 20 characters");if(this.init.dek?.keyLength!=null&&this.init.dek.keyLength<_n.minKeyLength)throw new Error(`dek.keyLength must be least ${_n.minKeyLength} bytes`);if(this.init.dek?.salt?.length!=null&&this.init.dek.salt.length<_n.minSaltLength)throw new Error(`dek.saltLength must be least ${_n.minSaltLength} bytes`);if(this.init.dek?.iterationCount!=null&&this.init.dek.iterationCount<_n.minIterationCount)throw new Error(`dek.iterationCount must be least ${_n.minIterationCount}`);const r=this.init.pass!=null&&this.init.dek?.salt!=null?Xd(this.init.pass,this.init.dek?.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";gi.set(this,{dek:r})}[Symbol.toStringTag]="@libp2p/keychain";[rt]=["@libp2p/keychain"];static generateOptions(){const e=Object.assign({},Rl),t=Math.ceil(_n.minSaltLength/3)*3;return e.dek.salt=K(un(t),"base64"),e}static get options(){return Rl}async findKeyByName(e){if(!ps(e))throw await et(),new B(`Invalid key name '${e}'`);const t=gs(e);try{const r=await this.components.datastore.get(t);return JSON.parse(K(r))}catch(r){throw await et(),this.log.error(r),new It(`Key '${e}' does not exist.`)}}async findKeyById(e){try{const t={prefix:Bu};for await(const r of this.components.datastore.query(t)){const s=JSON.parse(K(r.value));if(s.id===e)return s}throw new B(`Key with id '${e}' does not exist.`)}catch(t){throw await et(),t}}async importKey(e,t){if(!ps(e))throw await et(),new B(`Invalid key name '${e}'`);if(t==null)throw await et(),new B("Key is required");const r=xn(e);if(await this.components.datastore.has(r))throw await et(),new B(`Key '${e}' already exists`);let i,o;try{i=await lD(t);const l=gi.get(this);if(l==null)throw new B("dek missing");const u=l.dek;o=await f0(t,u,t.type==="RSA"?"pkcs-8":"libp2p-key")}catch(l){throw await et(),l}const a={name:e,id:i},c=this.components.datastore.batch();return c.put(r,V(o)),c.put(gs(e),V(JSON.stringify(a))),await c.commit(),a}async exportKey(e){if(!ps(e))throw await et(),new B(`Invalid key name '${e}'`);const t=xn(e);try{const r=await this.components.datastore.get(t),s=K(r),i=gi.get(this);if(i==null)throw new B("dek missing");const o=i.dek;return await p0(s,o)}catch(r){throw await et(),r}}async removeKey(e){if(!ps(e)||e==="self")throw await et(),new B(`Invalid key name '${e}'`);const t=xn(e),r=await this.findKeyByName(e),s=this.components.datastore.batch();return s.delete(t),s.delete(gs(e)),await s.commit(),r}async listKeys(){const e={prefix:Bu},t=[];for await(const r of this.components.datastore.query(e))t.push(JSON.parse(K(r.value)));return t}async renameKey(e,t){if(!ps(e)||e==="self")throw await et(),new B(`Invalid old key name '${e}'`);if(!ps(t)||t==="self")throw await et(),new B(`Invalid new key name '${t}'`);const r=xn(e),s=xn(t),i=gs(e),o=gs(t);if(await this.components.datastore.has(s))throw await et(),new B(`Key '${t}' already exists`);try{const c=await this.components.datastore.get(r),l=await this.components.datastore.get(i),u=JSON.parse(K(l));u.name=t;const h=this.components.datastore.batch();return h.put(s,c),h.put(o,V(JSON.stringify(u))),h.delete(r),h.delete(i),await h.commit(),u}catch(c){throw await et(),c}}async rotateKeychainPass(e,t){if(typeof e!="string")throw await et(),new B(`Invalid old pass type '${typeof e}'`);if(typeof t!="string")throw await et(),new B(`Invalid new pass type '${typeof t}'`);if(t.length<20)throw await et(),new B(`Invalid pass length ${t.length}`);this.log("recreating keychain");const r=gi.get(this);if(r==null)throw new B("dek missing");const s=r.dek;this.init.pass=t;const i=t!=null&&this.init.dek?.salt!=null?Xd(t,this.init.dek.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";gi.set(this,{dek:i});const o=await this.listKeys();for(const a of o){const c=await this.components.datastore.get(xn(a.name)),l=K(c),u=await p0(l,s),h=i.toString(),d=await f0(u,h,u.type==="RSA"?"pkcs-8":"libp2p-key"),f=this.components.datastore.batch(),p={name:a.name,id:a.id};f.put(xn(a.name),V(d)),f.put(gs(a.name),V(JSON.stringify(p))),await f.commit()}this.log("keychain reconstructed")}}function q4(n={}){return e=>new uD(e,n)}var de;(function(n){n[n.NEW_STREAM=0]="NEW_STREAM",n[n.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",n[n.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",n[n.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",n[n.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",n[n.RESET_RECEIVER=5]="RESET_RECEIVER",n[n.RESET_INITIATOR=6]="RESET_INITIATOR"})(de||(de={}));const id=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),m0=Object.freeze({NEW_STREAM:de.NEW_STREAM,MESSAGE:de.MESSAGE_INITIATOR,CLOSE:de.CLOSE_INITIATOR,RESET:de.RESET_INITIATOR}),hD=Object.freeze({MESSAGE:de.MESSAGE_RECEIVER,CLOSE:de.CLOSE_RECEIVER,RESET:de.RESET_RECEIVER}),K4=1<<20,dD=4<<20;class fD{_buffer;_headerInfo;_maxMessageSize;_maxUnprocessedMessageQueueSize;constructor(e=K4,t=dD){this._buffer=new ge,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(e==null||e.length===0)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw new Pe("Unprocessed message queue size too large!");const t=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(l){if(l.name==="InvalidMessageError")throw l;break}const{id:r,type:s,length:i,offset:o}=this._headerInfo;if(this._buffer.length-o<i)break;const c={id:r,type:s};(s===de.NEW_STREAM||s===de.MESSAGE_INITIATOR||s===de.MESSAGE_RECEIVER)&&(c.data=this._buffer.sublist(o,o+i)),t.push(c),this._buffer.consume(o+i),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:r}=w0(e),{value:s,offset:i}=w0(e,r),o=t&7;if(id[o]==null)throw new Error(`Invalid type received: ${o}`);if(s>this._maxMessageSize)throw new Pe("Message size too large");return{id:t>>3,type:o,offset:r+i,length:s}}}const pD=128,y0=127;function w0(n,e=0){let t=0,r=0,s=e,i;const o=n.length;do{if(s>=o||r>49)throw e=0,new RangeError("Could not decode varint");i=n.get(s++),t+=r<28?(i&y0)<<r:(i&y0)*Math.pow(2,r),r+=7}while(i>=pD);return e=s-e,{value:t,offset:e}}const Ml=10*1024;class gD{_pool;_poolOffset;constructor(){this._pool=ct(Ml),this._poolOffset=0}write(e,t){const r=this._pool;let s=this._poolOffset;Ze(e.id<<3|e.type,r,s),s+=ye(e.id<<3|e.type),(e.type===de.NEW_STREAM||e.type===de.MESSAGE_INITIATOR||e.type===de.MESSAGE_RECEIVER)&&e.data!=null?(Ze(e.data.length,r,s),s+=ye(e.data.length)):(Ze(0,r,s),s+=ye(0));const i=r.subarray(this._poolOffset,s);Ml-s<100?(this._pool=ct(Ml),this._poolOffset=0):this._poolOffset=s,t.append(i),(e.type===de.NEW_STREAM||e.type===de.MESSAGE_INITIATOR||e.type===de.MESSAGE_RECEIVER)&&e.data!=null&&t.append(e.data)}}const mD=new gD;async function*yD(n){for await(const e of n){const t=new ge;mD.write(e,t),yield t}}class wD extends Error{constructor(e="Stream input buffer error"){super(e),this.name="StreamInputBufferError"}}class bD extends vh{name;streamId;send;types;maxDataSize;constructor(e){super(e),this.types=e.direction==="outbound"?m0:hD,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:m0.NEW_STREAM,data:new ge(V(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,t)}),e.consume(t)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}function vD(n){const{id:e,name:t,send:r,onEnd:s,type:i="initiator",maxMsgSize:o=K4}=n;return new bD({id:i==="initiator"?`i${e}`:`r${e}`,streamId:e,name:`${t??e}`,direction:i==="initiator"?"outbound":"inbound",maxDataSize:o,onEnd:s,send:r,log:n.logger.forComponent(`libp2p:mplex:stream:${i}:${e}`)})}const ED=1024,SD=1024,_D=1024*1024*4,xD=5,kD=500;function b0(n){const e={...n,type:`${id[n.type]} (${n.type})`};return n.type===de.NEW_STREAM&&(e.data=K(n.data instanceof Uint8Array?n.data:n.data.subarray())),(n.type===de.MESSAGE_INITIATOR||n.type===de.MESSAGE_RECEIVER)&&(e.data=K(n.data instanceof Uint8Array?n.data:n.data.subarray(),"base16")),e}class ID{protocol="/mplex/6.7.0";sink;source;log;_streamId;_streams;_init;_source;closeController;rateLimiter;closeTimeout;logger;constructor(e,t){t=t??{},this.log=e.logger.forComponent("libp2p:mplex"),this.logger=e.logger,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=t,this.closeTimeout=t.closeTimeout??kD,this.sink=this._createSink(),this._source=_r({objectMode:!0,onEnd:()=>{for(const r of this._streams.initiators.values())r.destroy();for(const r of this._streams.receivers.values())r.destroy()}}),this.source=Bt(this._source,r=>yD(r)),this.closeController=new AbortController,this.rateLimiter=new xg({points:t.disconnectThreshold??xD,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new ms("Muxer already closed");const t=this._streamId++;e=e==null?t.toString():e.toString();const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}async close(e){if(this.closeController.signal.aborted)return;const t=e?.signal??AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map(async r=>r.close({signal:t}))),this._source.end(),await this._source.onEmpty({signal:t}),this.closeController.abort()}catch(r){this.abort(r)}}abort(e){this.closeController.signal.aborted||(this.streams.forEach(t=>{t.abort(e)}),this.closeController.abort(e))}_newReceiverStream(e){const{id:t,name:r}=e,s=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:s})}_newStream(e){const{id:t,name:r,type:s,registry:i}=e;if(this.log("new %s stream %s",s,t),s==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??SD))throw new Vu("Too many outbound streams open");if(i.has(t))throw new Error(`${s} stream ${t} already exists!`);const c=vD({id:t,name:r,send:async l=>{this.log.enabled&&this.log.trace("%s stream %s send",s,t,b0(l)),this._source.push(l)},type:s,onEnd:()=>{this.log("%s stream with id %s and protocol %s ended",s,t,c.protocol),i.delete(t),this._init.onStreamEnd!=null&&this._init.onStreamEnd(c)},maxMsgSize:this._init.maxMsgSize,logger:this.logger});return i.set(t,c),c}_createSink(){return async t=>{const r=()=>{Sp(t,this.log)};this.closeController.signal.addEventListener("abort",r);try{const s=new fD(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const i of t)for(const o of s.write(i))await this._handleIncoming(o);this._source.end()}catch(s){this.log("error in sink",s),this._source.end(s)}finally{this.closeController.signal.removeEventListener("abort",r)}}}async _handleIncoming(e){const{id:t,type:r}=e;if(this.log.enabled&&this.log.trace("incoming message",b0(e)),e.type===de.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??ED)){this.log("too many inbound streams open"),this._source.push({id:t,type:de.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this.abort(new Error("Too many open streams"));return}return}const a=this._newReceiverStream({id:t,name:K(e.data instanceof Uint8Array?e.data:e.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(a);return}const i=((r&1)===1?this._streams.initiators:this._streams.receivers).get(t);if(i==null){this.log("missing stream %s for message type %s",t,id[r]);try{await this.rateLimiter.consume("missing-stream",1)}catch{this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),this.abort(new Error("Too many messages for missing streams"));return}return}const o=this._init.maxStreamBufferSize??_D;try{switch(r){case de.MESSAGE_INITIATOR:case de.MESSAGE_RECEIVER:if(i.sourceReadableLength()>o)throw this._source.push({id:e.id,type:r===de.MESSAGE_INITIATOR?de.RESET_RECEIVER:de.RESET_INITIATOR}),new wD("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");i.sourcePush(e.data);break;case de.CLOSE_INITIATOR:case de.CLOSE_RECEIVER:i.remoteCloseWrite();break;case de.RESET_INITIATOR:case de.RESET_RECEIVER:i.reset();break;default:this.log("unknown message type %s",r)}}catch(a){this.log.error("error while processing message",a),i.abort(a)}}}class AD{protocol="/mplex/6.7.0";_init;components;constructor(e,t={}){this.components=e,this._init=t}[Symbol.toStringTag]="@libp2p/mplex";[rt]=["@libp2p/stream-multiplexing"];createStreamMuxer(e={}){return new ID(this.components,{...e,...this._init})}}function TD(n={}){return e=>new AD(e,n)}const Ll=32,PD="1.0.0",CD="ping",DD="ipfs",RD=1e4,MD=2,LD=1;class ND{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??DD}/${CD}/${PD}`,this.timeout=t.timeout??RD,this.maxInboundStreams=t.maxInboundStreams??MD,this.maxOutboundStreams=t.maxOutboundStreams??LD,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,r=Date.now(),s=la(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Ya("ping timeout"))});const a=await s.read(Ll,{signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-r;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const r=Date.now(),s=un(Ll),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=la(o),[,c]=await Promise.all([a.write(s,t),a.read(Ll,t)]),l=Date.now()-r;if(!pe(s,c.subarray()))throw new a6(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function BD(n={}){return e=>new ND(e,n)}function OD(n,e){const t=e.map((r,s)=>({record:ho(r),index:s}));return t.sort((r,s)=>{const i=r.record.sequence,o=s.record.sequence;if(i>o)return-1;if(i<o)return 1;if(r.record.validityType===ir.ValidityType.EOL&&s.record.validityType===ir.ValidityType.EOL){const a=Su.fromString(r.record.validity).toDate(),c=Su.fromString(s.record.validity).toDate();if(a.getTime()>c.getTime())return-1;if(a.getTime()<c.getTime())return 1}return 0}),t[0].index}const FD="5.2.1",UD="helia",$D={list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8","/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"]};function VD(n={}){const e=`${UD}/${FD} ${Fg()}`;return{privateKey:n.privateKey,dns:n.dns,nodeInfo:{userAgent:e},addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[qp(),lg(),IE(),pg()],connectionEncrypters:[wh()],streamMuxers:[xp(),TD()],peerDiscovery:[pP($D)],services:{autoNAT:rP(),dcutr:Wp(),delegatedRouting:()=>gT("https://delegated-ipfs.dev",mT()),dht:GC({clientMode:!0,validators:{ipns:x4},selectors:{ipns:OD}}),identify:Xp(),identifyPush:wv(),keychain:q4(n.keychain),ping:BD()}}}async function HD(n,e={}){const t=q4(e)({datastore:n,logger:wc()}),r=new Te("/pkcs8/self");let s;return await n.has(r)?s=await t.exportKey("self"):(s=await B3(e.keyType??"Ed25519"),await t.importKey("self",s)),s}async function zD(n){const e=n.libp2p??{};e.privateKey==null&&n.datastore!=null&&(e.privateKey=await HD(n.datastore,n.keychain));const t=VD(e);return t.datastore=t.datastore??n.datastore,await Ug({...t,...e,start:!1})}async function qD(n={}){const e=n.datastore??new _g,t=n.blockstore??new VT;let r;KD(n.libp2p)?r=n.libp2p:r=await zD({...n,libp2p:{dns:n.dns,...n.libp2p,start:void 0},datastore:e});const s=new zT({...n,libp2p:r,datastore:e,blockstore:t,blockBrokers:n.blockBrokers??[GA(),VA()],routers:n.routers??[$T(r),FT()],metrics:r.metrics});return n.start!==!1&&await s.start(),s}function KD(n){return n==null?!1:["dial","dialProtocol","hangUp","handle","unhandle","getMultiaddrs","getProtocols"].every(t=>typeof n[t]=="function")}const dt={peerId:()=>document.getElementById("peer-id"),dialMultiaddrInput:()=>document.getElementById("dial-multiaddr-input"),dialMultiaddrButton:()=>document.getElementById("dial-multiaddr-button"),subscribeTopicInput:()=>document.getElementById("subscribe-topic-input"),subscribeTopicButton:()=>document.getElementById("subscribe-topic-button"),sendTopicMessageInput:()=>document.getElementById("send-topic-message-input"),sendTopicMessageButton:()=>document.getElementById("send-topic-message-button"),output:()=>document.getElementById("output"),listeningAddressesList:()=>document.getElementById("listening-addresses"),peerConnectionsList:()=>document.getElementById("peer-connections"),topicPeerList:()=>document.getElementById("topic-peers")},Ys=n=>{dt.output().innerText+=`${n}
`},W4=n=>n.replaceAll(`
`,""),WD=Ug({addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[pg({filter:fg}),lg(),qp()],connectionEncrypters:[wh()],streamMuxers:[xp()],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:Xp(),pubsub:vy(),dcutr:Wp()}}),GD=await qD({libp2p:WD}),{libp2p:Wt}=GD;dt.peerId().innerText=Wt.peerId.toString();function G4(){const n=Wt.getPeers().map(e=>{const t=document.createElement("li");t.textContent=e.toString();const r=document.createElement("ul");for(const s of Wt.getConnections(e)){const i=document.createElement("li");i.textContent=s.remoteAddr.toString(),r.appendChild(i)}return t.appendChild(r),t});dt.peerConnectionsList().replaceChildren(...n)}Wt.addEventListener("connection:open",()=>{G4()});Wt.addEventListener("connection:close",()=>{G4()});Wt.addEventListener("self:peer:update",()=>{const n=Wt.getMultiaddrs().map(e=>{const t=document.createElement("li");return t.textContent=e.toString(),t});dt.listeningAddressesList().replaceChildren(...n)});dt.dialMultiaddrButton().onclick=async()=>{const n=re(dt.dialMultiaddrInput().value);Ys(`Dialing '${n}'`),await Wt.dial(n),Ys(`Connected to '${n}'`)};dt.subscribeTopicButton().onclick=async()=>{const n=dt.subscribeTopicInput().value;Ys(`Subscribing to '${W4(n)}'`),Wt.services.pubsub.subscribe(n),dt.sendTopicMessageInput().disabled=void 0,dt.sendTopicMessageButton().disabled=void 0};dt.sendTopicMessageButton().onclick=async()=>{const n=dt.subscribeTopicInput().value,e=dt.sendTopicMessageInput().value;Ys(`Sending message '${W4(e)}'`),await Wt.services.pubsub.publish(n,V(e))};setInterval(()=>{const n=dt.subscribeTopicInput().value,e=Wt.services.pubsub.getSubscribers(n).map(t=>{const r=document.createElement("li");return r.textContent=t.toString(),r});dt.topicPeerList().replaceChildren(...e)},500);Wt.services.pubsub.addEventListener("message",n=>{const e=n.detail.topic,t=K(n.detail.data);Ys(`Message received on topic '${e}'`),Ys(t)});
